<?xml version="1.0" encoding="UTF-8"?>
<mixpanel_backend_implementation>
  <project_info>
    <project_name>Sometimes App - ë°±ì—”ë“œ Mixpanel í†µí•©</project_name>
    <created_date>2025-12-29</created_date>
    <target_audience>ë°±ì—”ë“œ ê°œë°œíŒ€</target_audience>
    <implementation_period>1-2ì£¼ (Phase 1)</implementation_period>
  </project_info>

  <credentials>
    <mixpanel_project_token>3f1b97d815027821e7e1e93c73bad5a4</mixpanel_project_token>
    <mixpanel_api_secret>5252bedfc90bf837e5b9af70a38b9ab7</mixpanel_api_secret>
    <data_residency>US (í•œêµ­ ì‚¬ìš©ì)</data_residency>
  </credentials>

  <overview>
    <total_events>27ê°œ</total_events>
    <priority_breakdown>
      <high_priority count="8">ìµœìš°ì„  (1-2ì£¼) - Invite_Conversion ì¶”ê°€</high_priority>
      <medium_priority count="9">ë†’ì€ ìš°ì„ ìˆœìœ„ (2-3ì£¼) - Referral_Signup ì œê±°</medium_priority>
      <low_priority count="9">ì¤‘ê°„ ìš°ì„ ìˆœìœ„ (1ê°œì›”)</low_priority>
    </priority_breakdown>
    <duplicate_status>âœ… í´ë¼ì´ì–¸íŠ¸ ì¤‘ë³µ ì™„ì „ ì œê±° ì™„ë£Œ</duplicate_status>
    <note>âŒ Invite_Link_ClickedëŠ” í´ë¼ì´ì–¸íŠ¸ ì¤‘ë³µìœ¼ë¡œ ì„œë²„ êµ¬í˜„ ì•ˆ í•¨</note>
  </overview>

  <setup>
    <step number="1">
      <title>Mixpanel SDK ì„¤ì¹˜</title>
      <command>npm install mixpanel</command>
      <verification>package.jsonì— "mixpanel" í™•ì¸</verification>
    </step>

    <step number="2">
      <title>í™˜ê²½ë³€ìˆ˜ ì„¤ì •</title>
      <file_path>.env</file_path>
      <content><![CDATA[
# Mixpanel Configuration
MIXPANEL_PROJECT_TOKEN=3f1b97d815027821e7e1e93c73bad5a4
MIXPANEL_API_SECRET=5252bedfc90bf837e5b9af70a38b9ab7
MIXPANEL_DEBUG=true  # ê°œë°œ í™˜ê²½ì—ì„œë§Œ
NODE_ENV=development

# Slack Alerts (ì„ íƒ)
SLACK_BOT_TOKEN=xoxb-your-bot-token
SLACK_MATCHING_ALERT_CHANNEL=#matching-alerts
      ]]></content>
    </step>

    <step number="3">
      <title>Mixpanel í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”</title>
      <file_path>src/libs/mixpanel.ts</file_path>
      <content><![CDATA[
import Mixpanel from 'mixpanel';

// Mixpanel ì´ˆê¸°í™”
const mixpanel = Mixpanel.init(process.env.MIXPANEL_PROJECT_TOKEN!, {
  debug: process.env.MIXPANEL_DEBUG === 'true',
  verbose: process.env.NODE_ENV === 'development',
});

/**
 * Mixpanel ì´ë²¤íŠ¸ Tracking í—¬í¼ í•¨ìˆ˜
 */
export const trackEvent = (
  eventName: string,
  distinctId: string,
  properties: Record<string, any> = {}
) => {
  try {
    mixpanel.track(eventName, {
      distinct_id: distinctId,
      ...properties,
      env: process.env.NODE_ENV,
      timestamp: Date.now(),
    });
  } catch (error) {
    console.error(`[Mixpanel] Failed to track "${eventName}":`, error);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ê³„ì† ì§„í–‰
  }
};

/**
 * ì‚¬ìš©ì í”„ë¡œí•„ ì„¤ì •
 */
export const setUserProfile = (
  distinctId: string,
  properties: Record<string, any>
) => {
  mixpanel.people.set(distinctId, {
    ...properties,
    $ip: '0', // ì„œë²„ IP ì‚¬ìš© ì•ˆ í•¨ (ì§€ì—­ ì •ë³´ ì™œê³¡ ë°©ì§€)
  });
};

/**
 * ì‚¬ìš©ì í”„ë¡œí•„ ì†ì„± ì¦ê°€
 */
export const incrementUserProfile = (
  distinctId: string,
  property: string,
  incrementBy: number = 1
) => {
  mixpanel.people.increment(distinctId, property, incrementBy);
};

export default mixpanel;
      ]]></content>
    </step>
  </setup>

  <!-- ========================================
       Phase 1: ìµœìš°ì„  ìˆœìœ„ ì´ë²¤íŠ¸ (7ê°œ)
       ======================================== -->

  <phase priority="1" duration="1-2ì£¼">
    <title>Phase 1: ìµœìš°ì„  ìˆœìœ„ ì´ë²¤íŠ¸ êµ¬í˜„</title>
    <event_count>8ê°œ</event_count>
    <note>â­ Invite_Conversion_Completed ì¶”ê°€ë¨</note>

    <!-- 1. Payment_Completed -->
    <event id="1">
      <name>Payment_Completed</name>
      <category>ê²°ì œ</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âœ… í´ë¼ì´ì–¸íŠ¸ ì¤‘ë³µ ì œê±° ì™„ë£Œ (3ê³³ ì œê±°ë¨)</duplicate_status>

      <description>
        PGì‚¬ ì½œë°± ê²€ì¦ í›„ ê²°ì œ ì™„ë£Œ í™•ì • ì‹œ tracking.
        í´ë¼ì´ì–¸íŠ¸ëŠ” ì¡°ì‘ ê°€ëŠ¥í•˜ë¯€ë¡œ ì„œë²„ì—ì„œë§Œ tracking í•„ìˆ˜.
      </description>

      <business_impact>
        <metric>ê²°ì œ ì„±ê³µë¥ </metric>
        <metric>ì²« êµ¬ë§¤ ì „í™˜ìœ¨</metric>
        <metric>ARPU (Average Revenue Per User)</metric>
      </business_impact>

      <implementation>
        <file_path>src/controllers/payment.controller.ts</file_path>
        <api_endpoint>POST /api/v1/payment/verify</api_endpoint>
        <trigger>PGì‚¬ ì½œë°± ê²€ì¦ ì™„ë£Œ í›„</trigger>

        <code><![CDATA[
import { trackEvent, setUserProfile, incrementUserProfile } from '@/libs/mixpanel';

/**
 * POST /api/v1/payment/verify
 * PGì‚¬ ì½œë°± ê²€ì¦ ë° ê²°ì œ ì™„ë£Œ ì²˜ë¦¬
 */
export async function verifyPayment(req: Request, res: Response) {
  try {
    const { transactionId, paymentId, amount, method, userId } = req.body;

    // 1. PGì‚¬ ê²€ì¦
    const verified = await verifyPGCallback({
      transactionId,
      paymentId,
      amount,
    });

    if (!verified) {
      return res.status(400).json({
        success: false,
        error: 'Payment verification failed',
      });
    }

    // 2. DB ì—…ë°ì´íŠ¸
    await updatePaymentStatus(transactionId, 'completed');

    // 3. ì²« êµ¬ë§¤ ì—¬ë¶€ í™•ì¸
    const isFirstPurchase = await checkIsFirstPurchase(userId);

    // 4. ğŸ¯ Mixpanel Tracking (ì„œë²„ ì „ìš©)
    trackEvent(
      isFirstPurchase ? 'Payment_First_Purchase' : 'Payment_Completed',
      userId,
      {
        transaction_id: transactionId,
        payment_id: paymentId,
        total_amount: amount,
        payment_method: method,
        payment_provider: 'portone',
        is_first_purchase: isFirstPurchase,
        currency: 'KRW',
        verified_at_server: true, // ì„œë²„ ê²€ì¦ í‘œì‹œ
      }
    );

    // 5. ì‚¬ìš©ì í”„ë¡œí•„ ì—…ë°ì´íŠ¸
    if (isFirstPurchase) {
      setUserProfile(userId, {
        $name: req.user.name,
        $email: req.user.email,
        first_purchase_date: new Date().toISOString(),
        total_revenue: amount,
      });
    } else {
      incrementUserProfile(userId, 'total_revenue', amount);
      incrementUserProfile(userId, 'purchase_count', 1);
    }

    res.json({
      success: true,
      message: 'Payment verified successfully',
    });
  } catch (error) {
    console.error('Payment verification error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    });
  }
}
        ]]></code>

        <helper_functions><![CDATA[
/**
 * ì²« êµ¬ë§¤ ì—¬ë¶€ í™•ì¸
 */
export async function checkIsFirstPurchase(userId: string): Promise<boolean> {
  const count = await Payment.count({
    where: {
      userId,
      status: 'completed',
    },
  });

  return count === 0;
}
        ]]></helper_functions>
      </implementation>

      <testing>
        <test_case>
          <name>ì²« êµ¬ë§¤ ê²€ì¦</name>
          <command><![CDATA[
curl -X POST http://localhost:3000/api/v1/payment/verify \
  -H "Content-Type: application/json" \
  -d '{
    "userId": "test-user-123",
    "transactionId": "txn_test_123",
    "amount": 9900,
    "method": "card"
  }'
          ]]></command>
          <expected_event>Payment_First_Purchase</expected_event>
        </test_case>

        <verification>
          <step>Mixpanel â†’ Live View ì ‘ì†</step>
          <step>ì´ë²¤íŠ¸ í•„í„°: "Payment_First_Purchase"</step>
          <step>ì†ì„± í™•ì¸: verified_at_server = true</step>
        </verification>
      </testing>
    </event>

    <!-- 2. Subscription_Renewed -->
    <event id="2">
      <name>Subscription_Renewed</name>
      <category>ê²°ì œ</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âœ… ì¤‘ë³µ ì—†ìŒ</duplicate_status>

      <description>
        êµ¬ë… ìë™ ê°±ì‹  ì‹œ tracking. Webhook ë˜ëŠ” Cron Jobìœ¼ë¡œ êµ¬í˜„.
      </description>

      <business_impact>
        <metric>êµ¬ë… ìœ ì§€ìœ¨</metric>
        <metric>MRR (Monthly Recurring Revenue)</metric>
        <metric>LTV ì¦ê°€</metric>
      </business_impact>

      <implementation>
        <file_path>src/webhooks/subscription.webhook.ts</file_path>
        <api_endpoint>POST /api/v1/webhooks/subscription/renew</api_endpoint>
        <trigger>PGì‚¬ êµ¬ë… ê°±ì‹  Webhook</trigger>

        <code><![CDATA[
import { Request, Response } from 'express';
import { trackEvent, incrementUserProfile } from '@/libs/mixpanel';
import { updateSubscriptionStatus } from '@/services/subscription.service';

/**
 * POST /api/v1/webhooks/subscription/renew
 * PGì‚¬ êµ¬ë… ê°±ì‹  Webhook í•¸ë“¤ëŸ¬
 */
export async function handleSubscriptionRenew(req: Request, res: Response) {
  try {
    const { userId, subscriptionId, billingDate, amount, tier } = req.body;

    // 1. ì„œëª… ê²€ì¦ (PGì‚¬ ì œê³µ)
    const isValid = verifyWebhookSignature(req);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid signature' });
    }

    // 2. DB ì—…ë°ì´íŠ¸
    await updateSubscriptionStatus(subscriptionId, {
      status: 'active',
      nextBillingDate: calculateNextBillingDate(billingDate),
      lastRenewalDate: new Date(),
    });

    // 3. ğŸ¯ Mixpanel Tracking
    trackEvent('Subscription_Renewed', userId, {
      subscription_id: subscriptionId,
      subscription_tier: tier, // 'basic' | 'premium' | 'vip'
      renewal_amount: amount,
      billing_date: billingDate,
      renewal_count: await getSubscriptionRenewalCount(subscriptionId),
      renewed_via_webhook: true,
    });

    // 4. ì‚¬ìš©ì í”„ë¡œí•„ ì—…ë°ì´íŠ¸
    incrementUserProfile(userId, 'subscription_renewal_count', 1);
    incrementUserProfile(userId, 'total_revenue', amount);

    res.json({ success: true });
  } catch (error) {
    console.error('Subscription renewal error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

function calculateNextBillingDate(currentDate: string): Date {
  const date = new Date(currentDate);
  date.setMonth(date.getMonth() + 1);
  return date;
}
        ]]></code>
      </implementation>
    </event>

    <!-- 3. Like_Received -->
    <event id="3">
      <name>Like_Received</name>
      <category>ì¢‹ì•„ìš”</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âš ï¸ í´ë¼ì´ì–¸íŠ¸ ë³‘í–‰ (tracking_sourceë¡œ êµ¬ë¶„)</duplicate_status>

      <description>
        ìƒëŒ€ë°©ì´ ì¢‹ì•„ìš”ë¥¼ ë°›ìŒ. ìˆ˜ì‹ ìëŠ” í´ë¼ì´ì–¸íŠ¸ì—ì„œ tracking ë¶ˆê°€ëŠ¥.
        ì„œë²„ëŠ” ì‹¤ì‹œê°„, í´ë¼ì´ì–¸íŠ¸ëŠ” polling ë°±ì—…ìš©.
      </description>

      <business_impact>
        <metric>ì¢‹ì•„ìš” ìˆ˜ì‹ ë¥ </metric>
        <metric>ì¢‹ì•„ìš” â†’ ë§¤ì¹­ ì „í™˜ìœ¨</metric>
      </business_impact>

      <implementation>
        <file_path>src/controllers/like.controller.ts</file_path>
        <api_endpoint>POST /api/v1/likes</api_endpoint>
        <trigger>ì¢‹ì•„ìš” ìƒì„± ì‹œ</trigger>

        <code><![CDATA[
import { trackEvent } from '@/libs/mixpanel';
import { createLike, checkMutualLike, createMatch } from '@/services/like.service';

/**
 * POST /api/v1/likes
 * ì¢‹ì•„ìš” ìƒì„± ë° tracking
 */
export async function sendLike(req: Request, res: Response) {
  try {
    const senderId = req.user.id;
    const { targetUserId, likeType } = req.body; // 'free' | 'super'

    // 1. ì¢‹ì•„ìš” ìƒì„±
    const like = await createLike({
      senderId,
      targetUserId,
      likeType,
    });

    // 2. ğŸ¯ ìƒëŒ€ë°© ì¢‹ì•„ìš” ìˆ˜ì‹  tracking (ì„œë²„ ì „ìš©)
    trackEvent('Like_Received', targetUserId, {
      source_profile_id: senderId,
      like_type: likeType,
      tracking_source: 'server_realtime', // í´ë¼ì´ì–¸íŠ¸ì™€ êµ¬ë¶„
    });

    // 3. ìƒí˜¸ ì¢‹ì•„ìš” í™•ì¸
    const isMutualLike = await checkMutualLike(senderId, targetUserId);
    let matchId: string | null = null;

    if (isMutualLike) {
      // 4. ë§¤ì¹­ ìƒì„±
      const match = await createMatch(senderId, targetUserId);
      matchId = match.id;

      // 5. ğŸ¯ ë§¤ì¹­ ì„±ì‚¬ tracking (ì–‘ìª½ ëª¨ë‘)
      trackEvent('Like_Match_Created', senderId, {
        target_profile_id: targetUserId,
        match_id: matchId,
        is_mutual: true,
        like_type: likeType,
      });

      trackEvent('Like_Match_Created', targetUserId, {
        target_profile_id: senderId,
        match_id: matchId,
        is_mutual: true,
        like_type: likeType,
      });

      // 6. ğŸ¯ ë§¤ì¹­ ì„±ê³µ tracking (ì–‘ìª½ ëª¨ë‘)
      trackEvent('Matching_Success', senderId, {
        match_id: matchId,
        partner_id: targetUserId,
        matching_type: 'like',
      });

      trackEvent('Matching_Success', targetUserId, {
        match_id: matchId,
        partner_id: senderId,
        matching_type: 'like',
      });
    }

    res.json({
      success: true,
      isMatch: isMutualLike,
      matchId,
    });
  } catch (error) {
    console.error('Send like error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    });
  }
}
        ]]></code>

        <helper_functions><![CDATA[
/**
 * ìƒí˜¸ ì¢‹ì•„ìš” í™•ì¸
 */
async function checkMutualLike(user1Id: string, user2Id: string): Promise<boolean> {
  const like1 = await Like.findOne({
    where: { senderId: user1Id, targetUserId: user2Id },
  });

  const like2 = await Like.findOne({
    where: { senderId: user2Id, targetUserId: user1Id },
  });

  return !!like1 && !!like2;
}
        ]]></helper_functions>
      </implementation>

      <note>
        âš ï¸ í´ë¼ì´ì–¸íŠ¸ë„ pollingìœ¼ë¡œ tracking ì¤‘ (use-liked-me-query.tsx)
        â†’ tracking_sourceë¡œ êµ¬ë¶„í•˜ë¯€ë¡œ ì¤‘ë³µ ë¬¸ì œ ì—†ìŒ
        â†’ ì„œë²„: 'server_realtime', í´ë¼ì´ì–¸íŠ¸: 'client_polling'
      </note>
    </event>

    <!-- 4. Like_Match_Created -->
    <event id="4">
      <name>Like_Match_Created</name>
      <category>ì¢‹ì•„ìš”</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âœ… ì¤‘ë³µ ì—†ìŒ</duplicate_status>

      <description>
        ìƒí˜¸ ì¢‹ì•„ìš”ë¡œ ë§¤ì¹­ ì„±ì‚¬. ì–‘ë°©í–¥ í™•ì¸ì€ ì„œë²„ë§Œ ê°€ëŠ¥.
      </description>

      <implementation>
        <note>ìœ„ Like_Received ì´ë²¤íŠ¸ ì½”ë“œì— í¬í•¨ë¨ (Line 5-6 ì°¸ê³ )</note>
        <tracking_point>ìƒí˜¸ ì¢‹ì•„ìš” í™•ì¸ í›„ ì–‘ìª½ ëª¨ë‘ tracking</tracking_point>
      </implementation>
    </event>

    <!-- 5. Matching_Success -->
    <event id="5">
      <name>Matching_Success</name>
      <category>ë§¤ì¹­</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âœ… í´ë¼ì´ì–¸íŠ¸ ì˜ëª»ëœ ì‚¬ìš© ì œê±° ì™„ë£Œ</duplicate_status>

      <description>
        ë§¤ì¹­ ì„±ê³µ (ìƒí˜¸ ì¢‹ì•„ìš” ë˜ëŠ” ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜).
        í´ë¼ì´ì–¸íŠ¸ëŠ” ì–‘ë°©í–¥ í™•ì¸ ë¶ˆê°€ëŠ¥.
      </description>

      <implementation>
        <note>ìœ„ Like_Received ì´ë²¤íŠ¸ ì½”ë“œì— í¬í•¨ë¨ (Line 6 ì°¸ê³ )</note>
        <tracking_point>ë§¤ì¹­ ìƒì„± í›„ ì–‘ìª½ ëª¨ë‘ tracking</tracking_point>
      </implementation>
    </event>

    <!-- 6. Day_1/7/30_Retention -->
    <event id="6">
      <name>Day_1/3/7/30_Retention</name>
      <category>ë¦¬í…ì…˜</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âœ… ì¤‘ë³µ ì—†ìŒ</duplicate_status>

      <description>
        ê°€ì…ì¼ ê¸°ì¤€ 1ì¼, 3ì¼, 7ì¼, 30ì¼ì°¨ ë¦¬í…ì…˜ ì½”í˜¸íŠ¸ ì¶”ì .
        ì‹œê°„ ê¸°ë°˜ ê³„ì‚°ì€ ì„œë²„ Cron Job í•„ìˆ˜.
      </description>

      <business_impact>
        <metric>ì½”í˜¸íŠ¸ë³„ ë¦¬í…ì…˜ ê³¡ì„ </metric>
        <metric>Aha Moment íŒŒì•…</metric>
        <metric>ì´íƒˆ ì˜ˆì¸¡</metric>
      </business_impact>

      <implementation>
        <file_path>src/jobs/retention.job.ts</file_path>
        <trigger>Cron Job - ë§¤ì¼ ì˜¤ì „ 3ì‹œ</trigger>
        <cron_schedule>0 3 * * *</cron_schedule>

        <code><![CDATA[
import cron from 'node-cron';
import { trackEvent } from '@/libs/mixpanel';
import { User } from '@/models/user.model';

/**
 * ë¦¬í…ì…˜ ì¶”ì  Cron Job
 * ë§¤ì¼ ì˜¤ì „ 3ì‹œ ì‹¤í–‰
 */
export function setupRetentionTracking() {
  cron.schedule('0 3 * * *', async () => {
    console.log('[Cron] Running daily retention tracking...');

    try {
      const today = new Date();

      // ë¦¬í…ì…˜ ì²´í¬ ëŒ€ìƒ ì‚¬ìš©ì ì¡°íšŒ
      const usersToCheck = await User.findAll({
        where: {
          signupDate: {
            $in: [
              calculateDate(today, -1),   // Day 1
              calculateDate(today, -3),   // Day 3
              calculateDate(today, -7),   // Day 7
              calculateDate(today, -30),  // Day 30
            ],
          },
        },
      });

      // ê° ì‚¬ìš©ìë³„ ë¦¬í…ì…˜ tracking
      for (const user of usersToCheck) {
        const daysSinceSignup = calculateDaysSinceSignup(user.signupDate);

        // ë¦¬í…ì…˜ ì§€í‘œ ìˆ˜ì§‘
        const hasMatch = await hasUserMatch(user.id);
        const hasSentMessage = await hasUserSentMessage(user.id);
        const matchesCount = await getUserMatchesCount(user.id);
        const messagesCount = await getUserMessagesCount(user.id);
        const hasPurchased = await hasUserPurchased(user.id);

        const retentionData = {
          days_since_signup: daysSinceSignup,
          first_match_achieved: hasMatch,
          first_message_sent: hasSentMessage,
          matches_count: matchesCount,
          messages_sent: messagesCount,
          has_purchased: hasPurchased,
          tracked_via_cron: true,
        };

        // ğŸ¯ Dayë³„ Tracking
        if (daysSinceSignup === 1) {
          trackEvent('Day_1_Retention', user.id, retentionData);
        } else if (daysSinceSignup === 3) {
          trackEvent('Day_3_Retention', user.id, retentionData);
        } else if (daysSinceSignup === 7) {
          trackEvent('Day_7_Retention', user.id, retentionData);
        } else if (daysSinceSignup === 30) {
          trackEvent('Day_30_Retention', user.id, retentionData);
        }
      }

      console.log(`[Cron] Retention tracked for ${usersToCheck.length} users`);
    } catch (error) {
      console.error('[Cron] Retention tracking error:', error);
    }
  });
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
function calculateDate(baseDate: Date, daysOffset: number): Date {
  const date = new Date(baseDate);
  date.setDate(date.getDate() + daysOffset);
  date.setHours(0, 0, 0, 0);
  return date;
}

function calculateDaysSinceSignup(signupDate: Date): number {
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - signupDate.getTime());
  return Math.floor(diffTime / (1000 * 60 * 60 * 24));
}

async function hasUserMatch(userId: string): Promise<boolean> {
  const count = await Match.count({ where: { userId } });
  return count > 0;
}

async function hasUserSentMessage(userId: string): Promise<boolean> {
  const count = await Message.count({ where: { senderId: userId } });
  return count > 0;
}

async function getUserMatchesCount(userId: string): Promise<number> {
  return await Match.count({ where: { userId } });
}

async function getUserMessagesCount(userId: string): Promise<number> {
  return await Message.count({ where: { senderId: userId } });
}

async function hasUserPurchased(userId: string): Promise<boolean> {
  const count = await Payment.count({
    where: { userId, status: 'completed' },
  });
  return count > 0;
}
        ]]></code>

        <cron_registration><![CDATA[
// src/index.ts
import { setupRetentionTracking } from '@/jobs/retention.job';

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);

  // Cron Job ë“±ë¡
  setupRetentionTracking();
});
        ]]></cron_registration>
      </implementation>
    </event>

    <!-- 7. Chat_24h_Active -->
    <event id="7">
      <name>Chat_24h_Active</name>
      <category>ì±„íŒ…</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âš ï¸ í´ë¼ì´ì–¸íŠ¸ ë³‘í–‰ (tracking_sourceë¡œ êµ¬ë¶„)</duplicate_status>

      <description>
        ë§¤ì¹­ í›„ 24ì‹œê°„ ë‚´ ëŒ€í™” í™œì„±ë„ ì¶”ì .
        í´ë¼ì´ì–¸íŠ¸: ì•± ì‹¤í–‰ ì‹œ, ì„œë²„: ì•± ë¯¸ì‹¤í–‰ ì‚¬ìš©ì ì»¤ë²„.
      </description>

      <business_impact>
        <metric>ë§¤ì¹­ í›„ ëŒ€í™”ìœ¨</metric>
        <metric>ëŒ€í™” í’ˆì§ˆ</metric>
        <metric>ì°¸ì—¬ë„ ì¸¡ì •</metric>
      </business_impact>

      <implementation>
        <file_path>src/jobs/chat-activity.job.ts</file_path>
        <trigger>Cron Job - ë§¤ì¼ ì˜¤ì „ 4ì‹œ</trigger>
        <cron_schedule>0 4 * * *</cron_schedule>

        <code><![CDATA[
import cron from 'node-cron';
import { trackEvent } from '@/libs/mixpanel';
import { ChatRoom } from '@/models/chat-room.model';
import { Message } from '@/models/message.model';

/**
 * ì±„íŒ… í™œì„±ë„ ì¶”ì  Cron Job
 * ë§¤ì¼ ì˜¤ì „ 4ì‹œ ì‹¤í–‰
 */
export function setupChatActivityTracking() {
  cron.schedule('0 4 * * *', async () => {
    console.log('[Cron] Running chat activity tracking...');

    try {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(0, 0, 0, 0);

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // ì–´ì œ ìƒì„±ëœ ì±„íŒ…ë°© ì¡°íšŒ
      const chatRooms = await ChatRoom.findAll({
        where: {
          createdAt: { $gte: yesterday, $lt: today },
        },
      });

      // ê° ì±„íŒ…ë°©ë³„ í™œì„±ë„ ì²´í¬
      for (const room of chatRooms) {
        const { userId1, userId2, matchId } = room;

        // í´ë¼ì´ì–¸íŠ¸ê°€ ì´ë¯¸ trackingí–ˆëŠ”ì§€ í™•ì¸
        const trackedByClient = await isTrackedByClient(room.id);
        if (trackedByClient) {
          continue; // ì¤‘ë³µ ë°©ì§€
        }

        // 24ì‹œê°„ ë‚´ ë©”ì‹œì§€ ì¡°íšŒ
        const messages = await Message.findAll({
          where: {
            chatRoomId: room.id,
            createdAt: { $gte: yesterday, $lt: today },
          },
        });

        const user1Messages = messages.filter((m) => m.senderId === userId1);
        const user2Messages = messages.filter((m) => m.senderId === userId2);

        const isActive = messages.length > 0;
        const isMutual = user1Messages.length > 0 && user2Messages.length > 0;

        let activityStatus: 'inactive' | 'active' | 'mutual' | 'one_sided';
        if (!isActive) {
          activityStatus = 'inactive';
        } else if (isMutual) {
          activityStatus = 'mutual';
        } else {
          activityStatus = 'one_sided';
        }

        const baseData = {
          chat_room_id: room.id,
          match_id: matchId,
          is_active: isActive,
          is_mutual_conversation: isMutual,
          activity_status: activityStatus,
          total_message_count: messages.length,
          tracking_source: 'batch', // í´ë¼ì´ì–¸íŠ¸ì™€ êµ¬ë¶„
        };

        // ğŸ¯ 24ì‹œê°„ í™œì„±ë„ tracking (ì–‘ìª½ ëª¨ë‘)
        trackEvent('Chat_24h_Active', userId1, {
          ...baseData,
          chat_partner_id: userId2,
          my_message_count: user1Messages.length,
          partner_message_count: user2Messages.length,
        });

        trackEvent('Chat_24h_Active', userId2, {
          ...baseData,
          chat_partner_id: userId1,
          my_message_count: user2Messages.length,
          partner_message_count: user1Messages.length,
        });
      }

      console.log(`[Cron] Chat activity tracked for ${chatRooms.length} rooms`);
    } catch (error) {
      console.error('[Cron] Chat activity tracking error:', error);
    }
  });
}

/**
 * í´ë¼ì´ì–¸íŠ¸ê°€ ì´ë¯¸ trackingí–ˆëŠ”ì§€ í™•ì¸
 */
async function isTrackedByClient(chatRoomId: string): Promise<boolean> {
  // APIë¡œ tracking ì—¬ë¶€ í™•ì¸
  const tracked = await ChatActivityTracking.findOne({
    where: { chatRoomId, trackingSource: 'app' },
  });

  return !!tracked;
}
        ]]></code>

        <cron_registration><![CDATA[
// src/index.ts
import { setupChatActivityTracking } from '@/jobs/chat-activity.job';

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);

  // Cron Job ë“±ë¡
  setupChatActivityTracking();
});
        ]]></cron_registration>
      </implementation>

      <note>
        âš ï¸ í´ë¼ì´ì–¸íŠ¸ë„ tracking ì¤‘ (use-auto-track-chat-activity.ts)
        â†’ ì•± ì‹¤í–‰ ì‹œ ì„œë²„ APIë¡œ ë°›ì€ ë°ì´í„° tracking
        â†’ tracking_source: 'app'
        â†’ ì„œë²„ëŠ” ì•± ë¯¸ì‹¤í–‰ ì‚¬ìš©ìë§Œ ë³´ì™„ (tracking_source: 'batch')
      </note>
    </event>

    <!-- 8. Invite_Conversion_Completed -->
    <event id="8">
      <name>Invite_Conversion_Completed</name>
      <category>ì´ˆëŒ€/ì¶”ì²œ</category>
      <priority>ğŸ”´ ìµœìš°ì„ </priority>
      <duplicate_status>âœ… ì¤‘ë³µ ì—†ìŒ (í´ë¼ì´ì–¸íŠ¸ëŠ” íƒ€ì…ë§Œ ì •ì˜)</duplicate_status>

      <description>
        ì´ˆëŒ€ ë§í¬ë¥¼ í†µí•œ íšŒì›ê°€ì… ì™„ë£Œ ì¶”ì .
        íšŒì›ê°€ì… ì™„ë£ŒëŠ” ì„œë²„ì—ì„œ í™•ì •í•˜ë¯€ë¡œ ì„œë²„ì—ì„œ tracking í•„ìˆ˜.
      </description>

      <business_impact>
        <metric>ì´ˆëŒ€ í”„ë¡œê·¸ë¨ ì „í™˜ìœ¨</metric>
        <metric>ë°”ì´ëŸ´ ì„±ì¥ë¥ </metric>
        <metric>ì¶”ì²œì¸ íš¨ê³¼ ì¸¡ì •</metric>
      </business_impact>

      <implementation>
        <file_path>src/controllers/auth.controller.ts</file_path>
        <api_endpoint>POST /api/v1/auth/signup</api_endpoint>
        <trigger>íšŒì›ê°€ì… ì™„ë£Œ ì‹œ (ì´ˆëŒ€ ì½”ë“œ ìˆì„ ë•Œ)</trigger>

        <code><![CDATA[
import { trackEvent } from '@/libs/mixpanel';

/**
 * POST /api/v1/auth/signup
 * íšŒì›ê°€ì… API - ì´ˆëŒ€ ì „í™˜ tracking
 */
export async function signup(req: Request, res: Response) {
  try {
    const { inviteCode, authMethod, deviceType, ...userData } = req.body;

    // 1. ì‚¬ìš©ì ìƒì„±
    const user = await createUser(userData);

    // 2. ê¸°ë³¸ íšŒì›ê°€ì… ì™„ë£Œ tracking
    trackEvent('Signup_done', user.id, {
      signup_method: authMethod,
      profile_completion_rate: calculateCompletionRate(user),
      has_invite_code: !!inviteCode,
    });

    // 3. ì´ˆëŒ€ ì½”ë“œ ì²˜ë¦¬
    if (inviteCode) {
      try {
        // ì´ˆëŒ€ ì½”ë“œ ê²€ì¦
        const invite = await validateInviteCode(inviteCode);

        if (!invite) {
          throw new Error('Invalid invite code');
        }

        // ì´ˆëŒ€ ì½”ë“œ ì‚¬ìš© ê¸°ë¡
        await markInviteCodeUsed(inviteCode, user.id);

        // ğŸ¯ ì´ˆëŒ€ ì „í™˜ ì™„ë£Œ tracking (ì„œë²„ ì „ìš©)
        trackEvent('Invite_Conversion_Completed', user.id, {
          invite_code: inviteCode,
          inviter_id: invite.inviterId,
          invited_user_id: user.id,
          device_type: deviceType || 'unknown',
          signup_method: authMethod,
          tracking_source: 'server',
        });

        // ì¶”ì²œì¸ì—ê²Œ ë¦¬ì›Œë“œ ì§€ê¸‰
        await grantReferralReward(invite.inviterId, user.id);

        // ğŸ¯ ì¶”ì²œ ë¦¬ì›Œë“œ ì§€ê¸‰ tracking
        trackEvent('Referral_Reward_Granted', invite.inviterId, {
          invited_user_id: user.id,
          invite_code: inviteCode,
          reward_type: 'gem',
          reward_amount: 10,
        });

        console.log('[Invite] Conversion completed:', {
          userId: user.id,
          inviteCode,
          inviterId: invite.inviterId,
        });
      } catch (inviteError) {
        // ì´ˆëŒ€ ì½”ë“œ ì˜¤ë¥˜ëŠ” íšŒì›ê°€ì… ìì²´ëŠ” ì§„í–‰
        console.error('[Invite] Code validation failed:', inviteError);
      }
    }

    res.json({
      success: true,
      userId: user.id,
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    });
  }
}
        ]]></code>

        <helper_functions><![CDATA[
/**
 * ì´ˆëŒ€ ì½”ë“œ ê²€ì¦
 */
async function validateInviteCode(code: string): Promise<{ inviterId: string } | null> {
  const invite = await Invite.findOne({
    where: { code, isActive: true },
  });

  return invite ? { inviterId: invite.userId } : null;
}

/**
 * ì´ˆëŒ€ ì½”ë“œ ì‚¬ìš© ê¸°ë¡
 */
async function markInviteCodeUsed(code: string, userId: string): Promise<void> {
  await Invite.update(
    { usedBy: userId, usedAt: new Date() },
    { where: { code } }
  );
}

/**
 * ì¶”ì²œ ë¦¬ì›Œë“œ ì§€ê¸‰
 */
async function grantReferralReward(inviterId: string, invitedUserId: string): Promise<void> {
  await Gem.increment('balance', {
    by: 10,
    where: { userId: inviterId },
  });

  await RewardHistory.create({
    userId: inviterId,
    type: 'referral',
    amount: 10,
    source: invitedUserId,
  });
}
        ]]></helper_functions>
      </implementation>

      <note>
        âš ï¸ Invite_Link_ClickedëŠ” ì„œë²„ì—ì„œ êµ¬í˜„ ì•ˆ í•¨!
        â†’ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì´ë¯¸ tracking ì¤‘ (use-record-invite-click.ts:35)
        â†’ ì„œë²„ëŠ” DB ê¸°ë¡ë§Œ (Mixpanel tracking ì œì™¸)
      </note>
    </event>

  </phase>

  <!-- ========================================
       Phase 2: ë†’ì€ ìš°ì„ ìˆœìœ„ ì´ë²¤íŠ¸ (10ê°œ)
       ======================================== -->

  <phase priority="2" duration="2-3ì£¼">
    <title>Phase 2: ë†’ì€ ìš°ì„ ìˆœìœ„ ì´ë²¤íŠ¸ êµ¬í˜„</title>
    <event_count>9ê°œ</event_count>
    <note>âŒ Referral_Signup_Completed ì œê±° (Invite_Conversionê³¼ ì¤‘ë³µ)</note>

    <!-- ì±„íŒ… ë„ë©”ì¸ (3ê°œ) -->
    <domain name="ì±„íŒ…">
      <event id="8">
        <name>First_Message_Received</name>
        <implementation>
          <file_path>WebSocket ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬</file_path>
          <trigger>ìƒëŒ€ë°© ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ</trigger>
          <code><![CDATA[
// Socket.io ì˜ˆì‹œ
io.on('connection', (socket) => {
  socket.on('message:sent', async (data) => {
    await saveMessage(data);
    socket.to(data.chatRoomId).emit('message:received', data);

    // ğŸ¯ ì²« ë©”ì‹œì§€ ìˆ˜ì‹  tracking
    const isFirst = await checkIsFirstMessage(data.recipientId);
    if (isFirst) {
      trackEvent('First_Message_Received', data.recipientId, {
        sender_id: data.senderId,
        chat_room_id: data.chatRoomId,
        tracking_source: 'server_websocket',
      });
    }
  });
});
          ]]></code>
        </implementation>
      </event>

      <event id="9">
        <name>Chat_Response</name>
        <implementation>
          <file_path>WebSocket ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬</file_path>
          <trigger>ìƒëŒ€ë°© ì‘ë‹µ ì‹œ</trigger>
          <note>First_Message_Receivedì™€ ìœ ì‚¬í•œ êµ¬ì¡°</note>
        </implementation>
      </event>

      <event id="10">
        <name>Match_Conversation_Rate</name>
        <implementation>
          <file_path>src/jobs/conversation-rate.job.ts</file_path>
          <trigger>Cron Job - ë§¤ì¼ ì˜¤ì „ 5ì‹œ</trigger>
          <cron_schedule>0 5 * * *</cron_schedule>
          <note>ë§¤ì¹­ í›„ 24ì‹œê°„ ë‚´ ëŒ€í™” ì—¬ë¶€ ì§‘ê³„</note>
        </implementation>
      </event>
    </domain>

    <!-- íšŒì›ê°€ì…/ì¸ì¦ ë„ë©”ì¸ (4ê°œ) -->
    <domain name="íšŒì›ê°€ì…/ì¸ì¦">
      <event id="11">
        <name>Signup_done</name>
        <implementation>
          <file_path>src/controllers/auth.controller.ts</file_path>
          <api_endpoint>POST /api/v1/auth/signup</api_endpoint>
          <code><![CDATA[
export async function signup(req, res) {
  const user = await createUser(req.body);

  // ğŸ¯ íšŒì›ê°€ì… ì™„ë£Œ tracking
  trackEvent('Signup_done', user.id, {
    signup_method: req.body.authMethod,
    profile_completion_rate: calculateCompletionRate(user),
    has_invite_code: !!req.body.inviteCode,
  });

  res.json({ success: true, userId: user.id });
}
          ]]></code>
        </implementation>
      </event>

      <event id="12">
        <name>University_Verification_Started</name>
        <implementation>
          <api_endpoint>POST /api/v1/verification/start</api_endpoint>
        </implementation>
      </event>

      <event id="13">
        <name>University_Verification_Completed</name>
        <implementation>
          <api_endpoint>POST /api/v1/verification/complete</api_endpoint>
        </implementation>
      </event>

      <event id="14">
        <name>Account_Reactivated</name>
        <implementation>
          <api_endpoint>POST /api/v1/account/reactivate</api_endpoint>
        </implementation>
      </event>
    </domain>

    <!-- ì¶”ì²œ ë„ë©”ì¸ (1ê°œ) -->
    <domain name="ì¶”ì²œ">
      <note>
        âŒ Referral_Signup_Completed ì œê±°ë¨
        â†’ Invite_Conversion_Completedì™€ ì¤‘ë³µ (ë™ì¼í•œ ì˜ë¯¸)
        â†’ Phase 1ì˜ Invite_Conversion_Completed ì‚¬ìš©
      </note>

      <event id="15">
        <name>Referral_Reward_Granted</name>
        <implementation>
          <api_endpoint>POST /api/v1/rewards/referral</api_endpoint>
          <code><![CDATA[
// ë¦¬ì›Œë“œ ì§€ê¸‰ ì‹œ
await grantReferralReward(referrerId, invitedUserId);

// ğŸ¯ ë¦¬ì›Œë“œ ì§€ê¸‰ tracking
trackEvent('Referral_Reward_Granted', referrerId, {
  invited_user_id: invitedUserId,
  reward_type: 'gem',
  reward_amount: 10,
});
          ]]></code>
        </implementation>
      </event>
    </domain>

    <!-- ë§¤ì¹­ ì¶”ê°€ (1ê°œ) -->
    <domain name="ë§¤ì¹­">
      <event id="17">
        <name>Match_Request_Sent</name>
        <implementation>
          <api_endpoint>POST /api/v1/matching/request</api_endpoint>
        </implementation>
      </event>
    </domain>

  </phase>

  <!-- ========================================
       Phase 3: ì¤‘ê°„ ìš°ì„ ìˆœìœ„ ì´ë²¤íŠ¸ (9ê°œ)
       ======================================== -->

  <phase priority="3" duration="1ê°œì›”">
    <title>Phase 3: ì¤‘ê°„ ìš°ì„ ìˆœìœ„ ì´ë²¤íŠ¸ êµ¬í˜„</title>
    <event_count>9ê°œ</event_count>

    <domain name="ê²°ì œ/ìˆ˜ìµ">
      <event_list>
        <event>Rematch_Purchased</event>
        <event>Subscription_Started</event>
        <event>Subscription_Cancelled</event>
        <event>Revenue_Per_User</event>
      </event_list>
      <note>Phase 1 ì™„ë£Œ í›„ ì§„í–‰</note>
    </domain>

    <domain name="ì»¤ë®¤ë‹ˆí‹°">
      <event_list>
        <event>Community_Daily_Active_Users</event>
        <event>Community_Feed_Viewed</event>
        <event>Community_Post_Reported</event>
        <event>Community_Post_Deleted</event>
      </event_list>
    </domain>

    <domain name="ê¸°íƒ€">
      <event_list>
        <event>User_Metrics_Updated</event>
      </event_list>
    </domain>
  </phase>

  <!-- ========================================
       êµ¬í˜„ ê°€ì´ë“œ
       ======================================== -->

  <implementation_guide>
    <best_practices>
      <practice id="1">
        <title>ì—ëŸ¬ ì²˜ë¦¬</title>
        <description>Mixpanel tracking ì‹¤íŒ¨í•´ë„ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ê³„ì† ì§„í–‰</description>
        <code><![CDATA[
try {
  trackEvent('Event_Name', userId, properties);
} catch (error) {
  console.error('[Mixpanel] Tracking error:', error);
  // ì—ëŸ¬ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
}
        ]]></code>
      </practice>

      <practice id="2">
        <title>ê°œì¸ì •ë³´ ë³´í˜¸</title>
        <description>IP ì£¼ì†Œ ë¬´ì‹œ, ë¯¼ê° ì •ë³´ ì œì™¸</description>
        <code><![CDATA[
// IP ì£¼ì†Œ ë¬´ì‹œ
mixpanel.people.set(userId, {
  name: user.name,
  $ip: '0', // ì„œë²„ IP ì‚¬ìš© ì•ˆ í•¨
});

// ë¯¼ê° ì •ë³´ ì œì™¸
trackEvent('Payment_Completed', userId, {
  total_amount: 9900,
  // âŒ ì¹´ë“œ ë²ˆí˜¸, CVV ì ˆëŒ€ ì „ì†¡ ì•ˆ í•¨
});
        ]]></code>
      </practice>

      <practice id="3">
        <title>ë¹„ë™ê¸° ì²˜ë¦¬ (Serverless)</title>
        <description>AWS Lambda ë“±ì—ì„œëŠ” callback ì‚¬ìš© í•„ìˆ˜</description>
        <code><![CDATA[
export const trackEventAsync = async (
  eventName: string,
  distinctId: string,
  properties: Record<string, any> = {}
): Promise<void> => {
  return new Promise((resolve, reject) => {
    mixpanel.track(
      eventName,
      { distinct_id: distinctId, ...properties },
      (error) => {
        if (error) reject(error);
        else resolve();
      }
    );
  });
};
        ]]></code>
      </practice>

      <practice id="4">
        <title>ì¤‘ë³µ ë°©ì§€</title>
        <description>tracking_source í•„ë“œë¡œ ì¶œì²˜ êµ¬ë¶„</description>
        <code><![CDATA[
// ì„œë²„ tracking
trackEvent('Like_Received', userId, {
  tracking_source: 'server_realtime', // ì„œë²„ ì‹¤ì‹œê°„
});

// ë°°ì¹˜ ì‘ì—…
trackEvent('Day_1_Retention', userId, {
  tracking_source: 'batch', // Cron Job
});

// Webhook
trackEvent('Subscription_Renewed', userId, {
  tracking_source: 'webhook', // PGì‚¬ ì½œë°±
});
        ]]></code>
      </practice>
    </best_practices>

    <testing>
      <test_step number="1">
        <title>ë¡œì»¬ í…ŒìŠ¤íŠ¸</title>
        <command><![CDATA[
# í™˜ê²½ë³€ìˆ˜ í™•ì¸
echo $MIXPANEL_PROJECT_TOKEN

# ì„œë²„ ì‹¤í–‰
npm run dev

# API í…ŒìŠ¤íŠ¸
curl -X POST http://localhost:3000/api/v1/payment/verify \
  -H "Content-Type: application/json" \
  -d '{"userId": "test-123", "transactionId": "txn-123", "amount": 9900}'
        ]]></command>
      </test_step>

      <test_step number="2">
        <title>Mixpanel Live View í™•ì¸</title>
        <steps>
          <step>Mixpanel ë¡œê·¸ì¸: https://mixpanel.com</step>
          <step>Live View ì ‘ì†</step>
          <step>ì´ë²¤íŠ¸ í•„í„°: "Payment_Completed"</step>
          <step>ì†ì„± í™•ì¸: verified_at_server = true</step>
        </steps>
      </test_step>

      <test_step number="3">
        <title>ë””ë²„ê·¸ ë¡œê·¸ í™•ì¸</title>
        <expected_output><![CDATA[
[Mixpanel] Sending track request for event "Payment_Completed"
[Mixpanel] Event data: {
  distinct_id: 'test-user-123',
  transaction_id: 'txn_test_123',
  total_amount: 9900,
  verified_at_server: true
}
[Mixpanel] Request successful
        ]]></expected_output>
      </test_step>
    </testing>

    <deployment>
      <checklist>
        <item status="required">í™˜ê²½ë³€ìˆ˜ ì„¤ì • (.env)</item>
        <item status="required">Mixpanel SDK ì„¤ì¹˜</item>
        <item status="required">src/libs/mixpanel.ts ìƒì„±</item>
        <item status="required">Phase 1 ì´ë²¤íŠ¸ 7ê°œ êµ¬í˜„</item>
        <item status="required">Cron Job ë“±ë¡ (src/index.ts)</item>
        <item status="optional">Slack ì•Œë¦¼ ì„¤ì •</item>
        <item status="required">í…ŒìŠ¤íŠ¸ í™˜ê²½ ê²€ì¦</item>
        <item status="required">Mixpanel Live View í™•ì¸</item>
      </checklist>
    </deployment>
  </implementation_guide>

  <!-- ========================================
       ì „ì²´ ì´ë²¤íŠ¸ ëª©ë¡ (ì°¸ê³ ìš©)
       ======================================== -->

  <all_server_events>
    <summary>
      <total>27ê°œ</total>
      <phase_1>8ê°œ (ìµœìš°ì„ ) - Invite_Conversion ì¶”ê°€</phase_1>
      <phase_2>9ê°œ (ë†’ì€ ìš°ì„ ìˆœìœ„) - Referral_Signup ì œê±°</phase_2>
      <phase_3>9ê°œ (ì¤‘ê°„ ìš°ì„ ìˆœìœ„)</phase_3>
      <note>âŒ Invite_Link_Clicked ì œì™¸ (í´ë¼ì´ì–¸íŠ¸ ì¤‘ë³µ)</note>
    </summary>

    <phase_1_events>
      <event>Payment_Completed</event>
      <event>Subscription_Renewed</event>
      <event>Like_Received</event>
      <event>Like_Match_Created</event>
      <event>Matching_Success</event>
      <event>Day_1/3/7/30_Retention</event>
      <event>Chat_24h_Active</event>
      <event>Invite_Conversion_Completed</event> <!-- â­ ì¶”ê°€ -->
    </phase_1_events>

    <phase_2_events>
      <event>First_Message_Received</event>
      <event>Chat_Response</event>
      <event>Match_Conversation_Rate</event>
      <event>Signup_done</event>
      <event>University_Verification_Started</event>
      <event>University_Verification_Completed</event>
      <event>Account_Reactivated</event>
      <!-- âŒ Referral_Signup_Completed ì œê±° (Invite_Conversionê³¼ ì¤‘ë³µ) -->
      <event>Referral_Reward_Granted</event>
      <event>Match_Request_Sent</event>
    </phase_2_events>

    <phase_3_events>
      <event>Rematch_Purchased</event>
      <event>Subscription_Started</event>
      <event>Subscription_Cancelled</event>
      <event>Revenue_Per_User</event>
      <event>Community_Daily_Active_Users</event>
      <event>Community_Feed_Viewed</event>
      <event>Community_Post_Reported</event>
      <event>Community_Post_Deleted</event>
      <event>User_Metrics_Updated</event>
    </phase_3_events>
  </all_server_events>

  <!-- ========================================
       ì°¸ê³  ìë£Œ
       ======================================== -->

  <references>
    <document>
      <title>ì„œë²„ ì „ìš© ì´ë²¤íŠ¸ ìµœì¢… ëª©ë¡</title>
      <path>docs/SERVER-ONLY-EVENTS-FINAL.md</path>
      <description>26ê°œ ì„œë²„ ì´ë²¤íŠ¸ ìƒì„¸ ì„¤ëª… ë° ìš°ì„ ìˆœìœ„</description>
    </document>

    <document>
      <title>ë°±ì—”ë“œ í†µí•© ê°€ì´ë“œ</title>
      <path>docs/backend-mixpanel-integration-guide.md</path>
      <description>ì „ì²´ êµ¬í˜„ ê°€ì´ë“œ, ì½”ë“œ ì˜ˆì‹œ, ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤</description>
    </document>

    <document>
      <title>ì „ì²´ ì´ë²¤íŠ¸ ëª©ë¡</title>
      <path>docs/mixpanel-events-full-list.md</path>
      <description>í´ë¼ì´ì–¸íŠ¸ 153ê°œ + ì„œë²„ 33ê°œ = 186ê°œ ì „ì²´ ëª©ë¡</description>
    </document>

    <document>
      <title>ì¤‘ë³µ í•´ê²° ê°€ì´ë“œ</title>
      <path>docs/mixpanel-duplicate-resolution.md</path>
      <description>í´ë¼ì´ì–¸íŠ¸/ì„œë²„ ì¤‘ë³µ ì œê±° ì™„ë£Œ ë³´ê³ ì„œ</description>
    </document>

    <document>
      <title>ìµœì¢… ìš”ì•½</title>
      <path>docs/MIXPANEL-FINAL-SUMMARY.md</path>
      <description>ì „ì²´ êµ¬í˜„ í˜„í™© ë° ìµœì¢… ìš”ì•½</description>
    </document>

    <external_docs>
      <doc>
        <title>Mixpanel Node.js SDK</title>
        <url>https://developer.mixpanel.com/docs/nodejs</url>
      </doc>
      <doc>
        <title>Mixpanel API Reference</title>
        <url>https://mixpanel.github.io/mixpanel-node/</url>
      </doc>
    </external_docs>
  </references>

  <!-- ========================================
       íƒ€ì„ë¼ì¸ ë° ë§ˆì¼ìŠ¤í†¤
       ======================================== -->

  <timeline>
    <week number="1">
      <title>SDK ì„¤ì • ë° API Tracking (5ê°œ)</title>
      <tasks>
        <task>Mixpanel SDK ì´ˆê¸°í™”</task>
        <task>Payment_Completed êµ¬í˜„</task>
        <task>Like_Received, Like_Match_Created, Matching_Success êµ¬í˜„</task>
        <task>Invite_Conversion_Completed êµ¬í˜„</task>
        <task>ë¡œì»¬ í…ŒìŠ¤íŠ¸ ë° ê²€ì¦</task>
      </tasks>
      <deliverables>
        <deliverable>src/libs/mixpanel.ts</deliverable>
        <deliverable>src/controllers/payment.controller.ts (ìˆ˜ì •)</deliverable>
        <deliverable>src/controllers/like.controller.ts (ìˆ˜ì •)</deliverable>
        <deliverable>src/controllers/auth.controller.ts (ìˆ˜ì •)</deliverable>
      </deliverables>
    </week>

    <week number="2">
      <title>Webhook & Cron Jobs (3ê°œ)</title>
      <tasks>
        <task>Subscription_Renewed Webhook êµ¬í˜„</task>
        <task>Retention Tracking Cron Job êµ¬í˜„</task>
        <task>Chat Activity Cron Job êµ¬í˜„ (ì„ íƒ)</task>
        <task>Cron Job ë“±ë¡ ë° í…ŒìŠ¤íŠ¸</task>
      </tasks>
      <deliverables>
        <deliverable>src/webhooks/subscription.webhook.ts</deliverable>
        <deliverable>src/jobs/retention.job.ts</deliverable>
        <deliverable>src/jobs/chat-activity.job.ts</deliverable>
        <deliverable>src/index.ts (Cron ë“±ë¡)</deliverable>
      </deliverables>
    </week>

    <week number="3-4">
      <title>Phase 2 êµ¬í˜„ (10ê°œ)</title>
      <tasks>
        <task>WebSocket ì´ë²¤íŠ¸ (ì±„íŒ… 3ê°œ)</task>
        <task>íšŒì›ê°€ì…/ì¸ì¦ API (4ê°œ)</task>
        <task>ì¶”ì²œ ë¦¬ì›Œë“œ (2ê°œ)</task>
        <task>ë§¤ì¹­ ìš”ì²­ (1ê°œ)</task>
      </tasks>
    </week>

    <milestone name="Phase 1 ì™„ë£Œ">
      <criteria>7ê°œ ì´ë²¤íŠ¸ Mixpanel Live View í™•ì¸</criteria>
      <expected_date>2ì£¼ í›„</expected_date>
    </milestone>
  </timeline>

  <!-- ========================================
       ì„±ê³µ ì§€í‘œ
       ======================================== -->

  <success_metrics>
    <metric>
      <name>êµ¬í˜„ ì™„ë£Œìœ¨</name>
      <target>Phase 1: 7ê°œ / 7ê°œ (100%)</target>
    </metric>

    <metric>
      <name>Mixpanel ì´ë²¤íŠ¸ ë°œì†¡</name>
      <target>ì¼ì¼ 3,000~5,000ê°œ (ì„œë²„ ì¶”ê°€ë¶„)</target>
    </metric>

    <metric>
      <name>ì—ëŸ¬ìœ¨</name>
      <target>&lt; 0.1% (tracking ì‹¤íŒ¨ìœ¨)</target>
    </metric>

    <metric>
      <name>ì¤‘ë³µ ì´ë²¤íŠ¸</name>
      <target>0ê°œ (tracking_source êµ¬ë¶„)</target>
    </metric>
  </success_metrics>

  <!-- ========================================
       FAQ
       ======================================== -->

  <faq>
    <question id="1">
      <q>í´ë¼ì´ì–¸íŠ¸ì™€ ì¤‘ë³µë˜ëŠ” ì´ë²¤íŠ¸ê°€ ìˆë‚˜ìš”?</q>
      <a>
        âœ… ì—†ìŠµë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ì—ì„œ Payment_Completed, Matching_Success ì œê±° ì™„ë£Œ.
        Like_Received, Chat_24h_ActiveëŠ” tracking_sourceë¡œ êµ¬ë¶„í•˜ì—¬ ë³‘í–‰ ê°€ëŠ¥.
      </a>
    </question>

    <question id="2">
      <q>Mixpanel SDKëŠ” ì–´ë–»ê²Œ ì„¤ì¹˜í•˜ë‚˜ìš”?</q>
      <a>
        npm install mixpanel
        â†’ src/libs/mixpanel.ts ìƒì„±
        â†’ í™˜ê²½ë³€ìˆ˜ ì„¤ì • (.env)
      </a>
    </question>

    <question id="3">
      <q>Cron Jobì€ ì–´ë–»ê²Œ ë“±ë¡í•˜ë‚˜ìš”?</q>
      <a>
        node-cron íŒ¨í‚¤ì§€ ì‚¬ìš©.
        src/index.tsì—ì„œ setupRetentionTracking() í˜¸ì¶œ.
        ë§¤ì¼ ì˜¤ì „ 3ì‹œ ìë™ ì‹¤í–‰.
      </a>
    </question>

    <question id="4">
      <q>í…ŒìŠ¤íŠ¸ëŠ” ì–´ë–»ê²Œ í•˜ë‚˜ìš”?</q>
      <a>
        1. ë¡œì»¬ í™˜ê²½ì—ì„œ API í˜¸ì¶œ
        2. Mixpanel Live Viewì—ì„œ ì‹¤ì‹œê°„ í™•ì¸
        3. ì†ì„± ê°’ ê²€ì¦ (verified_at_server ë“±)
      </a>
    </question>

    <question id="5">
      <q>í”„ë¡œë•ì…˜ ë°°í¬ ì‹œ ì£¼ì˜ì‚¬í•­ì€?</q>
      <a>
        1. MIXPANEL_DEBUG=false ì„¤ì •
        2. í™˜ê²½ë³€ìˆ˜ ë³´ì•ˆ í™•ì¸
        3. ì—ëŸ¬ ì²˜ë¦¬ ì ìš©
        4. ê°œì¸ì •ë³´ ì œì™¸ í™•ì¸
      </a>
    </question>
  </faq>

  <!-- ========================================
       ì—°ë½ì²˜ ë° ì§€ì›
       ======================================== -->

  <support>
    <frontend_team>
      <status>âœ… í´ë¼ì´ì–¸íŠ¸ 153ê°œ ì´ë²¤íŠ¸ êµ¬í˜„ ì™„ë£Œ</status>
      <status>âœ… ì¤‘ë³µ ì œê±° ì™„ë£Œ (5ê³³)</status>
      <contact>í”„ë¡ íŠ¸ì—”ë“œ íŒ€ ë¦¬ë“œ</contact>
    </frontend_team>

    <backend_nestjs>
      <status>âœ… ë§¤ì¹­ íŒŒì´í”„ë¼ì¸ 7ê°œ ì´ë²¤íŠ¸ êµ¬í˜„ ì™„ë£Œ</status>
      <contact>ë°±ì—”ë“œ NestJS íŒ€</contact>
    </backend_nestjs>

    <backend_nodejs>
      <status>ğŸ”„ ì¶”ê°€ 26ê°œ ì´ë²¤íŠ¸ êµ¬í˜„ ì˜ˆì •</status>
      <contact>ë°±ì—”ë“œ Node.js íŒ€</contact>
    </backend_nodejs>

    <documentation>
      <location>docs/ ë””ë ‰í„°ë¦¬</location>
      <key_files>
        <file>SERVER-ONLY-EVENTS-FINAL.md</file>
        <file>backend-mixpanel-integration-guide.md</file>
        <file>MIXPANEL-FINAL-SUMMARY.md</file>
      </key_files>
    </documentation>
  </support>

  <!-- ========================================
       ì˜ˆìƒ ê²°ê³¼
       ======================================== -->

  <expected_outcomes>
    <outcome>
      <title>ë°ì´í„° ê¸°ë°˜ ì˜ì‚¬ê²°ì •</title>
      <description>
        ê²°ì œ ì „í™˜ìœ¨, ë¦¬í…ì…˜ ê³¡ì„ , ë§¤ì¹­ ì„±ê³µë¥  ë“± í•µì‹¬ ì§€í‘œ ì¸¡ì • ê°€ëŠ¥
      </description>
    </outcome>

    <outcome>
      <title>ìˆ˜ìµ ìµœì í™”</title>
      <description>
        ì²« êµ¬ë§¤ê¹Œì§€ ì‹œê°„, êµ¬ë… ê°±ì‹ ìœ¨ ë¶„ì„ â†’ LTV ì¦ê°€
      </description>
    </outcome>

    <outcome>
      <title>ì‚¬ìš©ì ê²½í—˜ ê°œì„ </title>
      <description>
        ì¢‹ì•„ìš” ì „í™˜ìœ¨, ëŒ€í™” í™œì„±ë„ ì¸¡ì • â†’ ë§¤ì¹­ í’ˆì§ˆ ê°œì„ 
      </description>
    </outcome>

    <outcome>
      <title>ì½”í˜¸íŠ¸ ë¶„ì„</title>
      <description>
        Day 1/7/30 ë¦¬í…ì…˜ìœ¼ë¡œ Aha Moment íŒŒì•… â†’ ì˜¨ë³´ë”© ìµœì í™”
      </description>
    </outcome>
  </expected_outcomes>

  <!-- ========================================
       ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸
       ======================================== -->

  <final_checklist>
    <setup_phase>
      <item priority="high">âœ… Mixpanel SDK ì„¤ì¹˜ ì™„ë£Œ</item>
      <item priority="high">âœ… Mixpanel í”„ë¡œì íŠ¸ ìƒì„± ì™„ë£Œ</item>
      <item priority="high">[ ] í™˜ê²½ë³€ìˆ˜ ì„¤ì • (.env)</item>
      <item priority="high">[ ] src/libs/mixpanel.ts ìƒì„±</item>
    </setup_phase>

    <week_1_implementation>
      <item priority="high">[ ] Payment_Completed êµ¬í˜„</item>
      <item priority="high">[ ] Like_Received êµ¬í˜„</item>
      <item priority="high">[ ] Like_Match_Created êµ¬í˜„</item>
      <item priority="high">[ ] Matching_Success êµ¬í˜„</item>
      <item priority="medium">[ ] ë¡œì»¬ í…ŒìŠ¤íŠ¸</item>
      <item priority="medium">[ ] Mixpanel Live View í™•ì¸</item>
    </week_1_implementation>

    <week_2_implementation>
      <item priority="high">[ ] Subscription_Renewed Webhook êµ¬í˜„</item>
      <item priority="high">[ ] Retention Cron Job êµ¬í˜„</item>
      <item priority="medium">[ ] Chat Activity Cron Job êµ¬í˜„</item>
      <item priority="medium">[ ] Cron Job ë“±ë¡ (src/index.ts)</item>
      <item priority="low">[ ] Slack ì•Œë¦¼ ì„¤ì •</item>
    </week_2_implementation>

    <verification>
      <item>[ ] ì¤‘ë³µ ì´ë²¤íŠ¸ 0ê°œ í™•ì¸</item>
      <item>[ ] tracking_source í•„ë“œ í™•ì¸</item>
      <item>[ ] ê°œì¸ì •ë³´ ë³´í˜¸ í™•ì¸</item>
      <item>[ ] ì—ëŸ¬ ì²˜ë¦¬ í™•ì¸</item>
    </verification>
  </final_checklist>

  <!-- ========================================
       ë¶€ë¡: ë¹ ë¥¸ ì°¸ì¡°
       ======================================== -->

  <quick_reference>
    <common_patterns>
      <pattern name="API í•¸ë“¤ëŸ¬">
        <code><![CDATA[
export async function yourApi(req, res) {
  // 1. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  const result = await yourLogic(req.body);

  // 2. DB ì—…ë°ì´íŠ¸
  await updateDatabase(result);

  // 3. ğŸ¯ Mixpanel Tracking
  trackEvent('Event_Name', userId, {
    property1: value1,
    verified_at_server: true,
  });

  res.json({ success: true });
}
        ]]></code>
      </pattern>

      <pattern name="Cron Job">
        <code><![CDATA[
import cron from 'node-cron';

export function setupYourCron() {
  cron.schedule('0 3 * * *', async () => {
    const items = await getItems();

    for (const item of items) {
      trackEvent('Event_Name', item.userId, {
        tracking_source: 'batch',
        tracked_via_cron: true,
      });
    }
  });
}
        ]]></code>
      </pattern>

      <pattern name="Webhook">
        <code><![CDATA[
export async function handleWebhook(req, res) {
  const isValid = verifySignature(req);
  if (!isValid) return res.status(401).json({ error: 'Invalid' });

  await updateDatabase(req.body);

  trackEvent('Event_Name', userId, {
    tracking_source: 'webhook',
  });

  res.json({ success: true });
}
        ]]></code>
      </pattern>
    </common_patterns>

    <useful_queries>
      <query name="ì¤‘ë³µ í™•ì¸">
        <description>Mixpanelì—ì„œ ì¤‘ë³µ ì´ë²¤íŠ¸ ì°¾ê¸°</description>
        <jql><![CDATA[
SELECT distinct_id, time, tracking_source, COUNT(*) as count
FROM events
WHERE event = 'Payment_Completed'
  AND time > '2025-12-29'
GROUP BY distinct_id, time
HAVING COUNT(*) > 1
        ]]></jql>
      </query>

      <query name="tracking_source ë¶„í¬">
        <description>ì´ë²¤íŠ¸ ì¶œì²˜ ë¶„í¬ í™•ì¸</description>
        <jql><![CDATA[
SELECT tracking_source, COUNT(*) as count
FROM events
WHERE event = 'Like_Received'
  AND time > '2025-12-29'
GROUP BY tracking_source
        ]]></jql>
      </query>
    </useful_queries>
  </quick_reference>

  <summary>
    <key_points>
      <point>âœ… í´ë¼ì´ì–¸íŠ¸ ì¤‘ë³µ ì™„ì „ ì œê±° ì™„ë£Œ</point>
      <point>âœ… íƒ€ì… ì•ˆì „ì„± í™•ë³´ (TypeScript ì¸í„°í˜ì´ìŠ¤)</point>
      <point>âœ… 26ê°œ ì„œë²„ ì „ìš© ì´ë²¤íŠ¸ ëª…í™•íˆ ë¶„ë¥˜</point>
      <point>âœ… ì‹¤ì œ êµ¬í˜„ ì½”ë“œ ì œê³µ (ë³µì‚¬-ë¶™ì—¬ë„£ê¸° ê°€ëŠ¥)</point>
      <point>âœ… Phaseë³„ ìš°ì„ ìˆœìœ„ ë° íƒ€ì„ë¼ì¸ ì œì‹œ</point>
    </key_points>

    <next_steps>
      <step>Week 1: SDK ì„¤ì • ë° API Tracking 4ê°œ êµ¬í˜„</step>
      <step>Week 2: Webhook & Cron Jobs 3ê°œ êµ¬í˜„</step>
      <step>Mixpanel Live Viewì—ì„œ ì´ë²¤íŠ¸ í™•ì¸</step>
      <step>Phase 1 ì™„ë£Œ í›„ Phase 2 ì§„í–‰</step>
    </next_steps>

    <contact_info>
      <for_questions>í”„ë¡ íŠ¸ì—”ë“œ íŒ€ ë¦¬ë“œ ë˜ëŠ” docs/ ë””ë ‰í„°ë¦¬ ì°¸ê³ </for_questions>
      <slack_channel>#mixpanel-implementation</slack_channel>
    </contact_info>
  </summary>
</mixpanel_backend_implementation>
