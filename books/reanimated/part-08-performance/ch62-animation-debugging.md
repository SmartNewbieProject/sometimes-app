# Chapter 62: ì• ë‹ˆë©”ì´ì…˜ ë””ë²„ê¹…

Reanimated ì• ë‹ˆë©”ì´ì…˜ì˜ ë¬¸ì œë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ì°¾ê³  í•´ê²°í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- Reanimated ë””ë²„ê¹… ë„êµ¬ì™€ ê¸°ë²• ì´í•´
- íš¨ê³¼ì ì¸ ë¡œê¹… ì „ëµ ìˆ˜ë¦½
- í”í•œ ë²„ê·¸ íŒ¨í„´ ì¸ì‹ ë° í•´ê²°
- ì„±ëŠ¥ ë¬¸ì œ ì§„ë‹¨ ë° ìˆ˜ì •

## ğŸ“– ê°œë… ì´í•´

### ì• ë‹ˆë©”ì´ì…˜ ë²„ê·¸ ìœ í˜•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Bug Categories                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. ì‹œê°ì  ë²„ê·¸ (Visual Bugs)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ â€¢ ì• ë‹ˆë©”ì´ì…˜ì´ ì‹œì‘ë˜ì§€ ì•ŠìŒ                          â”‚    â”‚
â”‚  â”‚ â€¢ ì˜ëª»ëœ ì‹œì‘/ì¢…ë£Œ ê°’                                 â”‚    â”‚
â”‚  â”‚ â€¢ ëŠê¹€/ë–¨ë¦¼ (Jitter, Jank)                           â”‚    â”‚
â”‚  â”‚ â€¢ ì˜ˆìƒê³¼ ë‹¤ë¥¸ ì›€ì§ì„                                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                              â”‚
â”‚  2. ì„±ëŠ¥ ë²„ê·¸ (Performance Bugs)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ â€¢ í”„ë ˆì„ ë“œë¡­                                         â”‚    â”‚
â”‚  â”‚ â€¢ ë†’ì€ CPU/GPU ì‚¬ìš©ëŸ‰                                â”‚    â”‚
â”‚  â”‚ â€¢ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜                                         â”‚    â”‚
â”‚  â”‚ â€¢ ë°°í„°ë¦¬ ê³¼ì†Œëª¨                                       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                              â”‚
â”‚  3. ë¡œì§ ë²„ê·¸ (Logic Bugs)                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ â€¢ ì œìŠ¤ì²˜ ì¸ì‹ ì˜¤ë¥˜                                    â”‚    â”‚
â”‚  â”‚ â€¢ ìƒíƒœ ë™ê¸°í™” ë¬¸ì œ                                    â”‚    â”‚
â”‚  â”‚ â€¢ ì½œë°± ë¯¸í˜¸ì¶œ                                         â”‚    â”‚
â”‚  â”‚ â€¢ ë¬´í•œ ë£¨í”„                                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                              â”‚
â”‚  4. ìŠ¤ë ˆë“œ ë²„ê·¸ (Thread Bugs)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ â€¢ Worklet ì™¸ë¶€ì—ì„œ SharedValue ì ‘ê·¼                  â”‚    â”‚
â”‚  â”‚ â€¢ runOnJS ëˆ„ë½                                        â”‚    â”‚
â”‚  â”‚ â€¢ í¬ë¡œìŠ¤ ìŠ¤ë ˆë“œ ë°ì´í„° ì˜¤ì—¼                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ë””ë²„ê¹… ë„êµ¬

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Debugging Tools                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Built-in                                                    â”‚
â”‚  â”œâ”€â”€ console.log (runOnJS í†µí•´)                              â”‚
â”‚  â”œâ”€â”€ React DevTools                                          â”‚
â”‚  â”œâ”€â”€ Performance Monitor                                     â”‚
â”‚  â””â”€â”€ Chrome DevTools (Web)                                   â”‚
â”‚                                                              â”‚
â”‚  Reanimated Specific                                         â”‚
â”‚  â”œâ”€â”€ useAnimatedReaction (ê°’ ë³€í™” ì¶”ì )                      â”‚
â”‚  â”œâ”€â”€ useFrameCallback (í”„ë ˆì„ ë¶„ì„)                          â”‚
â”‚  â””â”€â”€ makeMutable (ë””ë²„ê·¸ìš© ê°’ ì¶”ì )                          â”‚
â”‚                                                              â”‚
â”‚  External                                                    â”‚
â”‚  â”œâ”€â”€ Flipper                                                 â”‚
â”‚  â”œâ”€â”€ Reactotron                                              â”‚
â”‚  â”œâ”€â”€ Xcode Instruments                                       â”‚
â”‚  â””â”€â”€ Android Studio Profiler                                 â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ

### 1. ë””ë²„ê·¸ ë¡œê±°

```typescript
import { useCallback, useRef } from 'react';
import Animated, {
  useSharedValue,
  useAnimatedReaction,
  runOnJS,
  SharedValue,
} from 'react-native-reanimated';

interface LogEntry {
  timestamp: number;
  type: 'value' | 'event' | 'error' | 'warning';
  name: string;
  value?: any;
  message?: string;
}

// ì• ë‹ˆë©”ì´ì…˜ ë””ë²„ê·¸ ë¡œê±°
class AnimationDebugger {
  private static instance: AnimationDebugger;
  private logs: LogEntry[] = [];
  private maxLogs: number = 500;
  private enabled: boolean = __DEV__;

  static getInstance() {
    if (!this.instance) {
      this.instance = new AnimationDebugger();
    }
    return this.instance;
  }

  log(entry: Omit<LogEntry, 'timestamp'>) {
    if (!this.enabled) return;

    this.logs.push({
      ...entry,
      timestamp: Date.now(),
    });

    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }

    // ì½˜ì†” ì¶œë ¥
    const prefix = `[Animation:${entry.type}]`;
    const message = entry.message || `${entry.name} = ${JSON.stringify(entry.value)}`;

    switch (entry.type) {
      case 'error':
        console.error(prefix, message);
        break;
      case 'warning':
        console.warn(prefix, message);
        break;
      default:
        console.log(prefix, message);
    }
  }

  logValue(name: string, value: any) {
    this.log({ type: 'value', name, value });
  }

  logEvent(name: string, message: string) {
    this.log({ type: 'event', name, message });
  }

  logError(name: string, message: string) {
    this.log({ type: 'error', name, message });
  }

  logWarning(name: string, message: string) {
    this.log({ type: 'warning', name, message });
  }

  getLogs(filter?: LogEntry['type']): LogEntry[] {
    if (filter) {
      return this.logs.filter(log => log.type === filter);
    }
    return [...this.logs];
  }

  clear() {
    this.logs = [];
  }

  enable() {
    this.enabled = true;
  }

  disable() {
    this.enabled = false;
  }
}

// ë””ë²„ê·¸ í›…
function useAnimationDebug<T extends number>(
  value: SharedValue<T>,
  name: string
) {
  const debugger_ = AnimationDebugger.getInstance();
  const previousValue = useRef<T | null>(null);

  const logChange = useCallback((current: T, previous: T | null) => {
    if (__DEV__) {
      debugger_.logValue(name, {
        current,
        previous,
        delta: previous !== null ? current - previous : null,
      });
    }
  }, [name]);

  useAnimatedReaction(
    () => value.value,
    (current, previous) => {
      runOnJS(logChange)(current, previous);
    },
    [logChange]
  );

  return {
    log: (message: string) => debugger_.logEvent(name, message),
    warn: (message: string) => debugger_.logWarning(name, message),
    error: (message: string) => debugger_.logError(name, message),
  };
}

export { AnimationDebugger, useAnimationDebug };
```

### 2. ê°’ ì¶”ì  ì‹œê°í™”

```typescript
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, ScrollView, StyleSheet, Pressable } from 'react-native';
import Animated, {
  SharedValue,
  useAnimatedReaction,
  runOnJS,
} from 'react-native-reanimated';

interface ValueHistory {
  timestamp: number;
  value: number;
}

interface TrackedValue {
  name: string;
  history: ValueHistory[];
  current: number;
}

// ê°’ ì¶”ì  í›…
function useValueTracker(
  value: SharedValue<number>,
  name: string,
  maxHistory: number = 50
) {
  const historyRef = useRef<ValueHistory[]>([]);
  const [current, setCurrent] = useState(value.value);

  useAnimatedReaction(
    () => value.value,
    (val) => {
      runOnJS((v: number) => {
        historyRef.current.push({
          timestamp: Date.now(),
          value: v,
        });

        if (historyRef.current.length > maxHistory) {
          historyRef.current.shift();
        }

        setCurrent(v);
      })(val);
    },
    []
  );

  return {
    name,
    history: historyRef.current,
    current,
  };
}

// ê°’ ì¶”ì  ì‹œê°í™” ì»´í¬ë„ŒíŠ¸
function ValueTrackerOverlay({
  trackedValues,
  visible,
  onClose,
}: {
  trackedValues: TrackedValue[];
  visible: boolean;
  onClose: () => void;
}) {
  if (!visible || !__DEV__) return null;

  return (
    <View style={styles.overlay}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Value Tracker</Text>
        <Pressable onPress={onClose}>
          <Text style={styles.closeButton}>Ã—</Text>
        </Pressable>
      </View>

      <ScrollView style={styles.content}>
        {trackedValues.map((tracked, index) => (
          <View key={index} style={styles.valueCard}>
            <View style={styles.valueHeader}>
              <Text style={styles.valueName}>{tracked.name}</Text>
              <Text style={styles.currentValue}>
                {tracked.current.toFixed(2)}
              </Text>
            </View>

            {/* ë¯¸ë‹ˆ ê·¸ë˜í”„ */}
            <View style={styles.graph}>
              {tracked.history.slice(-20).map((point, i) => {
                const min = Math.min(...tracked.history.map(h => h.value));
                const max = Math.max(...tracked.history.map(h => h.value));
                const range = max - min || 1;
                const height = ((point.value - min) / range) * 30;

                return (
                  <View
                    key={i}
                    style={[
                      styles.graphBar,
                      { height: Math.max(2, height) }
                    ]}
                  />
                );
              })}
            </View>

            <View style={styles.valueStats}>
              <Text style={styles.statText}>
                Min: {Math.min(...tracked.history.map(h => h.value)).toFixed(2)}
              </Text>
              <Text style={styles.statText}>
                Max: {Math.max(...tracked.history.map(h => h.value)).toFixed(2)}
              </Text>
            </View>
          </View>
        ))}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  overlay: {
    position: 'absolute',
    top: 50,
    left: 10,
    right: 10,
    maxHeight: 400,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    borderRadius: 12,
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  headerTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  closeButton: {
    color: '#FFFFFF',
    fontSize: 24,
    fontWeight: 'bold',
  },
  content: {
    padding: 12,
  },
  valueCard: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
  },
  valueHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  valueName: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '600',
  },
  currentValue: {
    color: '#7A4AE2',
    fontSize: 16,
    fontWeight: 'bold',
    fontFamily: 'monospace',
  },
  graph: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    height: 30,
    gap: 2,
  },
  graphBar: {
    flex: 1,
    backgroundColor: '#7A4AE2',
    borderRadius: 2,
  },
  valueStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  statText: {
    color: '#999',
    fontSize: 10,
    fontFamily: 'monospace',
  },
});

export { useValueTracker, ValueTrackerOverlay, TrackedValue };
```

### 3. ì œìŠ¤ì²˜ ë””ë²„ê¹…

```typescript
import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  runOnJS,
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

interface GestureEvent {
  type: 'start' | 'update' | 'end' | 'cancel';
  timestamp: number;
  data: {
    translationX?: number;
    translationY?: number;
    velocityX?: number;
    velocityY?: number;
    scale?: number;
    rotation?: number;
  };
}

// ì œìŠ¤ì²˜ ë””ë²„ê·¸ í›…
function useGestureDebug(name: string) {
  const [events, setEvents] = useState<GestureEvent[]>([]);
  const [isActive, setIsActive] = useState(false);

  const logEvent = useCallback((event: GestureEvent) => {
    if (!__DEV__) return;

    setEvents(prev => {
      const newEvents = [...prev, event];
      // ìµœê·¼ 50ê°œë§Œ ìœ ì§€
      return newEvents.slice(-50);
    });

    console.log(
      `[Gesture:${name}]`,
      event.type,
      JSON.stringify(event.data)
    );
  }, [name]);

  const createGestureHandlers = useCallback(() => ({
    onStart: (data: any) => {
      setIsActive(true);
      logEvent({
        type: 'start',
        timestamp: Date.now(),
        data: {
          translationX: data.translationX,
          translationY: data.translationY,
        },
      });
    },
    onUpdate: (data: any) => {
      logEvent({
        type: 'update',
        timestamp: Date.now(),
        data: {
          translationX: data.translationX,
          translationY: data.translationY,
          velocityX: data.velocityX,
          velocityY: data.velocityY,
        },
      });
    },
    onEnd: (data: any) => {
      setIsActive(false);
      logEvent({
        type: 'end',
        timestamp: Date.now(),
        data: {
          translationX: data.translationX,
          translationY: data.translationY,
          velocityX: data.velocityX,
          velocityY: data.velocityY,
        },
      });
    },
  }), [logEvent]);

  const clear = useCallback(() => {
    setEvents([]);
  }, []);

  return {
    events,
    isActive,
    createGestureHandlers,
    logEvent,
    clear,
  };
}

// ì œìŠ¤ì²˜ ë””ë²„ê·¸ ì˜¤ë²„ë ˆì´
function GestureDebugOverlay({
  events,
  isActive,
}: {
  events: GestureEvent[];
  isActive: boolean;
}) {
  if (!__DEV__) return null;

  const lastEvent = events[events.length - 1];

  return (
    <View style={styles.gestureOverlay}>
      <View style={[
        styles.statusDot,
        { backgroundColor: isActive ? '#4CAF50' : '#999' }
      ]} />

      {lastEvent && (
        <View style={styles.gestureInfo}>
          <Text style={styles.gestureType}>{lastEvent.type}</Text>
          {lastEvent.data.translationX !== undefined && (
            <Text style={styles.gestureValue}>
              X: {lastEvent.data.translationX.toFixed(1)}
            </Text>
          )}
          {lastEvent.data.translationY !== undefined && (
            <Text style={styles.gestureValue}>
              Y: {lastEvent.data.translationY.toFixed(1)}
            </Text>
          )}
          {lastEvent.data.velocityX !== undefined && (
            <Text style={styles.gestureValue}>
              vX: {lastEvent.data.velocityX.toFixed(1)}
            </Text>
          )}
        </View>
      )}

      <Text style={styles.eventCount}>
        Events: {events.length}
      </Text>
    </View>
  );
}

// ì‚¬ìš© ì˜ˆì‹œ: ë””ë²„ê·¸ ê°€ëŠ¥í•œ ë“œë˜ê·¸ ì»´í¬ë„ŒíŠ¸
function DebuggableDraggable() {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const { events, isActive, createGestureHandlers } = useGestureDebug('drag');

  const handlers = createGestureHandlers();

  const panGesture = Gesture.Pan()
    .onStart((event) => {
      runOnJS(handlers.onStart)(event);
    })
    .onUpdate((event) => {
      translateX.value = event.translationX;
      translateY.value = event.translationY;
      runOnJS(handlers.onUpdate)(event);
    })
    .onEnd((event) => {
      runOnJS(handlers.onEnd)(event);
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
    ],
  }));

  return (
    <View style={styles.container}>
      <GestureDebugOverlay events={events} isActive={isActive} />

      <GestureDetector gesture={panGesture}>
        <Animated.View style={[styles.draggable, animatedStyle]}>
          <Text style={styles.draggableText}>Drag Me</Text>
        </Animated.View>
      </GestureDetector>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  gestureOverlay: {
    position: 'absolute',
    top: 50,
    right: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.85)',
    borderRadius: 8,
    padding: 10,
    minWidth: 120,
  },
  statusDot: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  gestureInfo: {
    marginBottom: 8,
  },
  gestureType: {
    color: '#7A4AE2',
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  gestureValue: {
    color: '#FFFFFF',
    fontSize: 11,
    fontFamily: 'monospace',
  },
  eventCount: {
    color: '#666',
    fontSize: 10,
    fontFamily: 'monospace',
  },
  draggable: {
    width: 120,
    height: 120,
    backgroundColor: '#7A4AE2',
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  draggableText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
});

export { useGestureDebug, GestureDebugOverlay };
```

### 4. í”í•œ ë²„ê·¸ íŒ¨í„´ ê°ì§€

```typescript
import { useEffect, useRef, useCallback } from 'react';
import Animated, {
  SharedValue,
  useAnimatedReaction,
  runOnJS,
} from 'react-native-reanimated';

type BugType =
  | 'infinite_loop'
  | 'stale_value'
  | 'rapid_changes'
  | 'nan_value'
  | 'infinity_value';

interface BugReport {
  type: BugType;
  valueName: string;
  message: string;
  timestamp: number;
  context?: any;
}

// ë²„ê·¸ íŒ¨í„´ ê°ì§€ê¸°
function useBugDetector(
  value: SharedValue<number>,
  name: string,
  options?: {
    maxChangesPerSecond?: number;
    checkNaN?: boolean;
    checkInfinity?: boolean;
  }
) {
  const {
    maxChangesPerSecond = 120,
    checkNaN = true,
    checkInfinity = true,
  } = options || {};

  const changesRef = useRef<number[]>([]);
  const lastValueRef = useRef<number | null>(null);
  const bugReportsRef = useRef<BugReport[]>([]);

  const reportBug = useCallback((bug: BugReport) => {
    if (!__DEV__) return;

    bugReportsRef.current.push(bug);
    console.error(`[BugDetector] ${bug.type}: ${bug.message}`, bug.context);
  }, []);

  useAnimatedReaction(
    () => value.value,
    (current, previous) => {
      runOnJS((cur: number, prev: number | null) => {
        const now = Date.now();

        // NaN ì²´í¬
        if (checkNaN && isNaN(cur)) {
          reportBug({
            type: 'nan_value',
            valueName: name,
            message: `Value became NaN`,
            timestamp: now,
            context: { previous: prev },
          });
        }

        // Infinity ì²´í¬
        if (checkInfinity && !isFinite(cur)) {
          reportBug({
            type: 'infinity_value',
            valueName: name,
            message: `Value became Infinity`,
            timestamp: now,
            context: { value: cur, previous: prev },
          });
        }

        // ê¸‰ê²©í•œ ë³€í™” ì²´í¬ (ë¬´í•œ ë£¨í”„ ê°ì§€)
        changesRef.current.push(now);
        changesRef.current = changesRef.current.filter(
          t => now - t < 1000
        );

        if (changesRef.current.length > maxChangesPerSecond) {
          reportBug({
            type: 'rapid_changes',
            valueName: name,
            message: `Too many changes: ${changesRef.current.length}/sec`,
            timestamp: now,
            context: { changesPerSecond: changesRef.current.length },
          });
        }

        // Stale value ì²´í¬ (ê°™ì€ ê°’ì´ ê³„ì† ì„¤ì •ë¨)
        if (prev !== null && cur === prev && cur === lastValueRef.current) {
          // ì„¸ ë²ˆ ì—°ì† ê°™ì€ ê°’ì´ë©´ ê²½ê³ 
          reportBug({
            type: 'stale_value',
            valueName: name,
            message: `Same value set repeatedly: ${cur}`,
            timestamp: now,
          });
        }

        lastValueRef.current = cur;
      })(current, previous);
    },
    []
  );

  return {
    getBugReports: () => bugReportsRef.current,
    clearReports: () => { bugReportsRef.current = []; },
  };
}

// ì „ì—­ ë²„ê·¸ ë¦¬í¬í„°
class AnimationBugReporter {
  private static reports: BugReport[] = [];
  private static listeners: ((report: BugReport) => void)[] = [];

  static report(bug: BugReport) {
    this.reports.push(bug);
    this.listeners.forEach(listener => listener(bug));

    if (__DEV__) {
      console.error(
        `[AnimationBug] ${bug.type}`,
        bug.valueName,
        bug.message
      );
    }
  }

  static subscribe(listener: (report: BugReport) => void) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  static getReports() {
    return [...this.reports];
  }

  static clear() {
    this.reports = [];
  }
}

export { useBugDetector, AnimationBugReporter, BugReport, BugType };
```

### 5. Worklet ì˜¤ë¥˜ ì²˜ë¦¬

```typescript
import { useCallback } from 'react';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  runOnJS,
  withTiming,
} from 'react-native-reanimated';

// ì•ˆì „í•œ Worklet ë˜í¼
function createSafeWorklet<T extends (...args: any[]) => any>(
  fn: T,
  errorHandler?: (error: Error) => void
): T {
  'worklet';

  return ((...args: Parameters<T>) => {
    'worklet';
    try {
      return fn(...args);
    } catch (error) {
      if (errorHandler) {
        runOnJS(errorHandler)(error as Error);
      } else if (__DEV__) {
        runOnJS(console.error)('[WorkletError]', String(error));
      }
      return undefined as ReturnType<T>;
    }
  }) as T;
}

// Worklet ë””ë²„ê±° í›…
function useWorkletDebugger(name: string) {
  const errorCount = useSharedValue(0);
  const lastError = useSharedValue<string | null>(null);

  const handleError = useCallback((error: Error) => {
    console.error(`[Worklet:${name}] Error:`, error.message);
  }, [name]);

  const wrapWorklet = useCallback(<T extends (...args: any[]) => any>(
    fn: T
  ): T => {
    return createSafeWorklet(fn, handleError);
  }, [handleError]);

  const safeAnimatedStyle = useCallback((
    fn: () => Record<string, any>
  ) => {
    return useAnimatedStyle(() => {
      'worklet';
      try {
        return fn();
      } catch (error) {
        runOnJS(handleError)(error as Error);
        return {};
      }
    });
  }, [handleError]);

  return {
    wrapWorklet,
    safeAnimatedStyle,
    errorCount,
    lastError,
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
function SafeAnimatedComponent() {
  const translateX = useSharedValue(0);
  const { safeAnimatedStyle, wrapWorklet } = useWorkletDebugger('SafeComponent');

  // ì•ˆì „í•œ ê³„ì‚°
  const calculate = wrapWorklet((value: number) => {
    'worklet';
    // ì ì¬ì ìœ¼ë¡œ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ” ê³„ì‚°
    if (value < 0) {
      throw new Error('Negative value not allowed');
    }
    return Math.sqrt(value) * 100;
  });

  const animatedStyle = safeAnimatedStyle(() => {
    'worklet';
    return {
      transform: [{ translateX: calculate(translateX.value) }],
    };
  });

  return <Animated.View style={animatedStyle} />;
}

export { createSafeWorklet, useWorkletDebugger };
```

### 6. ë””ë²„ê·¸ ëŒ€ì‹œë³´ë“œ

```typescript
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  ScrollView,
  Pressable,
  StyleSheet,
  Dimensions,
} from 'react-native';
import { AnimationDebugger } from './AnimationDebugger';
import { AnimationBugReporter, BugReport } from './BugDetector';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

type Tab = 'logs' | 'bugs' | 'performance';

function DebugDashboard({ visible }: { visible: boolean }) {
  const [activeTab, setActiveTab] = useState<Tab>('logs');
  const [logs, setLogs] = useState<any[]>([]);
  const [bugs, setBugs] = useState<BugReport[]>([]);

  useEffect(() => {
    // ë¡œê·¸ ì—…ë°ì´íŠ¸
    const interval = setInterval(() => {
      setLogs(AnimationDebugger.getInstance().getLogs());
      setBugs(AnimationBugReporter.getReports());
    }, 500);

    return () => clearInterval(interval);
  }, []);

  const handleClear = useCallback(() => {
    AnimationDebugger.getInstance().clear();
    AnimationBugReporter.clear();
    setLogs([]);
    setBugs([]);
  }, []);

  if (!visible || !__DEV__) return null;

  return (
    <View style={styles.dashboard}>
      {/* íƒ­ í—¤ë” */}
      <View style={styles.tabHeader}>
        {(['logs', 'bugs', 'performance'] as Tab[]).map(tab => (
          <Pressable
            key={tab}
            style={[
              styles.tab,
              activeTab === tab && styles.activeTab,
            ]}
            onPress={() => setActiveTab(tab)}
          >
            <Text style={[
              styles.tabText,
              activeTab === tab && styles.activeTabText,
            ]}>
              {tab.toUpperCase()}
              {tab === 'bugs' && bugs.length > 0 && (
                <Text style={styles.badge}> ({bugs.length})</Text>
              )}
            </Text>
          </Pressable>
        ))}
      </View>

      {/* ì½˜í…ì¸  */}
      <ScrollView style={styles.content}>
        {activeTab === 'logs' && (
          <View>
            {logs.slice(-50).reverse().map((log, index) => (
              <View
                key={index}
                style={[
                  styles.logItem,
                  log.type === 'error' && styles.errorLog,
                  log.type === 'warning' && styles.warningLog,
                ]}
              >
                <Text style={styles.logTime}>
                  {new Date(log.timestamp).toLocaleTimeString()}
                </Text>
                <Text style={styles.logName}>{log.name}</Text>
                <Text style={styles.logValue}>
                  {log.message || JSON.stringify(log.value)}
                </Text>
              </View>
            ))}
          </View>
        )}

        {activeTab === 'bugs' && (
          <View>
            {bugs.length === 0 ? (
              <Text style={styles.emptyText}>No bugs detected</Text>
            ) : (
              bugs.map((bug, index) => (
                <View key={index} style={styles.bugItem}>
                  <View style={styles.bugHeader}>
                    <Text style={styles.bugType}>{bug.type}</Text>
                    <Text style={styles.bugTime}>
                      {new Date(bug.timestamp).toLocaleTimeString()}
                    </Text>
                  </View>
                  <Text style={styles.bugValue}>{bug.valueName}</Text>
                  <Text style={styles.bugMessage}>{bug.message}</Text>
                </View>
              ))
            )}
          </View>
        )}

        {activeTab === 'performance' && (
          <View style={styles.performanceTab}>
            <Text style={styles.comingSoon}>
              Performance metrics coming soon...
            </Text>
          </View>
        )}
      </ScrollView>

      {/* ì•¡ì…˜ ë°” */}
      <View style={styles.actionBar}>
        <Pressable style={styles.clearButton} onPress={handleClear}>
          <Text style={styles.clearButtonText}>Clear All</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  dashboard: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 300,
    backgroundColor: '#1E1E1E',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
  },
  tabHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  tab: {
    flex: 1,
    padding: 12,
    alignItems: 'center',
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: '#7A4AE2',
  },
  tabText: {
    color: '#666',
    fontSize: 12,
    fontWeight: '600',
  },
  activeTabText: {
    color: '#FFFFFF',
  },
  badge: {
    color: '#F44336',
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
    padding: 8,
  },
  logItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 6,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
    gap: 8,
  },
  errorLog: {
    backgroundColor: 'rgba(244, 67, 54, 0.2)',
  },
  warningLog: {
    backgroundColor: 'rgba(255, 193, 7, 0.2)',
  },
  logTime: {
    color: '#666',
    fontSize: 10,
    fontFamily: 'monospace',
    width: 70,
  },
  logName: {
    color: '#7A4AE2',
    fontSize: 11,
    fontWeight: '600',
    width: 80,
  },
  logValue: {
    color: '#FFFFFF',
    fontSize: 10,
    flex: 1,
    fontFamily: 'monospace',
  },
  bugItem: {
    backgroundColor: 'rgba(244, 67, 54, 0.1)',
    borderRadius: 8,
    padding: 10,
    marginBottom: 8,
  },
  bugHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  bugType: {
    color: '#F44336',
    fontSize: 12,
    fontWeight: 'bold',
  },
  bugTime: {
    color: '#666',
    fontSize: 10,
  },
  bugValue: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '600',
  },
  bugMessage: {
    color: '#999',
    fontSize: 11,
    marginTop: 4,
  },
  emptyText: {
    color: '#666',
    fontSize: 14,
    textAlign: 'center',
    marginTop: 20,
  },
  performanceTab: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  comingSoon: {
    color: '#666',
    fontSize: 14,
  },
  actionBar: {
    flexDirection: 'row',
    padding: 8,
    borderTopWidth: 1,
    borderTopColor: '#333',
  },
  clearButton: {
    backgroundColor: '#F44336',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6,
  },
  clearButtonText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '600',
  },
});

export { DebugDashboard };
```

## sometimes-app ì ìš© ì‚¬ë¡€

### ë§¤ì¹­ ì¹´ë“œ ë””ë²„ê±°

```typescript
// src/features/matching/debug/matching-debug.tsx
import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  useAnimatedReaction,
  runOnJS,
  withSpring,
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

interface SwipeDebugInfo {
  translateX: number;
  translateY: number;
  rotation: number;
  velocity: number;
  direction: 'none' | 'left' | 'right';
  phase: 'idle' | 'swiping' | 'completing';
}

export function MatchingCardDebugger({
  children,
  enabled = __DEV__,
}: {
  children: React.ReactNode;
  enabled?: boolean;
}) {
  const [debugInfo, setDebugInfo] = useState<SwipeDebugInfo>({
    translateX: 0,
    translateY: 0,
    rotation: 0,
    velocity: 0,
    direction: 'none',
    phase: 'idle',
  });
  const [showDebug, setShowDebug] = useState(true);

  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const rotation = useSharedValue(0);
  const phase = useSharedValue<'idle' | 'swiping' | 'completing'>('idle');

  const updateDebugInfo = useCallback((info: Partial<SwipeDebugInfo>) => {
    setDebugInfo(prev => ({ ...prev, ...info }));
  }, []);

  // ê°’ ë³€í™” ì¶”ì 
  useAnimatedReaction(
    () => ({
      x: translateX.value,
      y: translateY.value,
      r: rotation.value,
    }),
    (current) => {
      const direction = current.x > 50 ? 'right' :
                       current.x < -50 ? 'left' : 'none';

      runOnJS(updateDebugInfo)({
        translateX: current.x,
        translateY: current.y,
        rotation: current.r,
        direction,
      });
    },
    []
  );

  const panGesture = Gesture.Pan()
    .onStart(() => {
      phase.value = 'swiping';
      runOnJS(updateDebugInfo)({ phase: 'swiping' });
    })
    .onUpdate((event) => {
      translateX.value = event.translationX;
      translateY.value = event.translationY;
      rotation.value = event.translationX / 20;

      runOnJS(updateDebugInfo)({
        velocity: Math.sqrt(
          event.velocityX ** 2 + event.velocityY ** 2
        ),
      });
    })
    .onEnd((event) => {
      const shouldComplete = Math.abs(translateX.value) > 150;

      if (shouldComplete) {
        phase.value = 'completing';
        runOnJS(updateDebugInfo)({ phase: 'completing' });
      } else {
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
        rotation.value = withSpring(0);
        phase.value = 'idle';
        runOnJS(updateDebugInfo)({ phase: 'idle' });
      }
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotation.value}deg` },
    ],
  }));

  if (!enabled) {
    return <>{children}</>;
  }

  return (
    <View style={styles.container}>
      {/* ë””ë²„ê·¸ ì˜¤ë²„ë ˆì´ */}
      {showDebug && (
        <View style={styles.debugOverlay}>
          <View style={styles.debugHeader}>
            <Text style={styles.debugTitle}>Swipe Debug</Text>
            <Pressable onPress={() => setShowDebug(false)}>
              <Text style={styles.hideButton}>Hide</Text>
            </Pressable>
          </View>

          <View style={styles.debugRow}>
            <Text style={styles.debugLabel}>Phase:</Text>
            <Text style={[
              styles.debugValue,
              debugInfo.phase === 'swiping' && styles.activeValue,
            ]}>
              {debugInfo.phase}
            </Text>
          </View>

          <View style={styles.debugRow}>
            <Text style={styles.debugLabel}>Direction:</Text>
            <Text style={[
              styles.debugValue,
              debugInfo.direction === 'right' && styles.rightDirection,
              debugInfo.direction === 'left' && styles.leftDirection,
            ]}>
              {debugInfo.direction}
            </Text>
          </View>

          <View style={styles.debugRow}>
            <Text style={styles.debugLabel}>X:</Text>
            <Text style={styles.debugValue}>
              {debugInfo.translateX.toFixed(1)}
            </Text>
          </View>

          <View style={styles.debugRow}>
            <Text style={styles.debugLabel}>Y:</Text>
            <Text style={styles.debugValue}>
              {debugInfo.translateY.toFixed(1)}
            </Text>
          </View>

          <View style={styles.debugRow}>
            <Text style={styles.debugLabel}>Rotation:</Text>
            <Text style={styles.debugValue}>
              {debugInfo.rotation.toFixed(1)}Â°
            </Text>
          </View>

          <View style={styles.debugRow}>
            <Text style={styles.debugLabel}>Velocity:</Text>
            <Text style={styles.debugValue}>
              {debugInfo.velocity.toFixed(0)}
            </Text>
          </View>
        </View>
      )}

      {!showDebug && (
        <Pressable
          style={styles.showButton}
          onPress={() => setShowDebug(true)}
        >
          <Text style={styles.showButtonText}>Debug</Text>
        </Pressable>
      )}

      {/* ì¹´ë“œ */}
      <GestureDetector gesture={panGesture}>
        <Animated.View style={[styles.card, animatedStyle]}>
          {children}
        </Animated.View>
      </GestureDetector>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  debugOverlay: {
    position: 'absolute',
    top: 50,
    right: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    borderRadius: 12,
    padding: 12,
    zIndex: 100,
    minWidth: 150,
  },
  debugHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
    paddingBottom: 8,
  },
  debugTitle: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: 'bold',
  },
  hideButton: {
    color: '#999',
    fontSize: 12,
  },
  debugRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  debugLabel: {
    color: '#999',
    fontSize: 12,
  },
  debugValue: {
    color: '#FFFFFF',
    fontSize: 12,
    fontFamily: 'monospace',
  },
  activeValue: {
    color: '#4CAF50',
  },
  rightDirection: {
    color: '#4CAF50',
  },
  leftDirection: {
    color: '#F44336',
  },
  showButton: {
    position: 'absolute',
    top: 50,
    right: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    padding: 8,
    borderRadius: 6,
    zIndex: 100,
  },
  showButtonText: {
    color: '#FFFFFF',
    fontSize: 12,
  },
  card: {
    flex: 1,
  },
});
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. Worklet ì™¸ë¶€ì—ì„œ SharedValue ì ‘ê·¼

```typescript
// âŒ ì—ëŸ¬ ë°œìƒ
const handlePress = () => {
  console.log(translateX.value); // ì§ì ‘ ì ‘ê·¼
};

// âœ… runOnJS ì‚¬ìš©
const logValue = (value: number) => {
  console.log('Value:', value);
};

useAnimatedReaction(
  () => translateX.value,
  (value) => {
    runOnJS(logValue)(value);
  }
);
```

### 2. ì½œë°±ì—ì„œ stale closure

```typescript
// âŒ ì˜¤ë˜ëœ ìƒíƒœ ì°¸ì¡°
const handleComplete = () => {
  console.log(count); // í•­ìƒ ì´ˆê¸°ê°’
};

translateX.value = withTiming(100, {}, () => {
  runOnJS(handleComplete)();
});

// âœ… ref ë˜ëŠ” ìµœì‹  ê°’ ì „ë‹¬
const countRef = useRef(count);
countRef.current = count;

const handleComplete = () => {
  console.log(countRef.current);
};
```

### 3. ë¬´í•œ useAnimatedReaction

```typescript
// âŒ ë¬´í•œ ë£¨í”„
useAnimatedReaction(
  () => value.value,
  (current) => {
    value.value = current + 1; // ë‹¤ì‹œ íŠ¸ë¦¬ê±°!
  }
);

// âœ… ì¡°ê±´ë¶€ ì—…ë°ì´íŠ¸
useAnimatedReaction(
  () => value.value,
  (current, previous) => {
    if (current !== previous && current < 100) {
      // ì¡°ê±´ ì²´í¬
    }
  }
);
```

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **ë””ë²„ê·¸ ë¡œê±°**: ì• ë‹ˆë©”ì´ì…˜ ê°’ ë³€í™” ì¶”ì  ì‹œìŠ¤í…œ
2. **ê°’ ì‹œê°í™”**: ì‹¤ì‹œê°„ ê°’ ë³€í™” ê·¸ë˜í”„
3. **ì œìŠ¤ì²˜ ë””ë²„ê¹…**: í„°ì¹˜ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§
4. **ë²„ê·¸ ê°ì§€**: NaN, Infinity, ë¬´í•œ ë£¨í”„ ìë™ ê°ì§€
5. **Worklet ì•ˆì „ì„±**: ì˜¤ë¥˜ ì²˜ë¦¬ ë˜í¼
6. **ë””ë²„ê·¸ ëŒ€ì‹œë³´ë“œ**: í†µí•© ë””ë²„ê¹… UI

## ë‹¤ìŒ ì¥ ì˜ˆê³ 

**Chapter 63: í”„ë¡œë•ì…˜ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸**ì—ì„œëŠ” ì•±ì„ í”„ë¡œë•ì…˜ì— ë°°í¬í•˜ê¸° ì „ í™•ì¸í•´ì•¼ í•  ì• ë‹ˆë©”ì´ì…˜ ìµœì í™” í•­ëª©ë“¤ì„ ì •ë¦¬í•©ë‹ˆë‹¤. ìµœì¢… ì„±ëŠ¥ ê²€ì¦, ë””ë²„ê·¸ ì½”ë“œ ì œê±°, ë²ˆë“¤ ìµœì í™” ë“±ì„ ë‹¤ë£¹ë‹ˆë‹¤.
