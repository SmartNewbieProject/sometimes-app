# Chapter 78: ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ

ReanimatedëŠ” ì§€ì†ì ìœ¼ë¡œ ë°œì „í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤. ì´ ì¥ì—ì„œëŠ” ë²„ì „ ì—…ê·¸ë ˆì´ë“œ ì‹œ ë°œìƒí•˜ëŠ” ë³€ê²½ì‚¬í•­ì— ëŒ€ì‘í•˜ê³ , ê¸°ì¡´ ì½”ë“œë¥¼ ì•ˆì „í•˜ê²Œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- Reanimated ë²„ì „ë³„ ì£¼ìš” ë³€ê²½ì‚¬í•­ ì´í•´
- ì•ˆì „í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ ìˆ˜ë¦½
- í˜¸í™˜ì„± ë ˆì´ì–´ êµ¬í˜„
- ìë™í™”ëœ ì½”ë“œ ë³€í™˜ ë„êµ¬ í™œìš©

## ğŸ“– ë²„ì „ íˆìŠ¤í† ë¦¬ ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Reanimated ë²„ì „ íƒ€ì„ë¼ì¸                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  v1.x    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
â”‚  â”‚ Animated.Value ê¸°ë°˜                                      â”‚
â”‚  â”‚ ì„ ì–¸ì  API                                               â”‚
â”‚  â””â”€â”€ 2019-2020                                              â”‚
â”‚                                                             â”‚
â”‚  v2.x    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
â”‚  â”‚ SharedValue ë„ì…                                          â”‚
â”‚  â”‚ Worklet ì‹œìŠ¤í…œ                                            â”‚
â”‚  â”‚ useAnimatedStyle                                         â”‚
â”‚  â””â”€â”€ 2020-2023                                              â”‚
â”‚                                                             â”‚
â”‚  v3.x    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
â”‚  â”‚ ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜ ì§€ì›                                       â”‚
â”‚  â”‚ Gesture Handler 2 í†µí•©                                   â”‚
â”‚  â”‚ Layout Animations ê°œì„                                    â”‚
â”‚  â””â”€â”€ 2023-2024                                              â”‚
â”‚                                                             â”‚
â”‚  v4.x    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
â”‚  â”‚ React Native 0.76+ í•„ìˆ˜                                  â”‚
â”‚  â”‚ ì‹ ê·œ ì•„í‚¤í…ì²˜ ê¸°ë³¸ê°’                                       â”‚
â”‚  â”‚ CSS Animations ì§€ì›                                      â”‚
â”‚  â””â”€â”€ 2024-í˜„ì¬                                               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 1: v2ì—ì„œ v3ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜

```typescript
// ============================================
// 1. useAnimatedGestureHandler ì œê±°
// ============================================

// âŒ v2 ë°©ì‹ (deprecated)
import { PanGestureHandler } from 'react-native-gesture-handler';
import { useAnimatedGestureHandler } from 'react-native-reanimated';

function OldGestureComponent() {
  const translateX = useSharedValue(0);

  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, ctx) => {
      ctx.startX = translateX.value;
    },
    onActive: (event, ctx) => {
      translateX.value = ctx.startX + event.translationX;
    },
    onEnd: () => {
      translateX.value = withSpring(0);
    },
  });

  return (
    <PanGestureHandler onGestureEvent={gestureHandler}>
      <Animated.View style={useAnimatedStyle(() => ({
        transform: [{ translateX: translateX.value }],
      }))} />
    </PanGestureHandler>
  );
}

// âœ… v3 ë°©ì‹ (Gesture Handler 2)
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

function NewGestureComponent() {
  const translateX = useSharedValue(0);
  const context = useSharedValue({ startX: 0 });

  const panGesture = Gesture.Pan()
    .onStart(() => {
      context.value.startX = translateX.value;
    })
    .onUpdate((event) => {
      translateX.value = context.value.startX + event.translationX;
    })
    .onEnd(() => {
      translateX.value = withSpring(0);
    });

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={useAnimatedStyle(() => ({
        transform: [{ translateX: translateX.value }],
      }))} />
    </GestureDetector>
  );
}

// ============================================
// 2. withRepeat ì‹œê·¸ë‹ˆì²˜ ë³€ê²½
// ============================================

// âŒ v2 ë°©ì‹
rotation.value = withRepeat(
  withTiming(360, { duration: 1000 }),
  -1,  // ë¬´í•œ ë°˜ë³µ
  false // ì—­ë°©í–¥ ì—†ìŒ
);

// âœ… v3 ë°©ì‹ (ë™ì¼í•˜ì§€ë§Œ íƒ€ì… ê°œì„ )
rotation.value = withRepeat(
  withTiming(360, { duration: 1000 }),
  -1,
  false,
  (finished, current) => {
    // ìƒˆë¡œìš´ ì½œë°± ì‹œê·¸ë‹ˆì²˜
    if (finished) {
      console.log('Repeat completed at:', current);
    }
  }
);

// ============================================
// 3. Entering/Exiting ì• ë‹ˆë©”ì´ì…˜ ê°œì„ 
// ============================================

// âŒ v2 ë°©ì‹
import { FadeIn, FadeOut } from 'react-native-reanimated';

<Animated.View entering={FadeIn} exiting={FadeOut}>
  {content}
</Animated.View>

// âœ… v3 ë°©ì‹ (ë” ì„¸ë°€í•œ ì œì–´)
import {
  FadeIn,
  FadeOut,
  LinearTransition,
} from 'react-native-reanimated';

<Animated.View
  entering={FadeIn.duration(300).springify().damping(15)}
  exiting={FadeOut.duration(200)}
  layout={LinearTransition.springify()}
>
  {content}
</Animated.View>
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 2: v3ì—ì„œ v4ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜

```typescript
// ============================================
// 1. ì‹ ê·œ ì•„í‚¤í…ì²˜ í•„ìˆ˜í™”
// ============================================

// babel.config.js ë³€ê²½ ë¶ˆí•„ìš” (ìë™ ì ìš©)
// ë‹¨, React Native 0.76+ í•„ìˆ˜

// package.json
{
  "dependencies": {
    "react-native": "^0.76.0",
    "react-native-reanimated": "^4.0.0"
  }
}

// ============================================
// 2. useSharedValue ì´ˆê¸°í™” ê°œì„ 
// ============================================

// âŒ v3 ì´ì „ - ì´ˆê¸°ê°’ ì œí•œ
const value = useSharedValue<ComplexType | null>(null);

// âœ… v4 - í•¨ìˆ˜ ì´ˆê¸°í™” ì§€ì›
const value = useSharedValue(() => {
  // ë³µì¡í•œ ì´ˆê¸°í™” ë¡œì§
  return computeInitialValue();
});

// ============================================
// 3. CSS Animations ì§€ì›
// ============================================

// v4 ì‹ ê·œ ê¸°ëŠ¥
import { useAnimatedStyle, Easing } from 'react-native-reanimated';

function CSSAnimationExample() {
  const animatedStyle = useAnimatedStyle(() => ({
    // CSS keyframe ìŠ¤íƒ€ì¼ ì• ë‹ˆë©”ì´ì…˜
    animation: 'pulse 2s ease-in-out infinite',
  }));

  return <Animated.View style={animatedStyle} />;
}

// ì»¤ìŠ¤í…€ keyframes ì •ì˜
import { createAnimatedKeyframes } from 'react-native-reanimated';

const pulseKeyframes = createAnimatedKeyframes({
  '0%': { transform: [{ scale: 1 }], opacity: 1 },
  '50%': { transform: [{ scale: 1.1 }], opacity: 0.8 },
  '100%': { transform: [{ scale: 1 }], opacity: 1 },
});

// ============================================
// 4. í–¥ìƒëœ ì œìŠ¤ì²˜ í†µí•©
// ============================================

// v4ì—ì„œ Gesture Handlerì™€ ë” ê¸´ë°€í•œ í†µí•©
import { Gesture } from 'react-native-gesture-handler';
import { useAnimatedStyle, withSpring } from 'react-native-reanimated';

function EnhancedGesture() {
  const scale = useSharedValue(1);
  const rotation = useSharedValue(0);

  // ë³µí•© ì œìŠ¤ì²˜ê°€ ë” ìì—°ìŠ¤ëŸ½ê²Œ ë™ì‘
  const composed = Gesture.Simultaneous(
    Gesture.Pinch()
      .onUpdate((e) => {
        scale.value = e.scale;
      })
      .onEnd(() => {
        scale.value = withSpring(1);
      }),
    Gesture.Rotation()
      .onUpdate((e) => {
        rotation.value = e.rotation;
      })
      .onEnd(() => {
        rotation.value = withSpring(0);
      })
  );

  // useAnimatedStyleì´ ìë™ìœ¼ë¡œ ìµœì í™”ë¨
  const style = useAnimatedStyle(() => ({
    transform: [
      { scale: scale.value },
      { rotate: `${rotation.value}rad` },
    ],
  }));

  return (
    <GestureDetector gesture={composed}>
      <Animated.View style={style} />
    </GestureDetector>
  );
}
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 3: í˜¸í™˜ì„± ë ˆì´ì–´ êµ¬í˜„

```typescript
// src/shared/libs/reanimated-compat.ts

import { Platform } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import { version as rnVersion } from 'react-native/package.json';

// ë²„ì „ ê°ì§€
const REANIMATED_VERSION = require('react-native-reanimated/package.json').version;
const isV3OrAbove = parseInt(REANIMATED_VERSION.split('.')[0]) >= 3;
const isV4OrAbove = parseInt(REANIMATED_VERSION.split('.')[0]) >= 4;

// ============================================
// ì œìŠ¤ì²˜ í•¸ë“¤ëŸ¬ í˜¸í™˜ì„± ë˜í¼
// ============================================

interface GestureContext {
  [key: string]: any;
}

interface LegacyGestureHandlers<T extends GestureContext = GestureContext> {
  onStart?: (event: any, context: T) => void;
  onActive?: (event: any, context: T) => void;
  onEnd?: (event: any, context: T) => void;
  onFail?: (event: any, context: T) => void;
  onCancel?: (event: any, context: T) => void;
}

export function createPanGesture<T extends GestureContext>(
  handlers: LegacyGestureHandlers<T>,
  initialContext?: T
) {
  const context = useSharedValue<T>(initialContext || ({} as T));

  const gesture = Gesture.Pan()
    .onStart((event) => {
      if (handlers.onStart) {
        handlers.onStart(event, context.value);
      }
    })
    .onUpdate((event) => {
      if (handlers.onActive) {
        handlers.onActive(event, context.value);
      }
    })
    .onEnd((event) => {
      if (handlers.onEnd) {
        handlers.onEnd(event, context.value);
      }
    })
    .onFinalize((event, success) => {
      if (!success && handlers.onCancel) {
        handlers.onCancel(event, context.value);
      }
    });

  return { gesture, context };
}

// ë ˆê±°ì‹œ ìŠ¤íƒ€ì¼ API ë˜í¼
export function useAnimatedGestureHandlerCompat<T extends GestureContext>(
  handlers: LegacyGestureHandlers<T>,
  dependencies: any[] = []
) {
  console.warn(
    'useAnimatedGestureHandlerCompat is deprecated. ' +
    'Please migrate to Gesture.Pan() API.'
  );

  return createPanGesture(handlers);
}

// ============================================
// withRepeat í˜¸í™˜ì„±
// ============================================

type RepeatCallback = (finished?: boolean, current?: number) => void;

export function withRepeatCompat(
  animation: any,
  numberOfReps: number = 1,
  reverse: boolean = false,
  callback?: RepeatCallback
) {
  if (isV4OrAbove) {
    // v4 ì‹œê·¸ë‹ˆì²˜
    return withRepeat(animation, numberOfReps, reverse, callback);
  }

  // v3 ì´í•˜ í˜¸í™˜ì„±
  return withRepeat(
    animation,
    numberOfReps,
    reverse,
    callback ? (finished) => callback(finished, undefined) : undefined
  );
}

// ============================================
// Layout Animation í˜¸í™˜ì„±
// ============================================

import {
  FadeIn,
  FadeOut,
  LinearTransition,
  LayoutAnimationConfig,
} from 'react-native-reanimated';

interface LayoutAnimationOptions {
  duration?: number;
  damping?: number;
  stiffness?: number;
  mass?: number;
}

export function createEnteringAnimation(
  type: 'fade' | 'slide' | 'zoom',
  options: LayoutAnimationOptions = {}
) {
  const { duration = 300, damping = 15, stiffness = 100 } = options;

  switch (type) {
    case 'fade':
      return FadeIn.duration(duration);

    case 'slide':
      if (isV3OrAbove) {
        return FadeIn.duration(duration)
          .springify()
          .damping(damping)
          .stiffness(stiffness);
      }
      return FadeIn.duration(duration);

    case 'zoom':
      if (isV3OrAbove) {
        return FadeIn.duration(duration)
          .springify()
          .damping(damping);
      }
      return FadeIn.duration(duration);

    default:
      return FadeIn.duration(duration);
  }
}

export function createExitingAnimation(
  type: 'fade' | 'slide' | 'zoom',
  options: LayoutAnimationOptions = {}
) {
  const { duration = 200 } = options;

  switch (type) {
    case 'fade':
    case 'slide':
    case 'zoom':
    default:
      return FadeOut.duration(duration);
  }
}

// ============================================
// useSharedValue í˜¸í™˜ì„±
// ============================================

type SharedValueInitializer<T> = T | (() => T);

export function useSharedValueCompat<T>(
  initialValue: SharedValueInitializer<T>
) {
  // v4ì—ì„œëŠ” í•¨ìˆ˜ ì´ˆê¸°í™” ì§€ì›
  if (isV4OrAbove && typeof initialValue === 'function') {
    return useSharedValue(initialValue);
  }

  // v3 ì´í•˜ì—ì„œëŠ” ì¦‰ì‹œ í‰ê°€
  const value = typeof initialValue === 'function'
    ? (initialValue as () => T)()
    : initialValue;

  return useSharedValue(value);
}

// ============================================
// Worklet í•¨ìˆ˜ í˜¸í™˜ì„±
// ============================================

// v4ì—ì„œ ë³€ê²½ëœ runOnJS ë™ì‘ ë˜í•‘
export function runOnJSCompat<T extends (...args: any[]) => any>(fn: T) {
  return (...args: Parameters<T>) => {
    'worklet';
    return runOnJS(fn)(...args);
  };
}

// ============================================
// í”Œë«í¼ë³„ í˜¸í™˜ì„±
// ============================================

export const AnimationConfig = {
  // í”Œë«í¼ë³„ ê¸°ë³¸ê°’
  defaultSpringConfig: Platform.select({
    ios: { damping: 15, stiffness: 100, mass: 1 },
    android: { damping: 20, stiffness: 150, mass: 1 },
    default: { damping: 15, stiffness: 100, mass: 1 },
  }),

  // ë²„ì „ë³„ ê¸°ëŠ¥ í”Œë˜ê·¸
  features: {
    cssAnimations: isV4OrAbove,
    enhancedGestures: isV3OrAbove,
    layoutAnimations: isV3OrAbove,
    workletContext: isV4OrAbove,
  },
};

// ============================================
// ë‚´ë³´ë‚´ê¸°
// ============================================

export {
  isV3OrAbove,
  isV4OrAbove,
  REANIMATED_VERSION,
};
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 4: ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸

```typescript
// scripts/migrate-reanimated.ts

import * as fs from 'fs';
import * as path from 'path';
import * as parser from '@babel/parser';
import traverse from '@babel/traverse';
import generate from '@babel/generator';
import * as t from '@babel/types';

interface MigrationResult {
  file: string;
  changes: string[];
  warnings: string[];
}

const migrations = {
  // useAnimatedGestureHandler â†’ Gesture API
  migrateGestureHandler: (code: string): { code: string; changes: string[] } => {
    const changes: string[] = [];
    const ast = parser.parse(code, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    traverse(ast, {
      CallExpression(path) {
        if (
          t.isIdentifier(path.node.callee) &&
          path.node.callee.name === 'useAnimatedGestureHandler'
        ) {
          changes.push('Found useAnimatedGestureHandler - manual migration required');

          // ì£¼ì„ ì¶”ê°€
          path.addComment(
            'leading',
            ' TODO: Migrate to Gesture.Pan() API\n' +
            ' See: https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/gesture',
            true
          );
        }
      },

      ImportDeclaration(path) {
        if (
          path.node.source.value === 'react-native-reanimated' &&
          path.node.specifiers.some(
            (spec) =>
              t.isImportSpecifier(spec) &&
              t.isIdentifier(spec.imported) &&
              spec.imported.name === 'useAnimatedGestureHandler'
          )
        ) {
          changes.push('Removing deprecated useAnimatedGestureHandler import');

          // import ì œê±°
          path.node.specifiers = path.node.specifiers.filter(
            (spec) =>
              !(
                t.isImportSpecifier(spec) &&
                t.isIdentifier(spec.imported) &&
                spec.imported.name === 'useAnimatedGestureHandler'
              )
          );

          // Gesture Handler 2 import ì¶”ê°€
          const gestureImport = t.importDeclaration(
            [
              t.importSpecifier(
                t.identifier('Gesture'),
                t.identifier('Gesture')
              ),
              t.importSpecifier(
                t.identifier('GestureDetector'),
                t.identifier('GestureDetector')
              ),
            ],
            t.stringLiteral('react-native-gesture-handler')
          );

          path.insertAfter(gestureImport);
        }
      },
    });

    return { code: generate(ast).code, changes };
  },

  // PanGestureHandler â†’ GestureDetector
  migratePanGestureHandler: (code: string): { code: string; changes: string[] } => {
    const changes: string[] = [];

    // ê°„ë‹¨í•œ ë¬¸ìì—´ ì¹˜í™˜ (ì‹¤ì œë¡œëŠ” AST ì‚¬ìš© ê¶Œì¥)
    if (code.includes('PanGestureHandler')) {
      changes.push('Found PanGestureHandler - replacing with GestureDetector');

      code = code.replace(
        /<PanGestureHandler\s+onGestureEvent=\{([^}]+)\}/g,
        (match, handler) => {
          return `<GestureDetector gesture={/* TODO: Create Gesture.Pan() for ${handler} */}`;
        }
      );

      code = code.replace(
        /<\/PanGestureHandler>/g,
        '</GestureDetector>'
      );
    }

    return { code, changes };
  },

  // withRepeat ì½œë°± ì‹œê·¸ë‹ˆì²˜ ì—…ë°ì´íŠ¸
  migrateWithRepeat: (code: string): { code: string; changes: string[] } => {
    const changes: string[] = [];
    const ast = parser.parse(code, {
      sourceType: 'module',
      plugins: ['typescript', 'jsx'],
    });

    traverse(ast, {
      CallExpression(path) {
        if (
          t.isIdentifier(path.node.callee) &&
          path.node.callee.name === 'withRepeat' &&
          path.node.arguments.length === 4
        ) {
          const callback = path.node.arguments[3];

          if (t.isArrowFunctionExpression(callback)) {
            // ì½œë°± íŒŒë¼ë¯¸í„°ê°€ 1ê°œì¸ ê²½ìš° 2ê°œë¡œ í™•ì¥
            if (callback.params.length === 1) {
              changes.push('Updating withRepeat callback signature');

              callback.params.push(t.identifier('current'));

              // ì½œë°± ë³¸ë¬¸ì— ì£¼ì„ ì¶”ê°€
              path.addComment(
                'trailing',
                ' Updated callback signature for v3+',
                true
              );
            }
          }
        }
      },
    });

    return { code: generate(ast).code, changes };
  },

  // Layout Animation ê°œì„ 
  migrateLayoutAnimations: (code: string): { code: string; changes: string[] } => {
    const changes: string[] = [];

    // entering/exitingì— duration ì¶”ê°€ ê¶Œì¥
    const enteringRegex = /entering=\{(\w+)\}/g;
    let match;

    while ((match = enteringRegex.exec(code)) !== null) {
      if (!match[1].includes('.duration')) {
        changes.push(
          `Consider adding .duration() to ${match[1]} for explicit timing control`
        );
      }
    }

    return { code, changes };
  },
};

async function migrateFile(filePath: string): Promise<MigrationResult> {
  const result: MigrationResult = {
    file: filePath,
    changes: [],
    warnings: [],
  };

  try {
    let code = fs.readFileSync(filePath, 'utf-8');

    // ê° ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©
    for (const [name, migrate] of Object.entries(migrations)) {
      const { code: newCode, changes } = migrate(code);
      code = newCode;
      result.changes.push(...changes.map((c) => `[${name}] ${c}`));
    }

    // ë³€ê²½ì‚¬í•­ì´ ìˆìœ¼ë©´ íŒŒì¼ ì €ì¥
    if (result.changes.length > 0) {
      fs.writeFileSync(filePath, code);
    }
  } catch (error) {
    result.warnings.push(`Failed to process: ${error}`);
  }

  return result;
}

async function migrateProject(srcDir: string): Promise<void> {
  console.log('Starting Reanimated migration...\n');

  const files = findTsxFiles(srcDir);
  const results: MigrationResult[] = [];

  for (const file of files) {
    const result = await migrateFile(file);
    if (result.changes.length > 0 || result.warnings.length > 0) {
      results.push(result);
    }
  }

  // ê²°ê³¼ ì¶œë ¥
  console.log('\n=== Migration Summary ===\n');

  for (const result of results) {
    console.log(`ğŸ“ ${result.file}`);

    for (const change of result.changes) {
      console.log(`  âœ… ${change}`);
    }

    for (const warning of result.warnings) {
      console.log(`  âš ï¸ ${warning}`);
    }

    console.log('');
  }

  console.log(`Total files processed: ${files.length}`);
  console.log(`Files with changes: ${results.length}`);
}

function findTsxFiles(dir: string): string[] {
  const files: string[] = [];

  const items = fs.readdirSync(dir);

  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
      files.push(...findTsxFiles(fullPath));
    } else if (item.endsWith('.tsx') || item.endsWith('.ts')) {
      files.push(fullPath);
    }
  }

  return files;
}

// ì‹¤í–‰
const srcPath = process.argv[2] || './src';
migrateProject(srcPath);
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 5: ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

```typescript
// src/shared/providers/reanimated-migration-provider.tsx

import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

interface MigrationState {
  completedMigrations: string[];
  currentVersion: string;
  targetVersion: string;
}

interface MigrationContextType {
  state: MigrationState;
  isMigrating: boolean;
  markMigrationComplete: (migrationId: string) => Promise<void>;
  checkMigration: (migrationId: string) => boolean;
  useNewApi: (featureId: string) => boolean;
}

const MigrationContext = createContext<MigrationContextType | null>(null);

// ê¸°ëŠ¥ë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ í”Œë˜ê·¸
const FEATURE_FLAGS: Record<string, { minVersion: string; migrationId: string }> = {
  gestureHandler2: { minVersion: '3.0.0', migrationId: 'gh2-migration' },
  layoutAnimationsV2: { minVersion: '3.0.0', migrationId: 'layout-v2-migration' },
  cssAnimations: { minVersion: '4.0.0', migrationId: 'css-anim-migration' },
  enhancedWorklets: { minVersion: '4.0.0', migrationId: 'worklet-v2-migration' },
};

export function ReanimatedMigrationProvider({
  children,
  currentVersion,
  targetVersion,
}: {
  children: React.ReactNode;
  currentVersion: string;
  targetVersion: string;
}) {
  const [state, setState] = useState<MigrationState>({
    completedMigrations: [],
    currentVersion,
    targetVersion,
  });
  const [isMigrating, setIsMigrating] = useState(false);

  useEffect(() => {
    loadMigrationState();
  }, []);

  const loadMigrationState = async () => {
    try {
      const saved = await AsyncStorage.getItem('reanimated-migrations');
      if (saved) {
        const parsed = JSON.parse(saved);
        setState((prev) => ({
          ...prev,
          completedMigrations: parsed.completedMigrations || [],
        }));
      }
    } catch (error) {
      console.warn('Failed to load migration state:', error);
    }
  };

  const markMigrationComplete = async (migrationId: string) => {
    const newCompleted = [...state.completedMigrations, migrationId];

    setState((prev) => ({
      ...prev,
      completedMigrations: newCompleted,
    }));

    try {
      await AsyncStorage.setItem(
        'reanimated-migrations',
        JSON.stringify({ completedMigrations: newCompleted })
      );
    } catch (error) {
      console.warn('Failed to save migration state:', error);
    }
  };

  const checkMigration = (migrationId: string): boolean => {
    return state.completedMigrations.includes(migrationId);
  };

  const useNewApi = (featureId: string): boolean => {
    const feature = FEATURE_FLAGS[featureId];
    if (!feature) return false;

    // ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ ì—¬ë¶€ í™•ì¸
    if (!checkMigration(feature.migrationId)) {
      return false;
    }

    // ë²„ì „ í™•ì¸
    return compareVersions(state.currentVersion, feature.minVersion) >= 0;
  };

  return (
    <MigrationContext.Provider
      value={{
        state,
        isMigrating,
        markMigrationComplete,
        checkMigration,
        useNewApi,
      }}
    >
      {children}
    </MigrationContext.Provider>
  );
}

export function useMigration() {
  const context = useContext(MigrationContext);
  if (!context) {
    throw new Error('useMigration must be used within ReanimatedMigrationProvider');
  }
  return context;
}

// ë²„ì „ ë¹„êµ ìœ í‹¸ë¦¬í‹°
function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(Number);
  const parts2 = v2.split('.').map(Number);

  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const p1 = parts1[i] || 0;
    const p2 = parts2[i] || 0;

    if (p1 > p2) return 1;
    if (p1 < p2) return -1;
  }

  return 0;
}

// ============================================
// ë§ˆì´ê·¸ë ˆì´ì…˜ ë˜í¼ ì»´í¬ë„ŒíŠ¸
// ============================================

interface MigrationWrapperProps {
  featureId: string;
  legacyComponent: React.ReactNode;
  newComponent: React.ReactNode;
  fallbackOnError?: boolean;
}

export function MigrationWrapper({
  featureId,
  legacyComponent,
  newComponent,
  fallbackOnError = true,
}: MigrationWrapperProps) {
  const { useNewApi } = useMigration();
  const [hasError, setHasError] = useState(false);

  if (hasError && fallbackOnError) {
    return <>{legacyComponent}</>;
  }

  if (useNewApi(featureId)) {
    return (
      <ErrorBoundary onError={() => setHasError(true)}>
        {newComponent}
      </ErrorBoundary>
    );
  }

  return <>{legacyComponent}</>;
}

// ê°„ë‹¨í•œ ì—ëŸ¬ ë°”ìš´ë”ë¦¬
class ErrorBoundary extends React.Component<{
  children: React.ReactNode;
  onError?: () => void;
}> {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error) {
    console.warn('Migration component error:', error);
    this.props.onError?.();
  }

  render() {
    if (this.state.hasError) {
      return null;
    }
    return this.props.children;
  }
}

// ============================================
// ì‚¬ìš© ì˜ˆì‹œ
// ============================================

// ë ˆê±°ì‹œ ì œìŠ¤ì²˜ ì»´í¬ë„ŒíŠ¸
function LegacySwipeCard({ onSwipe }: { onSwipe: (direction: string) => void }) {
  // v2 ìŠ¤íƒ€ì¼ êµ¬í˜„
  return <View />;
}

// ìƒˆë¡œìš´ ì œìŠ¤ì²˜ ì»´í¬ë„ŒíŠ¸
function NewSwipeCard({ onSwipe }: { onSwipe: (direction: string) => void }) {
  // v3+ Gesture Handler 2 êµ¬í˜„
  return <View />;
}

// ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©
function SwipeCardWithMigration(props: { onSwipe: (direction: string) => void }) {
  return (
    <MigrationWrapper
      featureId="gestureHandler2"
      legacyComponent={<LegacySwipeCard {...props} />}
      newComponent={<NewSwipeCard {...props} />}
      fallbackOnError={true}
    />
  );
}
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©

```typescript
// src/features/matching/ui/swipe-card.tsx

import { useMigration, MigrationWrapper } from '@/src/shared/providers/reanimated-migration-provider';
import { LegacySwipeCard } from './legacy-swipe-card';
import { ModernSwipeCard } from './modern-swipe-card';

interface SwipeCardProps {
  profile: MatchProfile;
  onSwipe: (direction: 'left' | 'right') => void;
  onSuperLike: () => void;
}

export function SwipeCard(props: SwipeCardProps) {
  const { useNewApi, markMigrationComplete } = useMigration();

  // ìƒˆ API ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ì— ë”°ë¼ ë¶„ê¸°
  if (useNewApi('gestureHandler2')) {
    return <ModernSwipeCard {...props} />;
  }

  // ë ˆê±°ì‹œ ì§€ì› (ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜)
  return <LegacySwipeCard {...props} />;
}

// ë ˆê±°ì‹œ ë²„ì „ (deprecated)
// src/features/matching/ui/legacy-swipe-card.tsx
function LegacySwipeCard({ profile, onSwipe, onSuperLike }: SwipeCardProps) {
  console.warn(
    'LegacySwipeCard is deprecated. ' +
    'Complete gestureHandler2 migration to use ModernSwipeCard.'
  );

  // v2 ìŠ¤íƒ€ì¼ useAnimatedGestureHandler ì‚¬ìš©
  // ...

  return (
    <PanGestureHandler onGestureEvent={gestureHandler}>
      <Animated.View style={[styles.card, animatedStyle]}>
        <ProfileContent profile={profile} />
      </Animated.View>
    </PanGestureHandler>
  );
}

// ëª¨ë˜ ë²„ì „
// src/features/matching/ui/modern-swipe-card.tsx
function ModernSwipeCard({ profile, onSwipe, onSuperLike }: SwipeCardProps) {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const context = useSharedValue({ startX: 0, startY: 0 });

  const panGesture = Gesture.Pan()
    .onStart(() => {
      context.value = {
        startX: translateX.value,
        startY: translateY.value,
      };
    })
    .onUpdate((event) => {
      translateX.value = context.value.startX + event.translationX;
      translateY.value = context.value.startY + event.translationY * 0.5;
    })
    .onEnd((event) => {
      const shouldSwipe = Math.abs(event.translationX) > SWIPE_THRESHOLD;

      if (shouldSwipe) {
        const direction = event.translationX > 0 ? 'right' : 'left';

        translateX.value = withSpring(
          event.translationX > 0 ? SCREEN_WIDTH : -SCREEN_WIDTH,
          { velocity: event.velocityX },
          () => {
            runOnJS(onSwipe)(direction);
          }
        );
      } else {
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
      }
    });

  // ìˆ˜ì§ ìŠ¤ì™€ì´í”„ë¡œ Super Like
  const verticalGesture = Gesture.Pan()
    .activeOffsetY([-20, 20])
    .failOffsetX([-10, 10])
    .onEnd((event) => {
      if (event.translationY < -100) {
        runOnJS(onSuperLike)();
      }
    });

  const composedGesture = Gesture.Race(panGesture, verticalGesture);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${(translateX.value / SCREEN_WIDTH) * 20}deg` },
    ],
  }));

  return (
    <GestureDetector gesture={composedGesture}>
      <Animated.View style={[styles.card, animatedStyle]}>
        <ProfileContent profile={profile} />
      </Animated.View>
    </GestureDetector>
  );
}

// ë§ˆì´ê·¸ë ˆì´ì…˜ íŠ¸ë˜ì»¤
// src/features/matching/hooks/use-migration-tracker.ts
export function useMigrationTracker() {
  const { markMigrationComplete, checkMigration } = useMigration();

  const completeMigration = async (featureId: string) => {
    await markMigrationComplete(`${featureId}-migration`);

    // ë¶„ì„ ì´ë²¤íŠ¸ ì „ì†¡
    analytics.track('migration_completed', {
      feature: featureId,
      version: REANIMATED_VERSION,
    });
  };

  const getMigrationStatus = () => {
    return {
      gestureHandler2: checkMigration('gh2-migration'),
      layoutAnimationsV2: checkMigration('layout-v2-migration'),
      cssAnimations: checkMigration('css-anim-migration'),
    };
  };

  return {
    completeMigration,
    getMigrationStatus,
  };
}
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ì œìŠ¤ì²˜ ì»¨í…ìŠ¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜ ì˜¤ë¥˜

```typescript
// âŒ ì˜ëª»ëœ ë°©ì‹: ctxë¥¼ ì§ì ‘ ì‚¬ìš©
const gestureHandler = useAnimatedGestureHandler({
  onStart: (_, ctx) => {
    ctx.startX = translateX.value; // ctx ê°ì²´ ì§ì ‘ ìˆ˜ì •
  },
});

// âœ… ì˜¬ë°”ë¥¸ ë°©ì‹: SharedValueë¡œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
const context = useSharedValue({ startX: 0 });

const gesture = Gesture.Pan()
  .onStart(() => {
    context.value = { startX: translateX.value };
  });
```

### 2. import ë¬¸ ì—…ë°ì´íŠ¸ ëˆ„ë½

```typescript
// âŒ ì˜ëª»ëœ ë°©ì‹: ë ˆê±°ì‹œ import ìœ ì§€
import { PanGestureHandler } from 'react-native-gesture-handler';

// âœ… ì˜¬ë°”ë¥¸ ë°©ì‹: ìƒˆ API import
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
```

### 3. ì½œë°± ì‹œê·¸ë‹ˆì²˜ ë¶ˆì¼ì¹˜

```typescript
// âŒ ì˜ëª»ëœ ë°©ì‹: ì´ì „ ì½œë°± ì‹œê·¸ë‹ˆì²˜
withRepeat(anim, -1, false, (finished) => {
  // v3+ì—ì„œëŠ” current íŒŒë¼ë¯¸í„°ë„ ë°›ìŒ
});

// âœ… ì˜¬ë°”ë¥¸ ë°©ì‹: ìƒˆ ì½œë°± ì‹œê·¸ë‹ˆì²˜
withRepeat(anim, -1, false, (finished, current) => {
  console.log('Finished:', finished, 'Current value:', current);
});
```

## ğŸ’¡ íŒ

1. **ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜**: í•œ ë²ˆì— ëª¨ë“  ì½”ë“œë¥¼ ë³€ê²½í•˜ì§€ ë§ê³  ê¸°ëŠ¥ ë‹¨ìœ„ë¡œ ì§„í–‰
2. **í…ŒìŠ¤íŠ¸ ìš°ì„ **: ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ ê¸°ì¡´ ë™ì‘ì„ í…ŒìŠ¤íŠ¸ë¡œ ë¬¸ì„œí™”
3. **í”¼ì²˜ í”Œë˜ê·¸ í™œìš©**: ìƒˆ APIì™€ ë ˆê±°ì‹œ APIë¥¼ ë™ì‹œì— ìœ ì§€í•˜ë©° ì ì§„ì  ì „í™˜
4. **ë²„ì „ í˜¸í™˜ì„± ë ˆì´ì–´**: í˜¸í™˜ì„± ìœ í‹¸ë¦¬í‹°ë¡œ ì½”ë“œ ë³€ê²½ ìµœì†Œí™”
5. **CIì—ì„œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê²€ì¦**: ìë™í™”ëœ ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ: ë ˆê±°ì‹œ ì œìŠ¤ì²˜ ì½”ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜

ë‹¤ìŒ v2 ìŠ¤íƒ€ì¼ ì½”ë“œë¥¼ v3+ Gesture Handler 2 APIë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ì„¸ìš”.

```typescript
// ë ˆê±°ì‹œ ì½”ë“œ
function DraggableBox() {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);

  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, ctx) => {
      ctx.startX = translateX.value;
      ctx.startY = translateY.value;
    },
    onActive: (event, ctx) => {
      translateX.value = ctx.startX + event.translationX;
      translateY.value = ctx.startY + event.translationY;
    },
    onEnd: () => {
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
    },
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
    ],
  }));

  return (
    <PanGestureHandler onGestureEvent={gestureHandler}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </PanGestureHandler>
  );
}
```

<details>
<summary>ì •ë‹µ ë³´ê¸°</summary>

```typescript
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';

function DraggableBox() {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const context = useSharedValue({ startX: 0, startY: 0 });

  const panGesture = Gesture.Pan()
    .onStart(() => {
      context.value = {
        startX: translateX.value,
        startY: translateY.value,
      };
    })
    .onUpdate((event) => {
      translateX.value = context.value.startX + event.translationX;
      translateY.value = context.value.startY + event.translationY;
    })
    .onEnd(() => {
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
    ],
  }));

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </GestureDetector>
  );
}
```

**ì£¼ìš” ë³€ê²½ ì‚¬í•­:**
1. `useAnimatedGestureHandler` â†’ `Gesture.Pan()` ì²´ì´ë‹ API
2. `ctx` ê°ì²´ â†’ `useSharedValue`ë¡œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
3. `PanGestureHandler` â†’ `GestureDetector`
4. `onActive` â†’ `onUpdate` (ì´ë¦„ ë³€ê²½)
</details>

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **ë²„ì „ë³„ ì£¼ìš” ë³€ê²½ì‚¬í•­**: v2 â†’ v3 â†’ v4 ë§ˆì´ê·¸ë ˆì´ì…˜ í¬ì¸íŠ¸
2. **í˜¸í™˜ì„± ë ˆì´ì–´ êµ¬í˜„**: ë²„ì „ ê°„ ì°¨ì´ë¥¼ ì¶”ìƒí™”í•˜ëŠ” ìœ í‹¸ë¦¬í‹°
3. **ìë™í™” ë§ˆì´ê·¸ë ˆì´ì…˜**: AST ê¸°ë°˜ ì½”ë“œ ë³€í™˜ ìŠ¤í¬ë¦½íŠ¸
4. **ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ**: í”¼ì²˜ í”Œë˜ê·¸ì™€ ë˜í¼ ì»´í¬ë„ŒíŠ¸ í™œìš©
5. **ì‹¤ì „ ë§ˆì´ê·¸ë ˆì´ì…˜ íŒ¨í„´**: sometimes-app ì ìš© ì‚¬ë¡€

> **ë‹¤ìŒ ì¥ ì˜ˆê³ **: **Chapter 79: ì‹¤ì „ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…**ì—ì„œëŠ” ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ë°œìƒí•œ ë¬¸ì œë“¤ê³¼ í•´ê²° ê³¼ì •ì„ ì¼€ì´ìŠ¤ ìŠ¤í„°ë””ë¡œ ë‹¤ë£¹ë‹ˆë‹¤.
