# Chapter 79: ì‹¤ì „ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

ì´ ì¥ì—ì„œëŠ” ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ë°œìƒí•œ Reanimated ê´€ë ¨ ë¬¸ì œë“¤ê³¼ ê·¸ í•´ê²° ê³¼ì •ì„ ì¼€ì´ìŠ¤ ìŠ¤í„°ë””ë¡œ ì‚´í´ë´…ë‹ˆë‹¤. ê° ì‚¬ë¡€ì—ì„œ ë¬¸ì œ ë°œê²¬ë¶€í„° ê·¼ë³¸ ì›ì¸ ë¶„ì„, í•´ê²°ê¹Œì§€ì˜ ì „ ê³¼ì •ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- ì‹¤ì œ í”„ë¡œë•ì…˜ ì´ìŠˆ ë¶„ì„ ë°©ë²•ë¡  í•™ìŠµ
- ë³µì¡í•œ ì• ë‹ˆë©”ì´ì…˜ ë²„ê·¸ ë””ë²„ê¹… ê¸°ë²•
- ì„±ëŠ¥ ë¬¸ì œ ì§„ë‹¨ ë° ìµœì í™” ê³¼ì •
- í¬ë˜ì‹œ ë¦¬í¬íŠ¸ ë¶„ì„ê³¼ ëŒ€ì‘

## ğŸ“– íŠ¸ëŸ¬ë¸”ìŠˆíŒ… í”„ë ˆì„ì›Œí¬

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 íŠ¸ëŸ¬ë¸”ìŠˆíŒ… 5ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. ì¦ìƒ íŒŒì•…        â”€â”€â†’  ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆëŠ”ê°€?                â”‚
â”‚  â”‚                                                          â”‚
â”‚  â–¼                                                          â”‚
â”‚  2. ì¬í˜„            â”€â”€â†’  ì–¸ì œ, ì–´ë–»ê²Œ ë°œìƒí•˜ëŠ”ê°€?             â”‚
â”‚  â”‚                                                          â”‚
â”‚  â–¼                                                          â”‚
â”‚  3. ê²©ë¦¬            â”€â”€â†’  ìµœì†Œ ì¬í˜„ ì¼€ì´ìŠ¤ ë§Œë“¤ê¸°              â”‚
â”‚  â”‚                                                          â”‚
â”‚  â–¼                                                          â”‚
â”‚  4. ë¶„ì„            â”€â”€â†’  ê·¼ë³¸ ì›ì¸(Root Cause) ì°¾ê¸°          â”‚
â”‚  â”‚                                                          â”‚
â”‚  â–¼                                                          â”‚
â”‚  5. ìˆ˜ì • & ê²€ì¦     â”€â”€â†’  í•´ê²°ì±… ì ìš© ë° íšŒê·€ í…ŒìŠ¤íŠ¸           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Case Study 1: iOSì—ì„œë§Œ ë°œìƒí•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ ëŠê¹€

### ì¦ìƒ

```
ì‚¬ìš©ì ë¦¬í¬íŠ¸:
- iOSì—ì„œ ì¹´ë“œ ìŠ¤ì™€ì´í”„ ì‹œ ê°„í—ì ìœ¼ë¡œ ë²„ë²…ê±°ë¦¼
- Androidì—ì„œëŠ” ì •ìƒ ë™ì‘
- íŠ¹ì • ê¸°ê¸°(iPhone 12 ì´í•˜)ì—ì„œ ë” ìì£¼ ë°œìƒ
```

### ì¬í˜„

```typescript
// ë¬¸ì œ ì¬í˜„ì„ ìœ„í•œ ì§„ë‹¨ ì½”ë“œ
import { useFrameCallback, useSharedValue } from 'react-native-reanimated';

function DiagnosticOverlay() {
  const frameCount = useSharedValue(0);
  const droppedFrames = useSharedValue(0);
  const lastFrameTime = useSharedValue(0);

  useFrameCallback((frameInfo) => {
    const now = frameInfo.timestamp;
    const delta = now - lastFrameTime.value;

    // 16.67ms (60fps) ê¸°ì¤€ìœ¼ë¡œ í”„ë ˆì„ ë“œë¡­ ê°ì§€
    if (lastFrameTime.value > 0 && delta > 20) {
      droppedFrames.value++;
      console.warn(`Frame dropped: ${delta.toFixed(2)}ms gap`);
    }

    frameCount.value++;
    lastFrameTime.value = now;
  });

  return (
    <View style={styles.diagnosticOverlay}>
      <Text>Frames: {frameCount.value}</Text>
      <Text>Dropped: {droppedFrames.value}</Text>
    </View>
  );
}
```

### ê²©ë¦¬

```typescript
// ìµœì†Œ ì¬í˜„ ì¼€ì´ìŠ¤
function MinimalReproduction() {
  const translateX = useSharedValue(0);
  const shadowOpacity = useSharedValue(0.3);

  // ë¬¸ì œ ì›ì¸: ë³µì¡í•œ shadow ê³„ì‚°
  const cardStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
    // iOSì—ì„œ shadow ì†ì„± ë³€ê²½ì€ ë¹„ìš©ì´ ë†’ìŒ
    shadowOpacity: shadowOpacity.value,
    shadowRadius: 10 + Math.abs(translateX.value) * 0.1,
    shadowOffset: {
      width: translateX.value * 0.1,
      height: 5,
    },
  }));

  const gesture = Gesture.Pan()
    .onUpdate((e) => {
      translateX.value = e.translationX;
      // ë§¤ í”„ë ˆì„ë§ˆë‹¤ shadow ì—…ë°ì´íŠ¸
      shadowOpacity.value = 0.3 + Math.abs(e.translationX) * 0.002;
    });

  return (
    <GestureDetector gesture={gesture}>
      <Animated.View style={[styles.card, cardStyle]} />
    </GestureDetector>
  );
}
```

### ë¶„ì„

```typescript
// ê·¼ë³¸ ì›ì¸ ë¶„ì„
/*
 * ë¬¸ì œ: iOSì—ì„œ shadow ì†ì„± ë³€ê²½ì€ ë ˆì´ì–´ ì¬ë Œë”ë§ í•„ìš”
 *
 * iOS Core Animation íŒŒì´í”„ë¼ì¸:
 * 1. shadow ì†ì„± ë³€ê²½ ê°ì§€
 * 2. ë ˆì´ì–´ì˜ shadowPath ì¬ê³„ì‚°
 * 3. GPUì—ì„œ shadow ë¸”ëŸ¬ ì¬ë Œë”ë§
 * 4. ì»´í¬ì§€íŒ…
 *
 * ë§¤ í”„ë ˆì„(16ms) ë‚´ì— ì™„ë£Œë˜ì§€ ì•Šìœ¼ë©´ í”„ë ˆì„ ë“œë¡­ ë°œìƒ
 */

// ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§
function analyzeShadowPerformance() {
  const measurements: number[] = [];

  return {
    startMeasure: () => {
      'worklet';
      return performance.now();
    },

    endMeasure: (startTime: number, operation: string) => {
      'worklet';
      const duration = performance.now() - startTime;
      measurements.push(duration);

      if (duration > 8) {
        console.warn(`Slow operation: ${operation} took ${duration.toFixed(2)}ms`);
      }
    },

    getStats: () => {
      const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length;
      const max = Math.max(...measurements);
      return { avg, max, count: measurements.length };
    },
  };
}
```

### ìˆ˜ì •

```typescript
// âœ… í•´ê²°ì±… 1: Shadowë¥¼ ì •ì ìœ¼ë¡œ ìœ ì§€í•˜ê³  opacityë§Œ ë³€ê²½
function FixedCardSwipe() {
  const translateX = useSharedValue(0);
  const swipeProgress = useSharedValue(0);

  // Shadowë¥¼ ë³„ë„ ë ˆì´ì–´ë¡œ ë¶„ë¦¬
  const cardStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  // Shadow ë ˆì´ì–´ëŠ” opacityë§Œ ë³€ê²½ (ì €ë¹„ìš©)
  const shadowStyle = useAnimatedStyle(() => ({
    opacity: interpolate(
      Math.abs(swipeProgress.value),
      [0, 100],
      [0.3, 0.6],
      Extrapolate.CLAMP
    ),
  }));

  const gesture = Gesture.Pan()
    .onUpdate((e) => {
      translateX.value = e.translationX;
      swipeProgress.value = e.translationX;
    });

  return (
    <GestureDetector gesture={gesture}>
      <View>
        {/* ê³ ì •ëœ shadow ë ˆì´ì–´ */}
        <Animated.View style={[styles.shadowLayer, shadowStyle]} />

        {/* ì¹´ë“œ ë³¸ì²´ */}
        <Animated.View style={[styles.card, cardStyle]}>
          <CardContent />
        </Animated.View>
      </View>
    </GestureDetector>
  );
}

// âœ… í•´ê²°ì±… 2: shouldRasterize ì‚¬ìš© (iOS)
const styles = StyleSheet.create({
  card: {
    backgroundColor: 'white',
    borderRadius: 16,
    // iOSì—ì„œ shadowê°€ ìˆëŠ” ë·°ë¥¼ ë˜ìŠ¤í„°í™”
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 10,
        // ì¤‘ìš”: ë ˆì´ì–´ë¥¼ ë¹„íŠ¸ë§µìœ¼ë¡œ ìºì‹±
        shouldRasterizeIOS: true,
      },
      android: {
        elevation: 8,
      },
    }),
  },
});

// âœ… í•´ê²°ì±… 3: ìŠ¤ë¡œí‹€ë§ìœ¼ë¡œ shadow ì—…ë°ì´íŠ¸ ë¹ˆë„ ê°ì†Œ
function ThrottledShadowCard() {
  const translateX = useSharedValue(0);
  const shadowOpacity = useSharedValue(0.3);
  const lastShadowUpdate = useSharedValue(0);

  const gesture = Gesture.Pan()
    .onUpdate((e) => {
      translateX.value = e.translationX;

      // 50msë§ˆë‹¤ë§Œ shadow ì—…ë°ì´íŠ¸
      const now = Date.now();
      if (now - lastShadowUpdate.value > 50) {
        shadowOpacity.value = withTiming(
          0.3 + Math.abs(e.translationX) * 0.002,
          { duration: 50 }
        );
        lastShadowUpdate.value = now;
      }
    });

  // ...
}
```

### ê²€ì¦

```typescript
// ìˆ˜ì • í›„ ì„±ëŠ¥ ê²€ì¦
function PerformanceVerification() {
  const [metrics, setMetrics] = useState({
    avgFrameTime: 0,
    droppedFrames: 0,
    testDuration: 0,
  });

  const runTest = () => {
    const startTime = Date.now();
    let frameCount = 0;
    let droppedCount = 0;
    let totalFrameTime = 0;
    let lastFrame = performance.now();

    const measureFrame = () => {
      const now = performance.now();
      const delta = now - lastFrame;

      totalFrameTime += delta;
      frameCount++;

      if (delta > 20) {
        droppedCount++;
      }

      lastFrame = now;

      if (Date.now() - startTime < 5000) {
        requestAnimationFrame(measureFrame);
      } else {
        setMetrics({
          avgFrameTime: totalFrameTime / frameCount,
          droppedFrames: droppedCount,
          testDuration: 5000,
        });
      }
    };

    requestAnimationFrame(measureFrame);
  };

  return (
    <View>
      <Button onPress={runTest} title="Run 5s Test" />
      <Text>Avg Frame Time: {metrics.avgFrameTime.toFixed(2)}ms</Text>
      <Text>Dropped Frames: {metrics.droppedFrames}</Text>
      <Text>Target: 16.67ms, 0 drops</Text>
    </View>
  );
}
```

## ğŸ’» Case Study 2: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¡œ ì¸í•œ í¬ë˜ì‹œ

### ì¦ìƒ

```
Sentry í¬ë˜ì‹œ ë¦¬í¬íŠ¸:
- Error: Reanimated: setValue for SharedValue with id X called after cleanup
- ì•± ì‚¬ìš© ì‹œê°„ì´ ê¸¸ì–´ì§ˆìˆ˜ë¡ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€
- ê²°êµ­ OOM(Out of Memory) í¬ë˜ì‹œ
```

### ì¬í˜„

```typescript
// ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œ íŒ¨í„´
function ProblematicComponent() {
  const translateY = useSharedValue(0);
  const [items, setItems] = useState<Item[]>([]);

  // ë¬¸ì œ 1: ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œì—ë„ ì• ë‹ˆë©”ì´ì…˜ ê³„ì† ì‹¤í–‰
  useEffect(() => {
    const interval = setInterval(() => {
      translateY.value = withSequence(
        withTiming(-10, { duration: 500 }),
        withTiming(0, { duration: 500 })
      );
    }, 2000);

    // cleanup ì—†ìŒ!
    // return () => clearInterval(interval);
  }, []);

  // ë¬¸ì œ 2: í´ë¡œì €ê°€ stale ìƒíƒœ ì°¸ì¡°
  const animatedStyle = useAnimatedStyle(() => {
    // itemsê°€ ì—…ë°ì´íŠ¸ë˜ì–´ë„ ì´ì „ ì°¸ì¡° ìœ ì§€
    const itemCount = items.length; // stale closure

    return {
      transform: [{ translateY: translateY.value }],
      opacity: itemCount > 0 ? 1 : 0.5,
    };
  });

  return <Animated.View style={animatedStyle} />;
}
```

### ê²©ë¦¬

```typescript
// ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€ ìœ í‹¸ë¦¬í‹°
class MemoryLeakDetector {
  private snapshots: { timestamp: number; size: number }[] = [];
  private componentRefs = new WeakMap<object, string>();

  takeSnapshot(label: string) {
    // React Nativeì—ì„œëŠ” ì§ì ‘ì ì¸ í™ í¬ê¸° ì ‘ê·¼ ë¶ˆê°€
    // ëŒ€ì‹  SharedValue ì¸ìŠ¤í„´ìŠ¤ ìˆ˜ ì¶”ì 
    const snapshot = {
      timestamp: Date.now(),
      size: this.estimateMemoryUsage(),
      label,
    };

    this.snapshots.push(snapshot);
    console.log(`[Memory] ${label}: ~${snapshot.size} estimated units`);

    return snapshot;
  }

  private estimateMemoryUsage(): number {
    // ê¸€ë¡œë²Œ SharedValue ë ˆì§€ìŠ¤íŠ¸ë¦¬ í¬ê¸° ì¶”ì •
    // (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë°©ë²• í•„ìš”)
    return Math.random() * 1000; // placeholder
  }

  analyzeGrowth(): { growing: boolean; rate: number } {
    if (this.snapshots.length < 2) {
      return { growing: false, rate: 0 };
    }

    const recent = this.snapshots.slice(-10);
    const first = recent[0];
    const last = recent[recent.length - 1];

    const timeDelta = (last.timestamp - first.timestamp) / 1000; // seconds
    const sizeDelta = last.size - first.size;
    const rate = sizeDelta / timeDelta;

    return {
      growing: rate > 10, // 10 units/second ì´ìƒì´ë©´ ëˆ„ìˆ˜ ì˜ì‹¬
      rate,
    };
  }
}

// ì»´í¬ë„ŒíŠ¸ ë¼ì´í”„ì‚¬ì´í´ ì¶”ì 
function useComponentLifecycleTracker(componentName: string) {
  const mountTime = useRef(Date.now());
  const animationCount = useRef(0);

  useEffect(() => {
    console.log(`[Lifecycle] ${componentName} mounted`);

    return () => {
      const lifetime = Date.now() - mountTime.current;
      console.log(
        `[Lifecycle] ${componentName} unmounted after ${lifetime}ms, ` +
        `${animationCount.current} animations started`
      );
    };
  }, [componentName]);

  const trackAnimation = () => {
    animationCount.current++;
  };

  return { trackAnimation };
}
```

### ë¶„ì„

```typescript
// ê·¼ë³¸ ì›ì¸ ë¶„ì„ ë„êµ¬
function analyzeAnimationLifecycle() {
  const activeAnimations = new Map<number, {
    startTime: number;
    type: string;
    stackTrace: string;
  }>();

  let nextId = 0;

  return {
    trackStart: (type: string) => {
      const id = nextId++;
      activeAnimations.set(id, {
        startTime: Date.now(),
        type,
        stackTrace: new Error().stack || '',
      });
      return id;
    },

    trackEnd: (id: number) => {
      activeAnimations.delete(id);
    },

    getLeaks: (thresholdMs: number = 30000) => {
      const now = Date.now();
      const leaks: Array<{ id: number; info: any }> = [];

      activeAnimations.forEach((info, id) => {
        if (now - info.startTime > thresholdMs) {
          leaks.push({ id, info });
        }
      });

      return leaks;
    },

    printReport: () => {
      console.log('=== Animation Lifecycle Report ===');
      console.log(`Active animations: ${activeAnimations.size}`);

      const leaks = analyzeAnimationLifecycle().getLeaks();
      if (leaks.length > 0) {
        console.log(`Potential leaks: ${leaks.length}`);
        leaks.forEach(({ id, info }) => {
          console.log(`  ID ${id}: ${info.type} started ${Date.now() - info.startTime}ms ago`);
          console.log(`    Stack: ${info.stackTrace.split('\n')[2]}`);
        });
      }
    },
  };
}
```

### ìˆ˜ì •

```typescript
// âœ… ìˆ˜ì •ëœ ì½”ë“œ
function FixedComponent() {
  const translateY = useSharedValue(0);
  const [items, setItems] = useState<Item[]>([]);
  const isMounted = useSharedValue(true);

  // ìˆ˜ì • 1: ì ì ˆí•œ cleanup
  useEffect(() => {
    const interval = setInterval(() => {
      // ë§ˆìš´íŠ¸ ìƒíƒœ í™•ì¸
      if (!isMounted.value) return;

      translateY.value = withSequence(
        withTiming(-10, { duration: 500 }),
        withTiming(0, { duration: 500 })
      );
    }, 2000);

    return () => {
      clearInterval(interval);
      isMounted.value = false;
      cancelAnimation(translateY);
    };
  }, []);

  // ìˆ˜ì • 2: useDerivedValueë¡œ ë°˜ì‘ì  ê°’ ì²˜ë¦¬
  const itemCount = useDerivedValue(() => items.length);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
      opacity: itemCount.value > 0 ? 1 : 0.5,
    };
  });

  return <Animated.View style={animatedStyle} />;
}

// ì•ˆì „í•œ ì• ë‹ˆë©”ì´ì…˜ í›…
function useSafeAnimation<T extends number>(initialValue: T) {
  const value = useSharedValue(initialValue);
  const isCleaned = useSharedValue(false);

  useEffect(() => {
    return () => {
      isCleaned.value = true;
      cancelAnimation(value);
    };
  }, []);

  const safeAnimate = (animation: T, callback?: (finished: boolean) => void) => {
    'worklet';

    if (isCleaned.value) {
      console.warn('Animation attempted after cleanup');
      return;
    }

    if (typeof animation === 'number') {
      value.value = withTiming(animation, undefined, (finished) => {
        if (!isCleaned.value && callback) {
          callback(finished ?? false);
        }
      });
    } else {
      value.value = animation;
    }
  };

  return { value, safeAnimate, isCleaned };
}

// ì‚¬ìš© ì˜ˆì‹œ
function SafeAnimationComponent() {
  const { value: opacity, safeAnimate } = useSafeAnimation(0);

  const handlePress = () => {
    safeAnimate(1, (finished) => {
      if (finished) {
        console.log('Animation completed safely');
      }
    });
  };

  return (
    <Animated.View style={useAnimatedStyle(() => ({ opacity: opacity.value }))}>
      <Button onPress={handlePress} title="Animate" />
    </Animated.View>
  );
}
```

## ğŸ’» Case Study 3: ë¦¬ìŠ¤íŠ¸ ìŠ¤í¬ë¡¤ ì„±ëŠ¥ ì €í•˜

### ì¦ìƒ

```
ì‚¬ìš©ì ë¦¬í¬íŠ¸:
- ì±„íŒ… ëª©ë¡ì—ì„œ ìŠ¤í¬ë¡¤í•  ë•Œ ë²„ë²…ê±°ë¦¼
- íŠ¹íˆ ì´ë¯¸ì§€ê°€ ë§ì€ ëŒ€í™”ì—ì„œ ì‹¬í•¨
- ë©”ì‹œì§€ê°€ ë§ì•„ì§ˆìˆ˜ë¡ ì•…í™”
```

### ì¬í˜„ ë° ë¶„ì„

```typescript
// ë¬¸ì œê°€ ìˆëŠ” ì±„íŒ… ë¦¬ìŠ¤íŠ¸
function ProblematicChatList() {
  const scrollY = useSharedValue(0);

  const scrollHandler = useAnimatedScrollHandler({
    onScroll: (event) => {
      scrollY.value = event.contentOffset.y;
    },
  });

  return (
    <Animated.FlatList
      data={messages}
      onScroll={scrollHandler}
      scrollEventThrottle={1} // ë¬¸ì œ: ëª¨ë“  ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
      renderItem={({ item, index }) => (
        // ë¬¸ì œ: ê° ì•„ì´í…œì— ë³µì¡í•œ ì• ë‹ˆë©”ì´ì…˜
        <AnimatedMessageItem
          message={item}
          scrollY={scrollY}
          index={index}
        />
      )}
    />
  );
}

// ë¬¸ì œê°€ ìˆëŠ” ë©”ì‹œì§€ ì•„ì´í…œ
function AnimatedMessageItem({
  message,
  scrollY,
  index,
}: {
  message: Message;
  scrollY: SharedValue<number>;
  index: number;
}) {
  // ë¬¸ì œ: ëª¨ë“  ì•„ì´í…œì´ scrollYì— ë°˜ì‘
  const animatedStyle = useAnimatedStyle(() => {
    const inputRange = [
      index * 80 - 200,
      index * 80,
      index * 80 + 200,
    ];

    // ë³µì¡í•œ ê³„ì‚°ì´ ëª¨ë“  ì•„ì´í…œì—ì„œ ë§¤ í”„ë ˆì„ ì‹¤í–‰
    const scale = interpolate(
      scrollY.value,
      inputRange,
      [0.8, 1, 0.8],
      Extrapolate.CLAMP
    );

    const opacity = interpolate(
      scrollY.value,
      inputRange,
      [0.5, 1, 0.5],
      Extrapolate.CLAMP
    );

    const translateX = interpolate(
      scrollY.value,
      inputRange,
      [-20, 0, 20],
      Extrapolate.CLAMP
    );

    return {
      transform: [{ scale }, { translateX }],
      opacity,
    };
  });

  return (
    <Animated.View style={animatedStyle}>
      <MessageContent message={message} />
    </Animated.View>
  );
}
```

### ìˆ˜ì •

```typescript
// âœ… ìµœì í™”ëœ ì±„íŒ… ë¦¬ìŠ¤íŠ¸
import { FlashList } from '@shopify/flash-list';

function OptimizedChatList() {
  const scrollY = useSharedValue(0);

  // ìˆ˜ì • 1: ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ ìŠ¤ë¡œí‹€ë§
  const scrollHandler = useAnimatedScrollHandler({
    onScroll: (event) => {
      scrollY.value = event.contentOffset.y;
    },
  });

  // ìˆ˜ì • 2: ë·°í¬íŠ¸ ì •ë³´ ì¶”ì 
  const viewportInfo = useSharedValue({
    firstVisible: 0,
    lastVisible: 10,
  });

  const onViewableItemsChanged = useCallback(({ viewableItems }) => {
    if (viewableItems.length > 0) {
      runOnUI(() => {
        viewportInfo.value = {
          firstVisible: viewableItems[0].index,
          lastVisible: viewableItems[viewableItems.length - 1].index,
        };
      })();
    }
  }, []);

  // ìˆ˜ì • 3: FlashList ì‚¬ìš©ìœ¼ë¡œ ë Œë”ë§ ìµœì í™”
  return (
    <Animated.FlatList
      as={FlashList}
      data={messages}
      onScroll={scrollHandler}
      scrollEventThrottle={16} // 60fpsë¡œ ì œí•œ
      onViewableItemsChanged={onViewableItemsChanged}
      viewabilityConfig={{ itemVisiblePercentThreshold: 50 }}
      estimatedItemSize={80}
      renderItem={({ item, index }) => (
        <OptimizedMessageItem
          message={item}
          index={index}
          viewportInfo={viewportInfo}
        />
      )}
    />
  );
}

// âœ… ìµœì í™”ëœ ë©”ì‹œì§€ ì•„ì´í…œ
const OptimizedMessageItem = React.memo(function OptimizedMessageItem({
  message,
  index,
  viewportInfo,
}: {
  message: Message;
  index: number;
  viewportInfo: SharedValue<{ firstVisible: number; lastVisible: number }>;
}) {
  // ìˆ˜ì • 4: ë·°í¬íŠ¸ ë‚´ ì•„ì´í…œë§Œ ì• ë‹ˆë©”ì´ì…˜
  const animatedStyle = useAnimatedStyle(() => {
    const { firstVisible, lastVisible } = viewportInfo.value;
    const isVisible = index >= firstVisible - 2 && index <= lastVisible + 2;

    if (!isVisible) {
      // ë·°í¬íŠ¸ ë°–ì€ ê¸°ë³¸ ìŠ¤íƒ€ì¼
      return {
        transform: [{ scale: 1 }, { translateX: 0 }],
        opacity: 1,
      };
    }

    // ìˆ˜ì • 5: ë‹¨ìˆœí™”ëœ ì• ë‹ˆë©”ì´ì…˜ (ì…ì¥ íš¨ê³¼ë§Œ)
    const distanceFromCenter = Math.abs(
      index - (firstVisible + lastVisible) / 2
    );

    const scale = interpolate(
      distanceFromCenter,
      [0, 5],
      [1, 0.95],
      Extrapolate.CLAMP
    );

    return {
      transform: [{ scale }],
      opacity: 1,
    };
  });

  return (
    <Animated.View style={animatedStyle}>
      <MessageContent message={message} />
    </Animated.View>
  );
});

// ìˆ˜ì • 6: ì´ë¯¸ì§€ ìµœì í™”
function MessageContent({ message }: { message: Message }) {
  const [isImageLoaded, setIsImageLoaded] = useState(false);

  if (message.type === 'image') {
    return (
      <View style={styles.imageContainer}>
        {/* ì €í•´ìƒë„ í”Œë ˆì´ìŠ¤í™€ë” */}
        {!isImageLoaded && (
          <Image
            source={{ uri: message.thumbnailUrl }}
            style={styles.imagePlaceholder}
            blurRadius={10}
          />
        )}

        {/* ì‹¤ì œ ì´ë¯¸ì§€ (ì§€ì—° ë¡œë”©) */}
        <Image
          source={{ uri: message.imageUrl }}
          style={[styles.image, !isImageLoaded && styles.hidden]}
          onLoad={() => setIsImageLoaded(true)}
        />
      </View>
    );
  }

  return <Text style={styles.messageText}>{message.text}</Text>;
}
```

## ğŸ’» Case Study 4: ì œìŠ¤ì²˜ ì¶©ëŒë¡œ ì¸í•œ UX ë¬¸ì œ

### ì¦ìƒ

```
ì‚¬ìš©ì ë¦¬í¬íŠ¸:
- í”„ë¡œí•„ ì¹´ë“œë¥¼ ìŠ¤ì™€ì´í”„í•˜ë ¤ëŠ”ë° ìŠ¤í¬ë¡¤ë¨
- ì¢Œìš° ìŠ¤ì™€ì´í”„ì™€ ìƒí•˜ ìŠ¤í¬ë¡¤ì´ ì¶©ëŒ
- ì˜ë„í•œ ë™ì‘ê³¼ ë‹¤ë¥¸ ê²°ê³¼
```

### ë¶„ì„ ë° ìˆ˜ì •

```typescript
// ë¬¸ì œ: ì œìŠ¤ì²˜ ì˜ë„ êµ¬ë¶„ ì‹¤íŒ¨
function ProblematicSwipeableList() {
  const scrollViewRef = useAnimatedRef<Animated.ScrollView>();

  return (
    <Animated.ScrollView ref={scrollViewRef}>
      {items.map((item) => (
        // ë¬¸ì œ: Pan ì œìŠ¤ì²˜ê°€ ScrollViewì™€ ì¶©ëŒ
        <SwipeableItem key={item.id} item={item} />
      ))}
    </Animated.ScrollView>
  );
}

// âœ… ìˆ˜ì •: ì œìŠ¤ì²˜ ë°©í–¥ ëª…í™•íˆ ë¶„ë¦¬
function FixedSwipeableList() {
  const scrollViewRef = useAnimatedRef<Animated.ScrollView>();

  // ìŠ¤í¬ë¡¤ ì œìŠ¤ì²˜ (ë„¤ì´í‹°ë¸Œ)
  const nativeGesture = Gesture.Native();

  return (
    <GestureDetector gesture={nativeGesture}>
      <Animated.ScrollView ref={scrollViewRef}>
        {items.map((item) => (
          <GestureAwareSwipeableItem
            key={item.id}
            item={item}
            scrollViewGesture={nativeGesture}
          />
        ))}
      </Animated.ScrollView>
    </GestureDetector>
  );
}

function GestureAwareSwipeableItem({
  item,
  scrollViewGesture,
}: {
  item: Item;
  scrollViewGesture: GestureType;
}) {
  const translateX = useSharedValue(0);
  const isHorizontalSwipe = useSharedValue(false);

  // ìˆ˜í‰ ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜
  const panGesture = Gesture.Pan()
    // í•µì‹¬: ìˆ˜í‰ 20px ì´ë™ í›„ì—ë§Œ í™œì„±í™”
    .activeOffsetX([-20, 20])
    // ìˆ˜ì§ 10px ì´ë™ ì‹œ ì‹¤íŒ¨ (ìŠ¤í¬ë¡¤ë¡œ ì „í™˜)
    .failOffsetY([-10, 10])
    .onStart(() => {
      isHorizontalSwipe.value = true;
    })
    .onUpdate((event) => {
      if (isHorizontalSwipe.value) {
        translateX.value = event.translationX;
      }
    })
    .onEnd(() => {
      translateX.value = withSpring(0);
      isHorizontalSwipe.value = false;
    })
    // ìŠ¤í¬ë¡¤ë·° ì œìŠ¤ì²˜ê°€ ì´ ì œìŠ¤ì²˜ ì‹¤íŒ¨ ì‹œ ì‹œì‘í•˜ë„ë¡
    .simultaneousWithExternalGesture(scrollViewGesture);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={animatedStyle}>
        <ItemContent item={item} />
      </Animated.View>
    </GestureDetector>
  );
}

// ì œìŠ¤ì²˜ ë””ë²„ê±°
function GestureDebugger() {
  const [gestureLog, setGestureLog] = useState<string[]>([]);

  const logGesture = (type: string, info: string) => {
    setGestureLog((prev) => [
      ...prev.slice(-20),
      `${Date.now()}: ${type} - ${info}`,
    ]);
  };

  return (
    <View style={styles.debugPanel}>
      <Text style={styles.debugTitle}>Gesture Log</Text>
      <ScrollView style={styles.debugLog}>
        {gestureLog.map((log, i) => (
          <Text key={i} style={styles.debugLogItem}>{log}</Text>
        ))}
      </ScrollView>
    </View>
  );
}
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### ì¢…í•© ë””ë²„ê¹… ëŒ€ì‹œë³´ë“œ

```typescript
// src/features/debug/ui/animation-debug-dashboard.tsx

import { useSharedValue, useAnimatedStyle, useFrameCallback } from 'react-native-reanimated';

interface DebugMetrics {
  fps: number;
  memoryUsage: number;
  activeAnimations: number;
  gestureState: string;
}

export function AnimationDebugDashboard() {
  const [isExpanded, setIsExpanded] = useState(false);
  const [metrics, setMetrics] = useState<DebugMetrics>({
    fps: 60,
    memoryUsage: 0,
    activeAnimations: 0,
    gestureState: 'idle',
  });

  // FPS ëª¨ë‹ˆí„°ë§
  const frameCount = useSharedValue(0);
  const lastSecond = useSharedValue(Date.now());

  useFrameCallback(() => {
    frameCount.value++;

    const now = Date.now();
    if (now - lastSecond.value >= 1000) {
      const fps = frameCount.value;
      runOnJS(setMetrics)((prev) => ({ ...prev, fps }));

      frameCount.value = 0;
      lastSecond.value = now;
    }
  });

  // íŒ¨ë„ í† ê¸€ ì• ë‹ˆë©”ì´ì…˜
  const panelHeight = useSharedValue(40);

  const toggleExpand = () => {
    setIsExpanded(!isExpanded);
    panelHeight.value = withSpring(isExpanded ? 40 : 200);
  };

  const panelStyle = useAnimatedStyle(() => ({
    height: panelHeight.value,
  }));

  if (!__DEV__) return null;

  return (
    <Animated.View style={[styles.debugPanel, panelStyle]}>
      <Pressable onPress={toggleExpand} style={styles.header}>
        <Text style={styles.title}>ğŸ”§ Animation Debug</Text>
        <View style={[styles.fpsIndicator, getFpsColor(metrics.fps)]}>
          <Text style={styles.fpsText}>{metrics.fps} FPS</Text>
        </View>
      </Pressable>

      {isExpanded && (
        <ScrollView style={styles.content}>
          <MetricRow label="Active Animations" value={metrics.activeAnimations} />
          <MetricRow label="Memory" value={`${metrics.memoryUsage}MB`} />
          <MetricRow label="Gesture State" value={metrics.gestureState} />

          <View style={styles.actions}>
            <Button title="Force GC" onPress={() => global.gc?.()} />
            <Button title="Clear Cache" onPress={clearAnimationCache} />
            <Button title="Export Logs" onPress={exportDebugLogs} />
          </View>
        </ScrollView>
      )}
    </Animated.View>
  );
}

function MetricRow({ label, value }: { label: string; value: string | number }) {
  return (
    <View style={styles.metricRow}>
      <Text style={styles.metricLabel}>{label}</Text>
      <Text style={styles.metricValue}>{value}</Text>
    </View>
  );
}

function getFpsColor(fps: number): ViewStyle {
  if (fps >= 55) return { backgroundColor: '#4CAF50' };
  if (fps >= 45) return { backgroundColor: '#FFC107' };
  return { backgroundColor: '#F44336' };
}

async function exportDebugLogs() {
  // ë””ë²„ê·¸ ë¡œê·¸ ìˆ˜ì§‘ ë° ë‚´ë³´ë‚´ê¸°
  const logs = {
    timestamp: new Date().toISOString(),
    device: Platform.OS,
    version: Platform.Version,
    reanimatedVersion: require('react-native-reanimated/package.json').version,
    // ... ì¶”ê°€ ì •ë³´
  };

  await Share.share({
    message: JSON.stringify(logs, null, 2),
    title: 'Animation Debug Logs',
  });
}

const styles = StyleSheet.create({
  debugPanel: {
    position: 'absolute',
    bottom: 100,
    left: 10,
    right: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    borderRadius: 12,
    overflow: 'hidden',
    zIndex: 9999,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 10,
  },
  title: {
    color: 'white',
    fontWeight: 'bold',
  },
  fpsIndicator: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  fpsText: {
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
  },
  content: {
    padding: 10,
  },
  metricRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 4,
  },
  metricLabel: {
    color: '#999',
  },
  metricValue: {
    color: 'white',
    fontWeight: '500',
  },
  actions: {
    flexDirection: 'row',
    gap: 8,
    marginTop: 10,
  },
});
```

## âš ï¸ ì‹¤ì „ íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ì²´í¬ë¦¬ìŠ¤íŠ¸

```typescript
// src/shared/utils/animation-troubleshooting-checklist.ts

export const TROUBLESHOOTING_CHECKLIST = {
  performance: [
    '[ ] useAnimatedStyle ë‚´ë¶€ì—ì„œ ë¶ˆí•„ìš”í•œ ê³„ì‚° ì—†ëŠ”ì§€ í™•ì¸',
    '[ ] ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œì—ì„œ scrollY ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸',
    '[ ] shadow ì†ì„±ì´ ë§¤ í”„ë ˆì„ ë³€ê²½ë˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸',
    '[ ] Platform.selectë¡œ iOS/Android ìµœì í™” ì ìš©í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] FlashList ë˜ëŠ” ìµœì í™”ëœ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©í•˜ëŠ”ì§€ í™•ì¸',
  ],

  memoryLeaks: [
    '[ ] useEffect cleanupì—ì„œ cancelAnimation í˜¸ì¶œí•˜ëŠ”ì§€ í™•ì¸',
    '[ ] setInterval/setTimeout ì •ë¦¬í•˜ëŠ”ì§€ í™•ì¸',
    '[ ] ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ í›„ SharedValue ì ‘ê·¼í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸',
    '[ ] í´ë¡œì €ê°€ stale ìƒíƒœë¥¼ ì°¸ì¡°í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸',
  ],

  gestureConflicts: [
    '[ ] activeOffsetX/Y ì„¤ì •í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] failOffsetX/Y ì„¤ì •í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] simultaneousWithExternalGesture ì ìš©í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] ì œìŠ¤ì²˜ ìš°ì„ ìˆœìœ„ ëª…í™•í•œì§€ í™•ì¸',
  ],

  crashes: [
    '[ ] worklet í•¨ìˆ˜ì— "worklet" ë””ë ‰í‹°ë¸Œ ìˆëŠ”ì§€ í™•ì¸',
    '[ ] runOnJSë¡œ JS í•¨ìˆ˜ í˜¸ì¶œí•˜ëŠ”ì§€ í™•ì¸',
    '[ ] SharedValue íƒ€ì…ì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸',
    '[ ] Babel ì„¤ì •ì— reanimated í”ŒëŸ¬ê·¸ì¸ ìˆëŠ”ì§€ í™•ì¸',
  ],

  platformSpecific: [
    '[ ] iOS shadowì™€ Android elevation ë¶„ë¦¬í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] ì‹œìŠ¤í…œ ì œìŠ¤ì²˜(back swipe) ê³ ë ¤í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] í‚¤ë³´ë“œ ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬í–ˆëŠ”ì§€ í™•ì¸',
    '[ ] Safe Area ê³ ë ¤í–ˆëŠ”ì§€ í™•ì¸',
  ],
};

export function runTroubleshootingCheck(): {
  category: string;
  passed: boolean;
  issues: string[];
}[] {
  // ìë™í™”ëœ ì²´í¬ ì‹¤í–‰
  const results: ReturnType<typeof runTroubleshootingCheck> = [];

  // ì„±ëŠ¥ ì²´í¬
  const performanceIssues: string[] = [];
  // ... ìë™í™”ëœ ê²€ì‚¬ ë¡œì§

  results.push({
    category: 'performance',
    passed: performanceIssues.length === 0,
    issues: performanceIssues,
  });

  return results;
}
```

## ğŸ’¡ íŒ

1. **ì¬í˜„ ë¨¼ì €**: ë¬¸ì œë¥¼ ì•ˆì •ì ìœ¼ë¡œ ì¬í˜„í•  ìˆ˜ ìˆì–´ì•¼ ë””ë²„ê¹… ê°€ëŠ¥
2. **ê²©ë¦¬í•˜ê¸°**: ìµœì†Œ ì¬í˜„ ì¼€ì´ìŠ¤ë¥¼ ë§Œë“¤ì–´ ë³€ìˆ˜ ì¤„ì´ê¸°
3. **ì¸¡ì •í•˜ê¸°**: ì¶”ì¸¡í•˜ì§€ ë§ê³  ì„±ëŠ¥ ë°ì´í„°ë¡œ íŒë‹¨
4. **ì ì§„ì  ìˆ˜ì •**: í•œ ë²ˆì— í•˜ë‚˜ì”© ë³€ê²½í•˜ê³  ê²€ì¦
5. **ë¬¸ì„œí™”**: í•´ê²° ê³¼ì •ì„ ê¸°ë¡í•˜ì—¬ ì¬ë°œ ë°©ì§€

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **íŠ¸ëŸ¬ë¸”ìŠˆíŒ… í”„ë ˆì„ì›Œí¬**: ì²´ê³„ì ì¸ 5ë‹¨ê³„ ë¬¸ì œ í•´ê²° í”„ë¡œì„¸ìŠ¤
2. **iOS ì„±ëŠ¥ ë¬¸ì œ**: shadow ê´€ë ¨ ìµœì í™” ê¸°ë²•
3. **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ëŒ€ì‘**: cleanupê³¼ lifecycle ê´€ë¦¬
4. **ë¦¬ìŠ¤íŠ¸ ìµœì í™”**: ë·°í¬íŠ¸ ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜ ì œí•œ
5. **ì œìŠ¤ì²˜ ì¶©ëŒ í•´ê²°**: offset ì„¤ì •ê³¼ ì œìŠ¤ì²˜ ê´€ê³„ ì„¤ì •
6. **ë””ë²„ê¹… ë„êµ¬**: ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

> **Part 10 ì™„ë£Œ!**: íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œë¥¼ ëª¨ë‘ í•™ìŠµí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒì€ **ë¶€ë¡**ì—ì„œ API ë ˆí¼ëŸ°ìŠ¤, ì„±ëŠ¥ ì²´í¬ë¦¬ìŠ¤íŠ¸, ìš©ì–´ì§‘ ë“± ì‹¤ì „ í™œìš©ì— ë„ì›€ë˜ëŠ” ìë£Œë¥¼ ì œê³µí•©ë‹ˆë‹¤.
