# Chapter 77: íƒ€ì´ë° ì´ìŠˆ

ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë°ì€ ì‚¬ìš©ì ê²½í—˜ì˜ í’ˆì§ˆì„ ê²°ì •í•˜ëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤. ì´ ì¥ì—ì„œëŠ” ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë° ë™ê¸°í™” ë¬¸ì œë¥¼ ì§„ë‹¨í•˜ê³  í•´ê²°í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë° ë™ê¸°í™” ë¬¸ì œ ì´í•´
- ì‹œí€€ìŠ¤ì™€ ë³‘ë ¬ ì• ë‹ˆë©”ì´ì…˜ ì¡°ìœ¨
- ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€ ê¸°ë²•
- ì§€ì—° ì²˜ë¦¬ì™€ ë””ë°”ìš´ì‹±

## ğŸ“– íƒ€ì´ë° ë¬¸ì œì˜ ì›ì¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  íƒ€ì´ë° ì´ìŠˆ ë¶„ë¥˜                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. ë™ê¸°í™” ë¬¸ì œ          2. ë ˆì´ìŠ¤ ì»¨ë””ì…˜                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ Animation A â”‚        â”‚ Animation A â”‚â”€â”€â”                 â”‚
â”‚  â”‚    â”€â”€â”€â”€â”€â”€â”€  â”‚        â”‚    â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚ ë™ì‹œ ì™„ë£Œ?      â”‚
â”‚  â”‚ Animation B â”‚        â”‚ Animation B â”‚â”€â”€â”˜                 â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€      â”‚ ë¶ˆì¼ì¹˜  â”‚      â”€â”€â”€â”€â”€ â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                             â”‚
â”‚  3. ìˆœì„œ ë¬¸ì œ            4. ì¤‘ë‹¨ ë¬¸ì œ                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ 1 â†’ 2 â†’ 3   â”‚        â”‚ â”€â”€X         â”‚ ê°‘ì‘ìŠ¤ëŸ° ì¤‘ë‹¨       â”‚
â”‚  â”‚ 1 â†’ 3 â†’ 2   â”‚ ì—­ì „!  â”‚   â””â”€â”€â†’ ì í”„ â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 1: ì‹œí€€ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™”

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  runOnJS,
} from 'react-native-reanimated';

// âŒ ë¬¸ì œ: ì½œë°± íƒ€ì´ë°ì´ ë§ì§€ ì•ŠìŒ
function BrokenSequence() {
  const opacity = useSharedValue(0);
  const scale = useSharedValue(0.5);

  const startAnimation = () => {
    // ë‘ ì• ë‹ˆë©”ì´ì…˜ì´ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰
    opacity.value = withTiming(1, { duration: 300 });
    scale.value = withTiming(1, { duration: 500 });

    // 300ms í›„ì— ì‹¤í–‰ë˜ì§€ë§Œ scaleì€ ì•„ì§ ì§„í–‰ ì¤‘!
    setTimeout(() => {
      console.log('Animation complete?'); // ì‹¤ì œë¡œëŠ” ë¯¸ì™„ë£Œ
    }, 300);
  };

  return null;
}

// âœ… í•´ê²°: í†µí•© ì‹œí€€ìŠ¤ ê´€ë¦¬
function useSequenceAnimation() {
  const progress = useSharedValue(0);
  const isAnimating = useSharedValue(false);
  const currentStep = useSharedValue(0);

  const steps = useSharedValue<AnimationStep[]>([]);

  interface AnimationStep {
    target: number;
    duration: number;
    delay?: number;
    onStart?: () => void;
    onComplete?: () => void;
  }

  const runSequence = (
    animationSteps: AnimationStep[],
    onSequenceComplete?: () => void
  ) => {
    'worklet';

    if (isAnimating.value) {
      console.warn('Animation already in progress');
      return;
    }

    isAnimating.value = true;
    currentStep.value = 0;
    steps.value = animationSteps;

    const executeStep = (stepIndex: number) => {
      'worklet';

      if (stepIndex >= animationSteps.length) {
        isAnimating.value = false;
        if (onSequenceComplete) {
          runOnJS(onSequenceComplete)();
        }
        return;
      }

      const step = animationSteps[stepIndex];

      if (step.onStart) {
        runOnJS(step.onStart)();
      }

      const delay = step.delay || 0;

      progress.value = withDelay(
        delay,
        withTiming(step.target, { duration: step.duration }, (finished) => {
          if (finished) {
            currentStep.value = stepIndex + 1;

            if (step.onComplete) {
              runOnJS(step.onComplete)();
            }

            executeStep(stepIndex + 1);
          }
        })
      );
    };

    executeStep(0);
  };

  const cancelSequence = () => {
    'worklet';
    isAnimating.value = false;
    cancelAnimation(progress);
  };

  return {
    progress,
    currentStep,
    isAnimating,
    runSequence,
    cancelSequence,
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
function SequencedEntrance() {
  const { progress, currentStep, runSequence } = useSequenceAnimation();

  const animatedStyle = useAnimatedStyle(() => {
    const opacity = interpolate(progress.value, [0, 0.3], [0, 1], Extrapolate.CLAMP);
    const translateY = interpolate(progress.value, [0, 0.3, 0.6], [50, 0, 0]);
    const scale = interpolate(progress.value, [0.3, 0.6, 1], [0.8, 1, 1], Extrapolate.CLAMP);

    return {
      opacity,
      transform: [{ translateY }, { scale }],
    };
  });

  const startEntrance = () => {
    runSequence([
      { target: 0.3, duration: 200, onStart: () => console.log('Fade in') },
      { target: 0.6, duration: 300, onStart: () => console.log('Scale up') },
      { target: 1.0, duration: 200, onStart: () => console.log('Settle') },
    ], () => {
      console.log('Entrance complete!');
    });
  };

  return (
    <Animated.View style={[styles.box, animatedStyle]}>
      <Text>Step: {currentStep.value}</Text>
    </Animated.View>
  );
}
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 2: ë³‘ë ¬ ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™”

```typescript
import { useCallback, useRef } from 'react';

interface ParallelAnimationConfig {
  animations: {
    value: Animated.SharedValue<number>;
    target: number;
    duration: number;
    easing?: (t: number) => number;
  }[];
  onAllComplete?: () => void;
  onAnyComplete?: (index: number) => void;
}

function useParallelAnimation() {
  const completedCount = useSharedValue(0);
  const totalAnimations = useSharedValue(0);
  const isRunning = useSharedValue(false);

  const runParallel = (config: ParallelAnimationConfig) => {
    'worklet';

    const { animations, onAllComplete, onAnyComplete } = config;

    completedCount.value = 0;
    totalAnimations.value = animations.length;
    isRunning.value = true;

    animations.forEach((anim, index) => {
      anim.value.value = withTiming(
        anim.target,
        {
          duration: anim.duration,
          easing: anim.easing || Easing.out(Easing.cubic),
        },
        (finished) => {
          if (finished) {
            completedCount.value += 1;

            if (onAnyComplete) {
              runOnJS(onAnyComplete)(index);
            }

            if (completedCount.value === totalAnimations.value) {
              isRunning.value = false;
              if (onAllComplete) {
                runOnJS(onAllComplete)();
              }
            }
          }
        }
      );
    });
  };

  // ê°€ì¥ ê¸´ ì• ë‹ˆë©”ì´ì…˜ ê¸°ì¤€ìœ¼ë¡œ ë™ê¸°í™”
  const runParallelSynced = (config: ParallelAnimationConfig) => {
    'worklet';

    const { animations, onAllComplete } = config;
    const maxDuration = Math.max(...animations.map(a => a.duration));

    isRunning.value = true;

    animations.forEach((anim) => {
      // ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ì„ ê°™ì€ durationìœ¼ë¡œ ì •ê·œí™”
      anim.value.value = withTiming(
        anim.target,
        {
          duration: maxDuration,
          easing: anim.easing || Easing.out(Easing.cubic),
        }
      );
    });

    // ë‹¨ì¼ ì™„ë£Œ ì½œë°±
    const primaryAnim = animations[0];
    primaryAnim.value.value = withTiming(
      primaryAnim.target,
      { duration: maxDuration },
      (finished) => {
        if (finished) {
          isRunning.value = false;
          if (onAllComplete) {
            runOnJS(onAllComplete)();
          }
        }
      }
    );
  };

  return {
    completedCount,
    totalAnimations,
    isRunning,
    runParallel,
    runParallelSynced,
  };
}

// ì‹¤ì „ ì˜ˆì‹œ: ì¹´ë“œ í”Œë¦½ ì• ë‹ˆë©”ì´ì…˜
function CardFlipAnimation() {
  const rotateY = useSharedValue(0);
  const scale = useSharedValue(1);
  const shadowOpacity = useSharedValue(0.2);

  const { runParallel, isRunning } = useParallelAnimation();

  const flipCard = () => {
    if (isRunning.value) return;

    runParallel({
      animations: [
        { value: rotateY, target: 180, duration: 600 },
        { value: scale, target: 1.1, duration: 300 },
        { value: shadowOpacity, target: 0.4, duration: 300 },
      ],
      onAnyComplete: (index) => {
        // scaleê³¼ shadowëŠ” ì¤‘ê°„ì— ë³µê·€
        if (index === 1) {
          scale.value = withTiming(1, { duration: 300 });
        }
        if (index === 2) {
          shadowOpacity.value = withTiming(0.2, { duration: 300 });
        }
      },
      onAllComplete: () => {
        console.log('Flip complete!');
      },
    });
  };

  const frontStyle = useAnimatedStyle(() => ({
    transform: [
      { perspective: 1000 },
      { rotateY: `${rotateY.value}deg` },
      { scale: scale.value },
    ],
    backfaceVisibility: 'hidden',
    shadowOpacity: shadowOpacity.value,
  }));

  const backStyle = useAnimatedStyle(() => ({
    transform: [
      { perspective: 1000 },
      { rotateY: `${rotateY.value + 180}deg` },
      { scale: scale.value },
    ],
    backfaceVisibility: 'hidden',
    position: 'absolute',
  }));

  return (
    <Pressable onPress={flipCard}>
      <Animated.View style={[styles.card, frontStyle]}>
        <Text>Front</Text>
      </Animated.View>
      <Animated.View style={[styles.card, backStyle]}>
        <Text>Back</Text>
      </Animated.View>
    </Pressable>
  );
}
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 3: ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€

```typescript
// âŒ ë¬¸ì œ: ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°œìƒ
function RaceConditionProblem() {
  const position = useSharedValue(0);

  const moveLeft = () => {
    position.value = withTiming(-100, { duration: 300 });
  };

  const moveRight = () => {
    position.value = withTiming(100, { duration: 300 });
  };

  // ë¹ ë¥´ê²Œ ì—°ì† í˜¸ì¶œ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ì¶©ëŒ!
  return (
    <View>
      <Button onPress={moveLeft} title="Left" />
      <Button onPress={moveRight} title="Right" />
    </View>
  );
}

// âœ… í•´ê²°: ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ ê´€ë¦¬
function useAnimationLock() {
  const isLocked = useSharedValue(false);
  const currentAnimation = useSharedValue<string | null>(null);
  const pendingAnimation = useSharedValue<(() => void) | null>(null);

  const acquireLock = (animationId: string): boolean => {
    'worklet';

    if (isLocked.value) {
      return false;
    }

    isLocked.value = true;
    currentAnimation.value = animationId;
    return true;
  };

  const releaseLock = () => {
    'worklet';

    isLocked.value = false;
    currentAnimation.value = null;

    // ëŒ€ê¸° ì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
    if (pendingAnimation.value) {
      const pending = pendingAnimation.value;
      pendingAnimation.value = null;
      pending();
    }
  };

  const queueAnimation = (animation: () => void) => {
    'worklet';
    pendingAnimation.value = animation;
  };

  return {
    isLocked,
    currentAnimation,
    acquireLock,
    releaseLock,
    queueAnimation,
  };
}

// ê°œì„ ëœ ë²„ì „
function SafeAnimationController() {
  const position = useSharedValue(0);
  const { isLocked, acquireLock, releaseLock, queueAnimation } = useAnimationLock();

  const animateTo = (target: number, id: string) => {
    'worklet';

    const execute = () => {
      'worklet';

      if (!acquireLock(id)) {
        // ë½ íšë“ ì‹¤íŒ¨ ì‹œ ëŒ€ê¸°ì—´ì— ì¶”ê°€
        queueAnimation(() => animateTo(target, id));
        return;
      }

      position.value = withTiming(target, { duration: 300 }, (finished) => {
        if (finished) {
          releaseLock();
        }
      });
    };

    execute();
  };

  const moveLeft = () => runOnUI(animateTo)(-100, 'moveLeft');
  const moveRight = () => runOnUI(animateTo)(100, 'moveRight');

  return (
    <View>
      <Button onPress={moveLeft} title="Left" disabled={isLocked.value} />
      <Button onPress={moveRight} title="Right" disabled={isLocked.value} />
    </View>
  );
}

// ë” ê³ ê¸‰: ì¸í„°ëŸ½íŠ¸ ê°€ëŠ¥í•œ ì• ë‹ˆë©”ì´ì…˜
function useInterruptibleAnimation<T extends number>(initialValue: T) {
  const value = useSharedValue(initialValue);
  const targetValue = useSharedValue(initialValue);
  const animationId = useSharedValue(0);

  const animateTo = (
    target: T,
    config?: { duration?: number; easing?: (t: number) => number },
    onComplete?: (interrupted: boolean) => void
  ) => {
    'worklet';

    // ìƒˆ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ ì „ í˜„ì¬ ìœ„ì¹˜ ìº¡ì²˜
    const currentPosition = value.value;
    const myId = ++animationId.value;
    targetValue.value = target;

    // ë‚¨ì€ ê±°ë¦¬ ê¸°ë°˜ìœ¼ë¡œ duration ê³„ì‚°
    const totalDistance = Math.abs(target - initialValue);
    const remainingDistance = Math.abs(target - currentPosition);
    const ratio = remainingDistance / totalDistance;

    const baseDuration = config?.duration || 300;
    const adjustedDuration = baseDuration * ratio;

    value.value = withTiming(
      target,
      {
        duration: adjustedDuration,
        easing: config?.easing || Easing.out(Easing.cubic),
      },
      (finished) => {
        // í˜„ì¬ ì• ë‹ˆë©”ì´ì…˜ì´ ìµœì‹ ì¸ì§€ í™•ì¸
        const wasInterrupted = animationId.value !== myId;

        if (onComplete) {
          runOnJS(onComplete)(wasInterrupted);
        }
      }
    );
  };

  const snapTo = (target: T) => {
    'worklet';
    animationId.value++;
    targetValue.value = target;
    value.value = target;
  };

  return {
    value,
    targetValue,
    animateTo,
    snapTo,
  };
}
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 4: ë””ë°”ìš´ìŠ¤ì™€ ìŠ¤ë¡œí‹€

```typescript
import { useCallback, useRef } from 'react';

// Worklet-safe ë””ë°”ìš´ìŠ¤
function useAnimationDebounce(delay: number = 100) {
  const timeoutId = useSharedValue<number | null>(null);
  const lastCallTime = useSharedValue(0);

  const debounce = (callback: () => void) => {
    'worklet';

    const now = Date.now();

    // ì´ì „ íƒ€ì„ì•„ì›ƒ ì·¨ì†Œ
    if (timeoutId.value !== null) {
      // Reanimatedì—ì„œëŠ” setTimeout ëŒ€ì‹  withDelay ì‚¬ìš©
      return;
    }

    lastCallTime.value = now;

    // withDelayë¥¼ ì‚¬ìš©í•œ ë””ë°”ìš´ìŠ¤ êµ¬í˜„
    const dummyValue = useSharedValue(0);
    dummyValue.value = withDelay(
      delay,
      withTiming(1, { duration: 0 }, () => {
        if (Date.now() - lastCallTime.value >= delay) {
          callback();
        }
      })
    );
  };

  return debounce;
}

// ë” ì‹¤ìš©ì ì¸ ë””ë°”ìš´ìŠ¤ í›…
function useDebouncedAnimation() {
  const pendingValue = useSharedValue<number | null>(null);
  const isDebouncing = useSharedValue(false);
  const debounceTimer = useSharedValue(0);

  const debouncedAnimate = (
    targetValue: Animated.SharedValue<number>,
    newValue: number,
    debounceMs: number = 100,
    animationConfig?: { duration?: number }
  ) => {
    'worklet';

    pendingValue.value = newValue;
    debounceTimer.value++;
    const myTimer = debounceTimer.value;

    if (!isDebouncing.value) {
      isDebouncing.value = true;

      // ì§§ì€ ë”œë ˆì´ í›„ ìµœì‹  ê°’ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜
      const checkValue = useSharedValue(0);
      checkValue.value = withDelay(
        debounceMs,
        withTiming(1, { duration: 0 }, () => {
          if (myTimer === debounceTimer.value && pendingValue.value !== null) {
            targetValue.value = withTiming(
              pendingValue.value,
              { duration: animationConfig?.duration || 200 },
              () => {
                isDebouncing.value = false;
                pendingValue.value = null;
              }
            );
          }
        })
      );
    }
  };

  return { debouncedAnimate, isDebouncing };
}

// ìŠ¤ë¡œí‹€ë§ëœ ì œìŠ¤ì²˜ í•¸ë“¤ëŸ¬
function useThrottledGesture(throttleMs: number = 16) {
  const lastUpdateTime = useSharedValue(0);

  const throttledUpdate = (
    callback: (value: number) => void,
    value: number
  ) => {
    'worklet';

    const now = Date.now();

    if (now - lastUpdateTime.value >= throttleMs) {
      lastUpdateTime.value = now;
      callback(value);
    }
  };

  return throttledUpdate;
}

// ì‹¤ì „ ì˜ˆì‹œ: ìŠ¤í¬ë¡¤ ê¸°ë°˜ í—¤ë” ì• ë‹ˆë©”ì´ì…˜
function ThrottledScrollHeader() {
  const scrollY = useSharedValue(0);
  const headerTranslate = useSharedValue(0);
  const lastScrollY = useSharedValue(0);

  const throttledUpdate = useThrottledGesture(16); // 60fps

  const scrollHandler = useAnimatedScrollHandler({
    onScroll: (event) => {
      const currentY = event.contentOffset.y;
      const delta = currentY - lastScrollY.value;

      throttledUpdate((d) => {
        // í—¤ë” ìˆ¨ê¸°ê¸°/ë³´ì´ê¸° ë¡œì§
        const newTranslate = Math.max(
          -100,
          Math.min(0, headerTranslate.value - d)
        );

        headerTranslate.value = withTiming(newTranslate, {
          duration: 100,
          easing: Easing.out(Easing.quad),
        });
      }, delta);

      lastScrollY.value = currentY;
      scrollY.value = currentY;
    },
  });

  const headerStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: headerTranslate.value }],
  }));

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.header, headerStyle]}>
        <Text>Header</Text>
      </Animated.View>

      <Animated.ScrollView onScroll={scrollHandler} scrollEventThrottle={16}>
        {/* Content */}
      </Animated.ScrollView>
    </View>
  );
}
```

## ğŸ’» ì½”ë“œ ì˜ˆì œ 5: íƒ€ì´ë° ë””ë²„ê±°

```typescript
// ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë° ë¶„ì„ ë„êµ¬
interface TimingEvent {
  id: string;
  type: 'start' | 'update' | 'complete' | 'cancel';
  timestamp: number;
  value: number;
  duration?: number;
}

function useAnimationTimingDebugger() {
  const events = useSharedValue<TimingEvent[]>([]);
  const startTimes = useSharedValue<Record<string, number>>({});

  const recordStart = (id: string, value: number, expectedDuration: number) => {
    'worklet';

    const now = Date.now();
    startTimes.value = { ...startTimes.value, [id]: now };

    events.value = [
      ...events.value,
      {
        id,
        type: 'start',
        timestamp: now,
        value,
        duration: expectedDuration,
      },
    ];
  };

  const recordUpdate = (id: string, value: number) => {
    'worklet';

    events.value = [
      ...events.value,
      {
        id,
        type: 'update',
        timestamp: Date.now(),
        value,
      },
    ];
  };

  const recordComplete = (id: string, value: number) => {
    'worklet';

    const startTime = startTimes.value[id];
    const actualDuration = startTime ? Date.now() - startTime : 0;

    events.value = [
      ...events.value,
      {
        id,
        type: 'complete',
        timestamp: Date.now(),
        value,
        duration: actualDuration,
      },
    ];
  };

  const getTimeline = () => {
    return events.value;
  };

  const analyzeOverlaps = () => {
    const timeline = events.value;
    const overlaps: { anim1: string; anim2: string; overlapMs: number }[] = [];

    // ì‹œì‘-ì™„ë£Œ ìŒ ì°¾ê¸°
    const animations = new Map<string, { start: number; end: number }>();

    timeline.forEach(event => {
      if (event.type === 'start') {
        animations.set(event.id, { start: event.timestamp, end: 0 });
      } else if (event.type === 'complete') {
        const anim = animations.get(event.id);
        if (anim) {
          anim.end = event.timestamp;
        }
      }
    });

    // ì˜¤ë²„ë© ë¶„ì„
    const animList = Array.from(animations.entries());
    for (let i = 0; i < animList.length; i++) {
      for (let j = i + 1; j < animList.length; j++) {
        const [id1, range1] = animList[i];
        const [id2, range2] = animList[j];

        const overlapStart = Math.max(range1.start, range2.start);
        const overlapEnd = Math.min(range1.end, range2.end);

        if (overlapStart < overlapEnd) {
          overlaps.push({
            anim1: id1,
            anim2: id2,
            overlapMs: overlapEnd - overlapStart,
          });
        }
      }
    }

    return overlaps;
  };

  const reset = () => {
    events.value = [];
    startTimes.value = {};
  };

  return {
    recordStart,
    recordUpdate,
    recordComplete,
    getTimeline,
    analyzeOverlaps,
    reset,
  };
}

// íƒ€ì´ë° ì‹œê°í™” ì»´í¬ë„ŒíŠ¸
function AnimationTimeline({ events }: { events: TimingEvent[] }) {
  const minTime = Math.min(...events.map(e => e.timestamp));
  const maxTime = Math.max(...events.map(e => e.timestamp));
  const range = maxTime - minTime || 1;

  // ì• ë‹ˆë©”ì´ì…˜ IDë³„ë¡œ ê·¸ë£¹í™”
  const grouped = events.reduce((acc, event) => {
    if (!acc[event.id]) acc[event.id] = [];
    acc[event.id].push(event);
    return acc;
  }, {} as Record<string, TimingEvent[]>);

  return (
    <View style={styles.timeline}>
      <Text style={styles.timelineTitle}>Animation Timeline</Text>

      {Object.entries(grouped).map(([id, eventList], index) => (
        <View key={id} style={styles.timelineRow}>
          <Text style={styles.animId}>{id}</Text>

          <View style={styles.timelineTrack}>
            {eventList.map((event, i) => {
              const left = ((event.timestamp - minTime) / range) * 100;

              return (
                <View
                  key={i}
                  style={[
                    styles.timelineEvent,
                    {
                      left: `${left}%`,
                      backgroundColor: getEventColor(event.type),
                    },
                  ]}
                />
              );
            })}
          </View>
        </View>
      ))}

      {/* ì‹œê°„ ì¶• */}
      <View style={styles.timeAxis}>
        <Text>0ms</Text>
        <Text>{Math.round(range)}ms</Text>
      </View>
    </View>
  );
}

function getEventColor(type: TimingEvent['type']): string {
  switch (type) {
    case 'start': return '#4CAF50';
    case 'update': return '#2196F3';
    case 'complete': return '#9C27B0';
    case 'cancel': return '#F44336';
    default: return '#999';
  }
}
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### ë§¤ì¹­ ì¹´ë“œ ìŠ¤ì™€ì´í”„ ì‹œí€€ìŠ¤

```typescript
// src/features/matching/hooks/use-card-swipe-sequence.ts
import { useSharedValue, withSpring, withTiming, runOnJS } from 'react-native-reanimated';
import { Haptics } from '@/src/shared/libs/haptics';

interface SwipeResult {
  direction: 'left' | 'right';
  velocity: number;
}

export function useCardSwipeSequence() {
  // ì¹´ë“œ ìŠ¤íƒ ìƒíƒœ
  const cards = useSharedValue<string[]>([]);
  const currentIndex = useSharedValue(0);

  // ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const rotate = useSharedValue(0);
  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);

  // ë‹¤ìŒ ì¹´ë“œ ìƒíƒœ
  const nextCardScale = useSharedValue(0.95);
  const nextCardOpacity = useSharedValue(0.8);

  // íƒ€ì´ë° ê´€ë¦¬
  const isAnimating = useSharedValue(false);
  const swipeStartTime = useSharedValue(0);

  const SCREEN_WIDTH = Dimensions.get('window').width;
  const SWIPE_THRESHOLD = SCREEN_WIDTH * 0.3;
  const SWIPE_OUT_DURATION = 300;
  const RESET_DURATION = 200;
  const NEXT_CARD_DURATION = 250;

  const triggerHaptic = (type: 'light' | 'medium' | 'success') => {
    Haptics.impact(type);
  };

  const executeSwipe = (result: SwipeResult, onComplete: () => void) => {
    'worklet';

    if (isAnimating.value) return;
    isAnimating.value = true;
    swipeStartTime.value = Date.now();

    const direction = result.direction === 'right' ? 1 : -1;
    const targetX = direction * SCREEN_WIDTH * 1.5;
    const targetRotate = direction * 30;

    // ë‹¨ê³„ 1: í˜„ì¬ ì¹´ë“œ ë‚ ë¦¬ê¸° (ë™ì‹œì— ì—¬ëŸ¬ ì†ì„±)
    translateX.value = withSpring(
      targetX,
      {
        velocity: result.velocity,
        stiffness: 100,
        damping: 15,
      }
    );

    rotate.value = withSpring(targetRotate, {
      velocity: result.velocity * 0.1,
      stiffness: 100,
      damping: 15,
    });

    opacity.value = withTiming(0, { duration: SWIPE_OUT_DURATION });

    // ë‹¨ê³„ 2: ë‹¤ìŒ ì¹´ë“œ ì˜¬ë¦¬ê¸° (ì•½ê°„ì˜ ë”œë ˆì´)
    nextCardScale.value = withDelay(
      100,
      withSpring(1, {
        stiffness: 200,
        damping: 20,
      })
    );

    nextCardOpacity.value = withDelay(
      100,
      withTiming(1, { duration: NEXT_CARD_DURATION })
    );

    // ë‹¨ê³„ 3: ìƒíƒœ ë¦¬ì…‹ ë° ì™„ë£Œ ì½œë°±
    const resetValue = useSharedValue(0);
    resetValue.value = withDelay(
      SWIPE_OUT_DURATION,
      withTiming(1, { duration: 0 }, (finished) => {
        if (finished) {
          // ìœ„ì¹˜ ë¦¬ì…‹ (ë‹¤ìŒ ì¹´ë“œ ì¤€ë¹„)
          translateX.value = 0;
          translateY.value = 0;
          rotate.value = 0;
          scale.value = 1;
          opacity.value = 1;

          // ë‹¤ìŒ ì¹´ë“œ ì´ˆê¸° ìƒíƒœ
          nextCardScale.value = 0.95;
          nextCardOpacity.value = 0.8;

          currentIndex.value++;
          isAnimating.value = false;

          runOnJS(onComplete)();
        }
      })
    );

    // í–…í‹± í”¼ë“œë°±
    runOnJS(triggerHaptic)(result.direction === 'right' ? 'success' : 'light');
  };

  const cancelSwipe = () => {
    'worklet';

    if (isAnimating.value) return;

    // ë¶€ë“œëŸ½ê²Œ ì›ìœ„ì¹˜ë¡œ
    translateX.value = withSpring(0, { stiffness: 300, damping: 25 });
    translateY.value = withSpring(0, { stiffness: 300, damping: 25 });
    rotate.value = withSpring(0, { stiffness: 300, damping: 25 });

    runOnJS(triggerHaptic)('light');
  };

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      if (isAnimating.value) return;

      translateX.value = event.translationX;
      translateY.value = event.translationY * 0.5; // ìˆ˜ì§ ì´ë™ ê°ì†Œ
      rotate.value = (event.translationX / SCREEN_WIDTH) * 20;

      // ë‹¤ìŒ ì¹´ë“œ ë¯¸ë¦¬ë³´ê¸°
      const progress = Math.abs(event.translationX) / SWIPE_THRESHOLD;
      nextCardScale.value = interpolate(
        progress,
        [0, 1],
        [0.95, 1],
        Extrapolate.CLAMP
      );
      nextCardOpacity.value = interpolate(
        progress,
        [0, 1],
        [0.8, 1],
        Extrapolate.CLAMP
      );
    })
    .onEnd((event) => {
      if (isAnimating.value) return;

      const shouldSwipe = Math.abs(event.translationX) > SWIPE_THRESHOLD ||
                          Math.abs(event.velocityX) > 500;

      if (shouldSwipe) {
        const direction = event.translationX > 0 ? 'right' : 'left';
        executeSwipe(
          { direction, velocity: event.velocityX },
          () => {
            // ìŠ¤ì™€ì´í”„ ì™„ë£Œ í›„ ì²˜ë¦¬
            console.log(`Swiped ${direction}`);
          }
        );
      } else {
        cancelSwipe();
      }
    });

  const currentCardStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotate.value}deg` },
      { scale: scale.value },
    ],
    opacity: opacity.value,
  }));

  const nextCardStyle = useAnimatedStyle(() => ({
    transform: [{ scale: nextCardScale.value }],
    opacity: nextCardOpacity.value,
  }));

  return {
    panGesture,
    currentCardStyle,
    nextCardStyle,
    currentIndex,
    isAnimating,
  };
}

// ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
function MatchingCardStack() {
  const {
    panGesture,
    currentCardStyle,
    nextCardStyle,
    currentIndex,
  } = useCardSwipeSequence();

  return (
    <View style={styles.cardStack}>
      {/* ë‹¤ìŒ ì¹´ë“œ (ë’¤ì— ë°°ì¹˜) */}
      <Animated.View style={[styles.card, styles.nextCard, nextCardStyle]}>
        <MatchCard data={cards[currentIndex.value + 1]} />
      </Animated.View>

      {/* í˜„ì¬ ì¹´ë“œ (ìœ„ì— ë°°ì¹˜) */}
      <GestureDetector gesture={panGesture}>
        <Animated.View style={[styles.card, currentCardStyle]}>
          <MatchCard data={cards[currentIndex.value]} />
        </Animated.View>
      </GestureDetector>

      {/* ìŠ¤ì™€ì´í”„ ì¸ë””ì¼€ì´í„° */}
      <SwipeIndicators translateX={translateX} />
    </View>
  );
}

// ìŠ¤ì™€ì´í”„ ì¸ë””ì¼€ì´í„°
function SwipeIndicators({ translateX }: { translateX: SharedValue<number> }) {
  const leftStyle = useAnimatedStyle(() => {
    const opacity = interpolate(
      translateX.value,
      [-100, -50, 0],
      [1, 0.5, 0],
      Extrapolate.CLAMP
    );

    return { opacity };
  });

  const rightStyle = useAnimatedStyle(() => {
    const opacity = interpolate(
      translateX.value,
      [0, 50, 100],
      [0, 0.5, 1],
      Extrapolate.CLAMP
    );

    return { opacity };
  });

  return (
    <>
      <Animated.View style={[styles.indicator, styles.leftIndicator, leftStyle]}>
        <Icon name="close" size={40} color="#FF6B6B" />
      </Animated.View>

      <Animated.View style={[styles.indicator, styles.rightIndicator, rightStyle]}>
        <Icon name="heart" size={40} color="#4CAF50" />
      </Animated.View>
    </>
  );
}

const styles = StyleSheet.create({
  cardStack: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  card: {
    position: 'absolute',
    width: SCREEN_WIDTH - 40,
    height: SCREEN_HEIGHT * 0.6,
    borderRadius: 20,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 10,
    elevation: 5,
  },
  nextCard: {
    zIndex: 1,
  },
  indicator: {
    position: 'absolute',
    top: 50,
    padding: 20,
    borderRadius: 50,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 5,
  },
  leftIndicator: {
    left: 20,
  },
  rightIndicator: {
    right: 20,
  },
});
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ì½œë°± íƒ€ì´ë° ë¶ˆì¼ì¹˜

```typescript
// âŒ ì˜ëª»ëœ ë°©ì‹: setTimeoutê³¼ withTiming duration ë¶ˆì¼ì¹˜
const animateAndNotify = () => {
  opacity.value = withTiming(1, { duration: 500 });

  setTimeout(() => {
    onAnimationComplete(); // 500ms í›„ í˜¸ì¶œë˜ì§€ë§Œ ì• ë‹ˆë©”ì´ì…˜ì€ ì•„ì§ ì§„í–‰ ì¤‘ì¼ ìˆ˜ ìˆìŒ
  }, 500);
};

// âœ… ì˜¬ë°”ë¥¸ ë°©ì‹: ì½œë°± ì‚¬ìš©
const animateAndNotify = () => {
  opacity.value = withTiming(1, { duration: 500 }, (finished) => {
    if (finished) {
      runOnJS(onAnimationComplete)();
    }
  });
};
```

### 2. ì—°ì† ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì²©

```typescript
// âŒ ì˜ëª»ëœ ë°©ì‹: ì´ì „ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì „ ìƒˆ ì• ë‹ˆë©”ì´ì…˜
const handlePress = () => {
  scale.value = withSequence(
    withTiming(1.2, { duration: 100 }),
    withTiming(1, { duration: 100 })
  );
  // ë¹ ë¥¸ ì—°ì† íƒ­ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ì¶©ëŒ
};

// âœ… ì˜¬ë°”ë¥¸ ë°©ì‹: ê°€ë“œ ì¶”ê°€
const isAnimating = useSharedValue(false);

const handlePress = () => {
  if (isAnimating.value) return;

  isAnimating.value = true;
  scale.value = withSequence(
    withTiming(1.2, { duration: 100 }),
    withTiming(1, { duration: 100 }, (finished) => {
      if (finished) {
        isAnimating.value = false;
      }
    })
  );
};
```

### 3. ë¹„ë™ê¸° ìƒíƒœì™€ ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™”

```typescript
// âŒ ì˜ëª»ëœ ë°©ì‹: API ì‘ë‹µê³¼ ì• ë‹ˆë©”ì´ì…˜ ë¶ˆì¼ì¹˜
const fetchAndAnimate = async () => {
  setLoading(true);
  loadingOpacity.value = withTiming(1);

  const data = await fetchData();

  setLoading(false);
  loadingOpacity.value = withTiming(0); // ì¦‰ì‹œ ì‚¬ë¼ì§
};

// âœ… ì˜¬ë°”ë¥¸ ë°©ì‹: ìµœì†Œ í‘œì‹œ ì‹œê°„ ë³´ì¥
const fetchAndAnimate = async () => {
  const startTime = Date.now();
  const MIN_LOADING_TIME = 500;

  setLoading(true);
  loadingOpacity.value = withTiming(1);

  const data = await fetchData();

  const elapsed = Date.now() - startTime;
  const remainingTime = Math.max(0, MIN_LOADING_TIME - elapsed);

  // ìµœì†Œ ì‹œê°„ í›„ fade out
  loadingOpacity.value = withDelay(
    remainingTime,
    withTiming(0, { duration: 200 }, () => {
      runOnJS(setLoading)(false);
    })
  );
};
```

## ğŸ’¡ íŒ

1. **ì• ë‹ˆë©”ì´ì…˜ IDë¡œ ì¶”ì í•˜ê¸°**: ë³µì¡í•œ ì‹œí€€ìŠ¤ì—ì„œëŠ” ê° ì• ë‹ˆë©”ì´ì…˜ì— ê³ ìœ  IDë¥¼ ë¶€ì—¬í•˜ì—¬ ë””ë²„ê¹… ìš©ì´
2. **ì™„ë£Œ ì½œë°± í•­ìƒ ì‚¬ìš©í•˜ê¸°**: setTimeout ëŒ€ì‹  withTimingì˜ ì½œë°± í™œìš©
3. **ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ ê³µìœ  ê°’ìœ¼ë¡œ ê´€ë¦¬**: isAnimatingì„ SharedValueë¡œ ë‘ì–´ UI ìŠ¤ë ˆë“œì—ì„œ ì¦‰ì‹œ ì²´í¬
4. **ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ ê³ ë ¤**: ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ì€ ì¤‘ê°„ì— ì·¨ì†Œë  ìˆ˜ ìˆìŒì„ ê°€ì •
5. **í”„ë ˆì„ ë‹¨ìœ„ë¡œ ìƒê°í•˜ê¸°**: 16ms(60fps) ê¸°ì¤€ìœ¼ë¡œ íƒ€ì´ë° ê³„íš

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: ìˆœì°¨ í¼ ê²€ì¦ ì• ë‹ˆë©”ì´ì…˜

í¼ í•„ë“œë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ê²€ì¦í•˜ë©° ê° í•„ë“œì— ì• ë‹ˆë©”ì´ì…˜ì„ ì ìš©í•˜ëŠ” í›…ì„ ë§Œë“œì„¸ìš”.

<details>
<summary>ì •ë‹µ ë³´ê¸°</summary>

```typescript
interface FieldValidation {
  fieldId: string;
  isValid: boolean;
  errorMessage?: string;
}

function useSequentialFormValidation() {
  const fieldAnimations = useSharedValue<Record<string, number>>({});
  const currentFieldIndex = useSharedValue(0);
  const validationResults = useSharedValue<FieldValidation[]>([]);

  const validateSequentially = async (
    fields: string[],
    validators: Record<string, () => Promise<FieldValidation>>
  ) => {
    const results: FieldValidation[] = [];

    for (let i = 0; i < fields.length; i++) {
      const fieldId = fields[i];
      currentFieldIndex.value = i;

      // í•„ë“œ í•˜ì´ë¼ì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜
      runOnUI(() => {
        'worklet';
        fieldAnimations.value = {
          ...fieldAnimations.value,
          [fieldId]: withTiming(1, { duration: 200 }),
        };
      })();

      // ê²€ì¦ ì‹¤í–‰
      const result = await validators[fieldId]();
      results.push(result);
      validationResults.value = [...results];

      // ê²°ê³¼ ì• ë‹ˆë©”ì´ì…˜
      runOnUI(() => {
        'worklet';
        const color = result.isValid ? 1 : -1;
        fieldAnimations.value = {
          ...fieldAnimations.value,
          [fieldId]: withSequence(
            withTiming(color * 1.5, { duration: 100 }),
            withTiming(color, { duration: 200 })
          ),
        };
      })();

      // ì—ëŸ¬ ì‹œ ì¤‘ë‹¨ ì˜µì…˜
      if (!result.isValid) {
        // shake ì• ë‹ˆë©”ì´ì…˜
        runOnUI(() => {
          'worklet';
          fieldAnimations.value = {
            ...fieldAnimations.value,
            [`${fieldId}_shake`]: withSequence(
              withTiming(10, { duration: 50 }),
              withTiming(-10, { duration: 50 }),
              withTiming(10, { duration: 50 }),
              withTiming(0, { duration: 50 })
            ),
          };
        })();
        break;
      }

      // ë‹¤ìŒ í•„ë“œ ì „ ë”œë ˆì´
      await new Promise(resolve => setTimeout(resolve, 150));
    }

    return results;
  };

  const getFieldStyle = (fieldId: string) => {
    return useAnimatedStyle(() => {
      const value = fieldAnimations.value[fieldId] || 0;
      const shake = fieldAnimations.value[`${fieldId}_shake`] || 0;

      const borderColor = interpolateColor(
        value,
        [-1, 0, 1],
        ['#FF6B6B', '#E0E0E0', '#4CAF50']
      );

      return {
        borderColor,
        borderWidth: 2,
        transform: [{ translateX: shake }],
      };
    });
  };

  return {
    validateSequentially,
    getFieldStyle,
    currentFieldIndex,
    validationResults,
  };
}
```
</details>

### ë¬¸ì œ 2: íƒ€ì´ë° ë™ê¸°í™” ìœ í‹¸ë¦¬í‹°

ì—¬ëŸ¬ ì• ë‹ˆë©”ì´ì…˜ì˜ ì‹œì‘/ì™„ë£Œ ì‹œì ì„ ì •í™•íˆ ë™ê¸°í™”í•˜ëŠ” ìœ í‹¸ë¦¬í‹°ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

<details>
<summary>ì •ë‹µ ë³´ê¸°</summary>

```typescript
type AnimationFactory = (
  onComplete: () => void
) => void;

function createSynchronizedAnimations() {
  const startTime = { value: 0 };
  const completedAnimations = { value: new Set<string>() };
  const totalAnimations = { value: 0 };
  const onAllComplete = { value: (() => {}) as () => void };

  const addAnimation = (
    id: string,
    factory: AnimationFactory
  ) => {
    totalAnimations.value++;

    return () => {
      'worklet';

      factory(() => {
        completedAnimations.value.add(id);

        if (completedAnimations.value.size === totalAnimations.value) {
          const duration = Date.now() - startTime.value;
          console.log(`All animations completed in ${duration}ms`);
          runOnJS(onAllComplete.value)();
        }
      });
    };
  };

  const runAll = (callback?: () => void) => {
    'worklet';

    if (callback) {
      onAllComplete.value = callback;
    }

    startTime.value = Date.now();
    completedAnimations.value.clear();
  };

  return {
    addAnimation,
    runAll,
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
function SynchronizedDemo() {
  const opacity1 = useSharedValue(0);
  const opacity2 = useSharedValue(0);
  const scale = useSharedValue(0.5);

  const sync = useMemo(() => createSynchronizedAnimations(), []);

  const anim1 = sync.addAnimation('opacity1', (onComplete) => {
    'worklet';
    opacity1.value = withTiming(1, { duration: 300 }, (finished) => {
      if (finished) onComplete();
    });
  });

  const anim2 = sync.addAnimation('opacity2', (onComplete) => {
    'worklet';
    opacity2.value = withTiming(1, { duration: 500 }, (finished) => {
      if (finished) onComplete();
    });
  });

  const anim3 = sync.addAnimation('scale', (onComplete) => {
    'worklet';
    scale.value = withSpring(1, { stiffness: 100 }, (finished) => {
      if (finished) onComplete();
    });
  });

  const startAll = () => {
    runOnUI(() => {
      'worklet';
      sync.runAll(() => {
        console.log('All synchronized animations complete!');
      });
      anim1();
      anim2();
      anim3();
    })();
  };

  return (
    <Button onPress={startAll} title="Start Synchronized" />
  );
}
```
</details>

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **ì‹œí€€ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™”**: ë‹¨ê³„ë³„ ì§„í–‰ê³¼ ì™„ë£Œ ì½œë°± ê´€ë¦¬
2. **ë³‘ë ¬ ì• ë‹ˆë©”ì´ì…˜ ì¡°ìœ¨**: ì—¬ëŸ¬ ì• ë‹ˆë©”ì´ì…˜ì˜ ë™ì‹œ ì‹¤í–‰ê³¼ ì™„ë£Œ ê°ì§€
3. **ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€**: ì• ë‹ˆë©”ì´ì…˜ ë½ê³¼ íë¥¼ í†µí•œ ì•ˆì „í•œ ì‹¤í–‰
4. **ë””ë°”ìš´ìŠ¤ì™€ ìŠ¤ë¡œí‹€**: ê³¼ë„í•œ ì—…ë°ì´íŠ¸ ë°©ì§€
5. **íƒ€ì´ë° ë””ë²„ê±°**: ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰ ì‹œì  ë¶„ì„ ë„êµ¬

> **ë‹¤ìŒ ì¥ ì˜ˆê³ **: **Chapter 78: ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ**ì—ì„œëŠ” Reanimated ë²„ì „ ì—…ê·¸ë ˆì´ë“œì™€ API ë³€ê²½ ëŒ€ì‘ ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.
