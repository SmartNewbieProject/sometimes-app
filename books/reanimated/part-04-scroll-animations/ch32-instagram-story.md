# Chapter 32: ì‹¤ì „ - ì¸ìŠ¤íƒ€ê·¸ë¨ ìŠ¤í† ë¦¬

Part 4ì˜ ë§ˆì§€ë§‰ ì¥ì…ë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ëª¨ë“  ìŠ¤í¬ë¡¤ ê¸°ë²•ì„ ì¢…í•©í•´ ì¸ìŠ¤íƒ€ê·¸ë¨ ìŠ¤íƒ€ì¼ì˜ ìŠ¤í† ë¦¬ ë·°ì–´ë¥¼ ì™„ì„±í•©ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- ìŠ¤í† ë¦¬ ìºëŸ¬ì…€ êµ¬í˜„
- ì§„í–‰ë¥  ë°” ì• ë‹ˆë©”ì´ì…˜
- ìë™ ì¬ìƒê³¼ ì¼ì‹œì •ì§€
- íƒ­/ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜ ì œì–´
- ìŠ¤í† ë¦¬ ì „í™˜ íš¨ê³¼

## ğŸ“– ìŠ¤í† ë¦¬ ë·°ì–´ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProgressBar Container               â”‚
â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”    â”‚
â”‚  â”‚â–ˆâ–ˆâ–ˆâ”‚ â”‚â–ˆâ–ˆâ–ˆâ”‚ â”‚â–“â–“â–‘â”‚ â”‚â–‘â–‘â–‘â”‚ â”‚â–‘â–‘â–‘â”‚    â”‚
â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UserInfo: Avatar + Name + Time     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚                                     â”‚
â”‚         Story Content               â”‚
â”‚         (Image/Video)               â”‚
â”‚                                     â”‚
â”‚    â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º          â”‚
â”‚    Prev       â”‚          Next       â”‚
â”‚               â”‚                     â”‚
â”‚           LongPress                 â”‚
â”‚            = Pause                  â”‚
â”‚                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Reply Input + Actions              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ìƒíƒœ ë¨¸ì‹ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”  tap left  â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚      â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚      â”‚
â”‚ Prev â”‚            â”‚ Play â”‚
â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚      â”‚
â””â”€â”€â”€â”€â”€â”€â”˜  complete  â””â”€â”€â”€â”€â”€â”€â”˜
              â”‚          â”‚
              â”‚          â”‚ long press
              â”‚          â–¼
              â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”
              â”‚     â”‚Pause â”‚
              â”‚     â””â”€â”€â”€â”€â”€â”€â”˜
              â”‚          â”‚
              â”‚          â”‚ release
              â”‚          â–¼
         tap right  â”Œâ”€â”€â”€â”€â”€â”€â”
              â””â”€â”€â”€â”€â–ºâ”‚ Next â”‚
                    â””â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» ê¸°ë³¸ ìŠ¤í† ë¦¬ ë·°ì–´

### íƒ€ì… ì •ì˜

```typescript
// types/story.ts
export interface Story {
  id: string;
  userId: string;
  mediaUrl: string;
  mediaType: 'image' | 'video';
  duration: number; // milliseconds
  createdAt: Date;
}

export interface StoryGroup {
  user: {
    id: string;
    name: string;
    avatar: string;
  };
  stories: Story[];
  hasUnread: boolean;
}

export type StoryState = 'idle' | 'playing' | 'paused' | 'transitioning';
```

### ì§„í–‰ë¥  ë°” ì»´í¬ë„ŒíŠ¸

```typescript
// components/ProgressBar.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Animated, {
  useAnimatedStyle,
  withTiming,
  Easing,
  interpolate,
  SharedValue,
} from 'react-native-reanimated';

interface ProgressBarProps {
  count: number;
  currentIndex: number;
  progress: SharedValue<number>;
  isPaused: SharedValue<boolean>;
}

function ProgressBar({ count, currentIndex, progress, isPaused }: ProgressBarProps) {
  return (
    <View style={styles.container}>
      {Array.from({ length: count }).map((_, index) => (
        <ProgressSegment
          key={index}
          index={index}
          currentIndex={currentIndex}
          progress={progress}
          isPaused={isPaused}
          isLast={index === count - 1}
        />
      ))}
    </View>
  );
}

interface ProgressSegmentProps {
  index: number;
  currentIndex: number;
  progress: SharedValue<number>;
  isPaused: SharedValue<boolean>;
  isLast: boolean;
}

function ProgressSegment({
  index,
  currentIndex,
  progress,
  isPaused,
  isLast,
}: ProgressSegmentProps) {
  const animatedStyle = useAnimatedStyle(() => {
    let width: number | string;

    if (index < currentIndex) {
      // ì´ë¯¸ ë³¸ ìŠ¤í† ë¦¬: 100%
      width = '100%';
    } else if (index > currentIndex) {
      // ì•„ì§ ì•ˆ ë³¸ ìŠ¤í† ë¦¬: 0%
      width = '0%';
    } else {
      // í˜„ì¬ ìŠ¤í† ë¦¬: progressì— ë”°ë¼
      width = `${progress.value * 100}%`;
    }

    return {
      width,
    };
  });

  return (
    <View style={[styles.segment, !isLast && styles.segmentMargin]}>
      <View style={styles.segmentBackground} />
      <Animated.View style={[styles.segmentFill, animatedStyle]} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    paddingHorizontal: 8,
    paddingTop: 8,
    gap: 4,
  },
  segment: {
    flex: 1,
    height: 3,
    borderRadius: 1.5,
    overflow: 'hidden',
  },
  segmentMargin: {
    marginRight: 4,
  },
  segmentBackground: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
  },
  segmentFill: {
    position: 'absolute',
    left: 0,
    top: 0,
    bottom: 0,
    backgroundColor: '#FFFFFF',
  },
});

export default ProgressBar;
```

### ìŠ¤í† ë¦¬ íƒ€ì´ë¨¸ í›…

```typescript
// hooks/useStoryTimer.ts
import { useEffect, useRef, useCallback } from 'react';
import {
  useSharedValue,
  withTiming,
  cancelAnimation,
  runOnJS,
  Easing,
} from 'react-native-reanimated';

interface UseStoryTimerProps {
  duration: number;
  isPaused: boolean;
  onComplete: () => void;
}

export function useStoryTimer({ duration, isPaused, onComplete }: UseStoryTimerProps) {
  const progress = useSharedValue(0);
  const startTime = useRef<number>(0);
  const pausedProgress = useRef<number>(0);

  const startTimer = useCallback(() => {
    const remainingDuration = duration * (1 - pausedProgress.current);
    progress.value = pausedProgress.current;

    progress.value = withTiming(
      1,
      {
        duration: remainingDuration,
        easing: Easing.linear,
      },
      (finished) => {
        if (finished) {
          runOnJS(onComplete)();
        }
      }
    );

    startTime.current = Date.now() - (duration * pausedProgress.current);
  }, [duration, onComplete, progress]);

  const pauseTimer = useCallback(() => {
    const elapsed = Date.now() - startTime.current;
    pausedProgress.current = Math.min(elapsed / duration, 1);
    cancelAnimation(progress);
    progress.value = pausedProgress.current;
  }, [duration, progress]);

  const resetTimer = useCallback(() => {
    cancelAnimation(progress);
    progress.value = 0;
    pausedProgress.current = 0;
    startTime.current = 0;
  }, [progress]);

  useEffect(() => {
    if (isPaused) {
      pauseTimer();
    } else {
      startTimer();
    }

    return () => {
      cancelAnimation(progress);
    };
  }, [isPaused, startTimer, pauseTimer, progress]);

  return {
    progress,
    resetTimer,
  };
}
```

### ì œìŠ¤ì²˜ ì˜ì—­ ì»´í¬ë„ŒíŠ¸

```typescript
// components/GestureArea.tsx
import React from 'react';
import { StyleSheet, Dimensions, Pressable } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const TAP_ZONE_WIDTH = SCREEN_WIDTH * 0.3;

interface GestureAreaProps {
  onTapLeft: () => void;
  onTapRight: () => void;
  onLongPressStart: () => void;
  onLongPressEnd: () => void;
  children: React.ReactNode;
}

function GestureArea({
  onTapLeft,
  onTapRight,
  onLongPressStart,
  onLongPressEnd,
  children,
}: GestureAreaProps) {
  const scale = useSharedValue(1);
  const isPressed = useSharedValue(false);

  const longPressGesture = Gesture.LongPress()
    .minDuration(200)
    .onStart(() => {
      isPressed.value = true;
      scale.value = withSpring(0.98, { damping: 15 });
      runOnJS(onLongPressStart)();
    })
    .onEnd(() => {
      isPressed.value = false;
      scale.value = withSpring(1, { damping: 15 });
      runOnJS(onLongPressEnd)();
    });

  const tapGesture = Gesture.Tap()
    .maxDuration(200)
    .onEnd((event) => {
      if (event.x < TAP_ZONE_WIDTH) {
        runOnJS(onTapLeft)();
      } else if (event.x > SCREEN_WIDTH - TAP_ZONE_WIDTH) {
        runOnJS(onTapRight)();
      }
    });

  const composedGesture = Gesture.Race(longPressGesture, tapGesture);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return (
    <GestureDetector gesture={composedGesture}>
      <Animated.View style={[styles.container, animatedStyle]}>
        {children}
      </Animated.View>
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default GestureArea;
```

## ğŸ’» ìŠ¤í† ë¦¬ ìºëŸ¬ì…€ êµ¬í˜„

### ìˆ˜í‰ ìŠ¤ì™€ì´í”„ ë„¤ë¹„ê²Œì´ì…˜

```typescript
// components/StoryCarousel.tsx
import React, { useCallback, useState } from 'react';
import { View, StyleSheet, Dimensions, Image } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  interpolate,
  Extrapolation,
} from 'react-native-reanimated';
import { StoryGroup, Story } from '../types/story';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const SWIPE_THRESHOLD = SCREEN_WIDTH * 0.3;

interface StoryCarouselProps {
  storyGroups: StoryGroup[];
  initialGroupIndex: number;
  onClose: () => void;
}

function StoryCarousel({
  storyGroups,
  initialGroupIndex,
  onClose,
}: StoryCarouselProps) {
  const [currentGroupIndex, setCurrentGroupIndex] = useState(initialGroupIndex);
  const [currentStoryIndex, setCurrentStoryIndex] = useState(0);
  const [isPaused, setIsPaused] = useState(false);

  const translateX = useSharedValue(-initialGroupIndex * SCREEN_WIDTH);
  const contextX = useSharedValue(0);

  const currentGroup = storyGroups[currentGroupIndex];
  const currentStory = currentGroup?.stories[currentStoryIndex];

  const goToNextGroup = useCallback(() => {
    if (currentGroupIndex < storyGroups.length - 1) {
      const newIndex = currentGroupIndex + 1;
      setCurrentGroupIndex(newIndex);
      setCurrentStoryIndex(0);
      translateX.value = withSpring(-newIndex * SCREEN_WIDTH, {
        damping: 20,
        stiffness: 200,
      });
    } else {
      onClose();
    }
  }, [currentGroupIndex, storyGroups.length, onClose, translateX]);

  const goToPrevGroup = useCallback(() => {
    if (currentGroupIndex > 0) {
      const newIndex = currentGroupIndex - 1;
      setCurrentGroupIndex(newIndex);
      setCurrentStoryIndex(storyGroups[newIndex].stories.length - 1);
      translateX.value = withSpring(-newIndex * SCREEN_WIDTH, {
        damping: 20,
        stiffness: 200,
      });
    }
  }, [currentGroupIndex, storyGroups, translateX]);

  const goToNextStory = useCallback(() => {
    if (currentStoryIndex < currentGroup.stories.length - 1) {
      setCurrentStoryIndex(currentStoryIndex + 1);
    } else {
      goToNextGroup();
    }
  }, [currentStoryIndex, currentGroup.stories.length, goToNextGroup]);

  const goToPrevStory = useCallback(() => {
    if (currentStoryIndex > 0) {
      setCurrentStoryIndex(currentStoryIndex - 1);
    } else {
      goToPrevGroup();
    }
  }, [currentStoryIndex, goToPrevGroup]);

  const panGesture = Gesture.Pan()
    .onStart(() => {
      contextX.value = translateX.value;
      runOnJS(setIsPaused)(true);
    })
    .onUpdate((event) => {
      const newTranslateX = contextX.value + event.translationX;

      // ê²½ê³„ ì²˜ë¦¬: ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ì—ì„œ ì €í•­ê°
      const minX = -(storyGroups.length - 1) * SCREEN_WIDTH;
      const maxX = 0;

      if (newTranslateX > maxX) {
        translateX.value = maxX + (newTranslateX - maxX) * 0.3;
      } else if (newTranslateX < minX) {
        translateX.value = minX + (newTranslateX - minX) * 0.3;
      } else {
        translateX.value = newTranslateX;
      }
    })
    .onEnd((event) => {
      const velocity = event.velocityX;

      if (
        event.translationX < -SWIPE_THRESHOLD ||
        (velocity < -500 && event.translationX < 0)
      ) {
        // ë‹¤ìŒ ê·¸ë£¹ìœ¼ë¡œ
        runOnJS(goToNextGroup)();
      } else if (
        event.translationX > SWIPE_THRESHOLD ||
        (velocity > 500 && event.translationX > 0)
      ) {
        // ì´ì „ ê·¸ë£¹ìœ¼ë¡œ
        runOnJS(goToPrevGroup)();
      } else {
        // ì›ìœ„ì¹˜
        translateX.value = withSpring(-currentGroupIndex * SCREEN_WIDTH, {
          damping: 20,
          stiffness: 200,
        });
      }

      runOnJS(setIsPaused)(false);
    });

  const carouselStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <View style={styles.container}>
      <GestureDetector gesture={panGesture}>
        <Animated.View style={[styles.carousel, carouselStyle]}>
          {storyGroups.map((group, groupIndex) => (
            <StoryGroupView
              key={group.user.id}
              group={group}
              isActive={groupIndex === currentGroupIndex}
              currentStoryIndex={
                groupIndex === currentGroupIndex ? currentStoryIndex : 0
              }
              isPaused={isPaused}
              onTapLeft={goToPrevStory}
              onTapRight={goToNextStory}
              onLongPressStart={() => setIsPaused(true)}
              onLongPressEnd={() => setIsPaused(false)}
              onStoryComplete={goToNextStory}
              translateX={translateX}
              groupIndex={groupIndex}
            />
          ))}
        </Animated.View>
      </GestureDetector>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  carousel: {
    flexDirection: 'row',
    height: SCREEN_HEIGHT,
  },
});

export default StoryCarousel;
```

### íë¸Œ ì „í™˜ íš¨ê³¼

```typescript
// components/StoryGroupView.tsx
import React from 'react';
import { View, StyleSheet, Dimensions, Image, Text } from 'react-native';
import Animated, {
  useAnimatedStyle,
  interpolate,
  Extrapolation,
  SharedValue,
} from 'react-native-reanimated';
import { StoryGroup } from '../types/story';
import ProgressBar from './ProgressBar';
import GestureArea from './GestureArea';
import { useStoryTimer } from '../hooks/useStoryTimer';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const PERSPECTIVE = 1000;

interface StoryGroupViewProps {
  group: StoryGroup;
  isActive: boolean;
  currentStoryIndex: number;
  isPaused: boolean;
  onTapLeft: () => void;
  onTapRight: () => void;
  onLongPressStart: () => void;
  onLongPressEnd: () => void;
  onStoryComplete: () => void;
  translateX: SharedValue<number>;
  groupIndex: number;
}

function StoryGroupView({
  group,
  isActive,
  currentStoryIndex,
  isPaused,
  onTapLeft,
  onTapRight,
  onLongPressStart,
  onLongPressEnd,
  onStoryComplete,
  translateX,
  groupIndex,
}: StoryGroupViewProps) {
  const currentStory = group.stories[currentStoryIndex];

  const { progress } = useStoryTimer({
    duration: currentStory?.duration ?? 5000,
    isPaused: isPaused || !isActive,
    onComplete: onStoryComplete,
  });

  // íë¸Œ íš¨ê³¼ ìŠ¤íƒ€ì¼
  const cubeStyle = useAnimatedStyle(() => {
    const inputRange = [
      (groupIndex - 1) * SCREEN_WIDTH,
      groupIndex * SCREEN_WIDTH,
      (groupIndex + 1) * SCREEN_WIDTH,
    ];

    const rotateY = interpolate(
      -translateX.value,
      inputRange,
      [45, 0, -45],
      Extrapolation.CLAMP
    );

    const translateXCube = interpolate(
      -translateX.value,
      inputRange,
      [-SCREEN_WIDTH * 0.5, 0, SCREEN_WIDTH * 0.5],
      Extrapolation.CLAMP
    );

    const scale = interpolate(
      -translateX.value,
      inputRange,
      [0.85, 1, 0.85],
      Extrapolation.CLAMP
    );

    const opacity = interpolate(
      -translateX.value,
      inputRange,
      [0.5, 1, 0.5],
      Extrapolation.CLAMP
    );

    return {
      transform: [
        { perspective: PERSPECTIVE },
        { translateX: translateXCube },
        { rotateY: `${rotateY}deg` },
        { scale },
      ],
      opacity,
    };
  });

  return (
    <Animated.View style={[styles.container, cubeStyle]}>
      <GestureArea
        onTapLeft={onTapLeft}
        onTapRight={onTapRight}
        onLongPressStart={onLongPressStart}
        onLongPressEnd={onLongPressEnd}
      >
        {/* ìŠ¤í† ë¦¬ ì´ë¯¸ì§€ */}
        <Image
          source={{ uri: currentStory?.mediaUrl }}
          style={styles.storyImage}
          resizeMode="cover"
        />

        {/* ì˜¤ë²„ë ˆì´ ê·¸ë¼ë°ì´ì…˜ */}
        <View style={styles.overlay} />

        {/* í”„ë¡œê·¸ë ˆìŠ¤ ë°” */}
        <View style={styles.progressContainer}>
          <ProgressBar
            count={group.stories.length}
            currentIndex={currentStoryIndex}
            progress={progress}
            isPaused={useSharedValue(isPaused)}
          />
        </View>

        {/* ìœ ì € ì •ë³´ */}
        <View style={styles.userInfo}>
          <Image
            source={{ uri: group.user.avatar }}
            style={styles.avatar}
          />
          <Text style={styles.userName}>{group.user.name}</Text>
          <Text style={styles.timeAgo}>2ì‹œê°„ ì „</Text>
        </View>
      </GestureArea>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
    backgroundColor: '#000',
    overflow: 'hidden',
    borderRadius: 12,
  },
  storyImage: {
    ...StyleSheet.absoluteFillObject,
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    background: 'linear-gradient(to bottom, rgba(0,0,0,0.4) 0%, transparent 20%, transparent 80%, rgba(0,0,0,0.4) 100%)',
  },
  progressContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    paddingTop: 50, // Safe area
  },
  userInfo: {
    position: 'absolute',
    top: 70, // Safe area + progress bar
    left: 16,
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: '#FFFFFF',
  },
  userName: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 8,
  },
  timeAgo: {
    color: 'rgba(255, 255, 255, 0.7)',
    fontSize: 12,
    marginLeft: 8,
  },
});

export default StoryGroupView;
```

## ğŸ’» ê³ ê¸‰ íš¨ê³¼ êµ¬í˜„

### ì´ë¯¸ì§€ ë¡œë”© ì• ë‹ˆë©”ì´ì…˜

```typescript
// components/StoryImage.tsx
import React, { useState } from 'react';
import { StyleSheet, Dimensions, ActivityIndicator } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  Easing,
  FadeIn,
} from 'react-native-reanimated';
import FastImage from 'react-native-fast-image';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

interface StoryImageProps {
  uri: string;
  onLoadStart: () => void;
  onLoadEnd: () => void;
}

function StoryImage({ uri, onLoadStart, onLoadEnd }: StoryImageProps) {
  const [isLoading, setIsLoading] = useState(true);
  const opacity = useSharedValue(0);
  const scale = useSharedValue(1.1);

  const handleLoadStart = () => {
    setIsLoading(true);
    onLoadStart();
  };

  const handleLoadEnd = () => {
    setIsLoading(false);

    // í˜ì´ë“œ ì¸ + ì¤Œ ì•„ì›ƒ íš¨ê³¼
    opacity.value = withTiming(1, { duration: 300 });
    scale.value = withTiming(1, {
      duration: 500,
      easing: Easing.out(Easing.cubic),
    });

    onLoadEnd();
  };

  const imageStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ scale: scale.value }],
  }));

  return (
    <>
      <Animated.View style={[styles.imageContainer, imageStyle]}>
        <FastImage
          source={{
            uri,
            priority: FastImage.priority.high,
          }}
          style={styles.image}
          resizeMode={FastImage.resizeMode.cover}
          onLoadStart={handleLoadStart}
          onLoadEnd={handleLoadEnd}
        />
      </Animated.View>

      {isLoading && (
        <Animated.View
          entering={FadeIn.duration(200)}
          style={styles.loadingContainer}
        >
          <ActivityIndicator size="large" color="#FFFFFF" />
        </Animated.View>
      )}
    </>
  );
}

const styles = StyleSheet.create({
  imageContainer: {
    ...StyleSheet.absoluteFillObject,
  },
  image: {
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  },
  loadingContainer: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
});

export default StoryImage;
```

### ìŠ¤í† ë¦¬ ê°„ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜

```typescript
// components/StoryTransition.tsx
import React, { useEffect } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  withSequence,
  interpolate,
  Easing,
} from 'react-native-reanimated';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

interface StoryTransitionProps {
  direction: 'next' | 'prev' | null;
  onTransitionEnd: () => void;
  children: React.ReactNode;
}

function StoryTransition({
  direction,
  onTransitionEnd,
  children,
}: StoryTransitionProps) {
  const progress = useSharedValue(0);

  useEffect(() => {
    if (direction) {
      progress.value = 0;
      progress.value = withTiming(
        1,
        {
          duration: 300,
          easing: Easing.out(Easing.cubic),
        },
        () => {
          // ì „í™˜ ì™„ë£Œ ì½œë°±
        }
      );
    }
  }, [direction, progress]);

  const currentStyle = useAnimatedStyle(() => {
    if (!direction) {
      return {};
    }

    const translateX = interpolate(
      progress.value,
      [0, 1],
      [0, direction === 'next' ? -SCREEN_WIDTH : SCREEN_WIDTH]
    );

    const scale = interpolate(
      progress.value,
      [0, 0.5, 1],
      [1, 0.95, 0.9]
    );

    const opacity = interpolate(
      progress.value,
      [0, 1],
      [1, 0]
    );

    return {
      transform: [
        { translateX },
        { scale },
      ],
      opacity,
    };
  });

  const nextStyle = useAnimatedStyle(() => {
    if (!direction) {
      return { opacity: 0 };
    }

    const translateX = interpolate(
      progress.value,
      [0, 1],
      [direction === 'next' ? SCREEN_WIDTH : -SCREEN_WIDTH, 0]
    );

    const scale = interpolate(
      progress.value,
      [0, 0.5, 1],
      [0.9, 0.95, 1]
    );

    const opacity = interpolate(
      progress.value,
      [0, 1],
      [0, 1]
    );

    return {
      transform: [
        { translateX },
        { scale },
      ],
      opacity,
    };
  });

  return (
    <>
      <Animated.View style={[styles.container, currentStyle]}>
        {children}
      </Animated.View>
      <Animated.View style={[styles.container, styles.overlay, nextStyle]} />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
  },
  overlay: {
    backgroundColor: '#000',
  },
});

export default StoryTransition;
```

### ë‹«ê¸° ì œìŠ¤ì²˜ (ìœ„ë¡œ ë“œë˜ê·¸)

```typescript
// hooks/useCloseGesture.ts
import { Gesture } from 'react-native-gesture-handler';
import {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
  interpolate,
  Extrapolation,
} from 'react-native-reanimated';

const CLOSE_THRESHOLD = 150;

interface UseCloseGestureProps {
  onClose: () => void;
  onPauseChange: (isPaused: boolean) => void;
}

export function useCloseGesture({ onClose, onPauseChange }: UseCloseGestureProps) {
  const translateY = useSharedValue(0);
  const scale = useSharedValue(1);
  const contextY = useSharedValue(0);

  const gesture = Gesture.Pan()
    .onStart(() => {
      contextY.value = translateY.value;
      runOnJS(onPauseChange)(true);
    })
    .onUpdate((event) => {
      // ì•„ë˜ë¡œë§Œ ë“œë˜ê·¸ ê°€ëŠ¥
      const newY = contextY.value + event.translationY;
      translateY.value = Math.max(0, newY);

      // ë“œë˜ê·¸ ê±°ë¦¬ì— ë”°ë¼ ìŠ¤ì¼€ì¼ ì¡°ì •
      scale.value = interpolate(
        translateY.value,
        [0, 300],
        [1, 0.8],
        Extrapolation.CLAMP
      );
    })
    .onEnd((event) => {
      if (translateY.value > CLOSE_THRESHOLD || event.velocityY > 500) {
        // ë‹«ê¸°
        translateY.value = withSpring(1000, { damping: 20 });
        scale.value = withSpring(0.5);
        runOnJS(onClose)();
      } else {
        // ì›ìœ„ì¹˜
        translateY.value = withSpring(0, { damping: 20 });
        scale.value = withSpring(1);
        runOnJS(onPauseChange)(false);
      }
    });

  const animatedStyle = useAnimatedStyle(() => {
    const borderRadius = interpolate(
      translateY.value,
      [0, 100],
      [0, 24],
      Extrapolation.CLAMP
    );

    return {
      transform: [
        { translateY: translateY.value },
        { scale: scale.value },
      ],
      borderRadius,
    };
  });

  const backdropStyle = useAnimatedStyle(() => {
    const opacity = interpolate(
      translateY.value,
      [0, 200],
      [1, 0],
      Extrapolation.CLAMP
    );

    return {
      backgroundColor: `rgba(0, 0, 0, ${opacity})`,
    };
  });

  return {
    gesture,
    animatedStyle,
    backdropStyle,
  };
}
```

## ğŸ’» ì™„ì„±ëœ ìŠ¤í† ë¦¬ ë·°ì–´

```typescript
// screens/StoryViewerScreen.tsx
import React, { useState, useCallback } from 'react';
import { View, StyleSheet, StatusBar, Dimensions } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  FadeIn,
  FadeOut,
} from 'react-native-reanimated';
import { useNavigation, useRoute } from '@react-navigation/native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { StoryGroup, Story } from '../types/story';
import ProgressBar from '../components/ProgressBar';
import StoryImage from '../components/StoryImage';
import UserInfo from '../components/UserInfo';
import ReplyInput from '../components/ReplyInput';
import { useStoryTimer } from '../hooks/useStoryTimer';
import { useCloseGesture } from '../hooks/useCloseGesture';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

interface StoryViewerScreenProps {
  storyGroups: StoryGroup[];
  initialGroupIndex: number;
}

function StoryViewerScreen() {
  const navigation = useNavigation();
  const route = useRoute();
  const insets = useSafeAreaInsets();

  const { storyGroups, initialGroupIndex } = route.params as StoryViewerScreenProps;

  const [currentGroupIndex, setCurrentGroupIndex] = useState(initialGroupIndex);
  const [currentStoryIndex, setCurrentStoryIndex] = useState(0);
  const [isPaused, setIsPaused] = useState(false);
  const [isImageLoading, setIsImageLoading] = useState(false);

  const translateX = useSharedValue(-initialGroupIndex * SCREEN_WIDTH);
  const progress = useSharedValue(0);

  const currentGroup = storyGroups[currentGroupIndex];
  const currentStory = currentGroup?.stories[currentStoryIndex];

  const handleClose = useCallback(() => {
    navigation.goBack();
  }, [navigation]);

  const { gesture: closeGesture, animatedStyle, backdropStyle } = useCloseGesture({
    onClose: handleClose,
    onPauseChange: setIsPaused,
  });

  const goToNextStory = useCallback(() => {
    if (currentStoryIndex < currentGroup.stories.length - 1) {
      setCurrentStoryIndex(prev => prev + 1);
      progress.value = 0;
    } else if (currentGroupIndex < storyGroups.length - 1) {
      setCurrentGroupIndex(prev => prev + 1);
      setCurrentStoryIndex(0);
      progress.value = 0;
      translateX.value = withSpring(-(currentGroupIndex + 1) * SCREEN_WIDTH);
    } else {
      handleClose();
    }
  }, [
    currentStoryIndex,
    currentGroupIndex,
    currentGroup?.stories.length,
    storyGroups.length,
    handleClose,
    progress,
    translateX,
  ]);

  const goToPrevStory = useCallback(() => {
    if (currentStoryIndex > 0) {
      setCurrentStoryIndex(prev => prev - 1);
      progress.value = 0;
    } else if (currentGroupIndex > 0) {
      setCurrentGroupIndex(prev => prev - 1);
      const prevGroup = storyGroups[currentGroupIndex - 1];
      setCurrentStoryIndex(prevGroup.stories.length - 1);
      progress.value = 0;
      translateX.value = withSpring(-(currentGroupIndex - 1) * SCREEN_WIDTH);
    }
  }, [currentStoryIndex, currentGroupIndex, storyGroups, progress, translateX]);

  // íƒ€ì´ë¨¸ í›…
  const { resetTimer } = useStoryTimer({
    duration: currentStory?.duration ?? 5000,
    isPaused: isPaused || isImageLoading,
    onComplete: goToNextStory,
  });

  // íƒ­ ì œìŠ¤ì²˜
  const tapGesture = Gesture.Tap()
    .maxDuration(200)
    .onEnd((event) => {
      const TAP_ZONE = SCREEN_WIDTH * 0.3;

      if (event.x < TAP_ZONE) {
        runOnJS(goToPrevStory)();
      } else if (event.x > SCREEN_WIDTH - TAP_ZONE) {
        runOnJS(goToNextStory)();
      }
    });

  // ë¡±í”„ë ˆìŠ¤ ì œìŠ¤ì²˜
  const longPressGesture = Gesture.LongPress()
    .minDuration(200)
    .onStart(() => {
      runOnJS(setIsPaused)(true);
    })
    .onEnd(() => {
      runOnJS(setIsPaused)(false);
    });

  // ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜
  const panGesture = Gesture.Pan()
    .activeOffsetX([-10, 10])
    .onStart(() => {
      runOnJS(setIsPaused)(true);
    })
    .onUpdate((event) => {
      const baseX = -currentGroupIndex * SCREEN_WIDTH;
      translateX.value = baseX + event.translationX * 0.5;
    })
    .onEnd((event) => {
      const SWIPE_THRESHOLD = 80;

      if (event.translationX < -SWIPE_THRESHOLD &&
          currentGroupIndex < storyGroups.length - 1) {
        runOnJS(setCurrentGroupIndex)(currentGroupIndex + 1);
        runOnJS(setCurrentStoryIndex)(0);
        translateX.value = withSpring(-(currentGroupIndex + 1) * SCREEN_WIDTH);
      } else if (event.translationX > SWIPE_THRESHOLD && currentGroupIndex > 0) {
        runOnJS(setCurrentGroupIndex)(currentGroupIndex - 1);
        runOnJS(setCurrentStoryIndex)(0);
        translateX.value = withSpring(-(currentGroupIndex - 1) * SCREEN_WIDTH);
      } else {
        translateX.value = withSpring(-currentGroupIndex * SCREEN_WIDTH);
      }

      runOnJS(setIsPaused)(false);
    });

  const composedGesture = Gesture.Race(
    closeGesture,
    Gesture.Simultaneous(
      tapGesture,
      longPressGesture,
      panGesture
    )
  );

  const carouselStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <View style={styles.container}>
      <StatusBar hidden />

      {/* ë°°ê²½ ì˜¤ë²„ë ˆì´ */}
      <Animated.View style={[styles.backdrop, backdropStyle]} />

      {/* ë©”ì¸ ìŠ¤í† ë¦¬ ë·° */}
      <GestureDetector gesture={composedGesture}>
        <Animated.View style={[styles.storyContainer, animatedStyle]}>
          <Animated.View style={[styles.carousel, carouselStyle]}>
            {storyGroups.map((group, groupIndex) => (
              <View key={group.user.id} style={styles.groupContainer}>
                {groupIndex === currentGroupIndex && (
                  <StoryImage
                    uri={currentStory?.mediaUrl ?? ''}
                    onLoadStart={() => setIsImageLoading(true)}
                    onLoadEnd={() => setIsImageLoading(false)}
                  />
                )}
              </View>
            ))}
          </Animated.View>

          {/* UI ì˜¤ë²„ë ˆì´ */}
          <View style={[styles.uiOverlay, { paddingTop: insets.top }]}>
            {/* í”„ë¡œê·¸ë ˆìŠ¤ ë°” */}
            <ProgressBar
              count={currentGroup?.stories.length ?? 0}
              currentIndex={currentStoryIndex}
              progress={progress}
              isPaused={useSharedValue(isPaused)}
            />

            {/* ìœ ì € ì •ë³´ */}
            <UserInfo
              user={currentGroup?.user}
              onClose={handleClose}
            />
          </View>

          {/* í•˜ë‹¨ ì…ë ¥ */}
          <View style={[styles.bottomContainer, { paddingBottom: insets.bottom }]}>
            <ReplyInput
              onFocus={() => setIsPaused(true)}
              onBlur={() => setIsPaused(false)}
            />
          </View>
        </Animated.View>
      </GestureDetector>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  backdrop: {
    ...StyleSheet.absoluteFillObject,
  },
  storyContainer: {
    flex: 1,
    overflow: 'hidden',
  },
  carousel: {
    flexDirection: 'row',
    flex: 1,
  },
  groupContainer: {
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  },
  uiOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
  },
  bottomContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: 16,
  },
});

export default StoryViewerScreen;
```

## ğŸ’» sometimes-app ì ìš© ì‚¬ë¡€

### ë§¤ì¹­ ìŠ¤í† ë¦¬ êµ¬í˜„

```typescript
// src/features/matching/ui/matching-story-viewer.tsx
import React, { useCallback, useState, useEffect } from 'react';
import { View, StyleSheet, Dimensions, Image, Text } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  interpolate,
  Extrapolation,
  FadeIn,
  FadeOut,
  SlideInDown,
} from 'react-native-reanimated';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { BlurView } from 'expo-blur';
import { Heart, X, MessageCircle } from 'lucide-react-native';
import colors from '@/src/shared/constants/colors';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

interface MatchingProfile {
  id: string;
  name: string;
  age: number;
  university: string;
  photos: string[];
  bio: string;
  interests: string[];
}

interface MatchingStoryViewerProps {
  profiles: MatchingProfile[];
  onLike: (profileId: string) => void;
  onPass: (profileId: string) => void;
  onMessage: (profileId: string) => void;
  onClose: () => void;
}

function MatchingStoryViewer({
  profiles,
  onLike,
  onPass,
  onMessage,
  onClose,
}: MatchingStoryViewerProps) {
  const insets = useSafeAreaInsets();

  const [currentProfileIndex, setCurrentProfileIndex] = useState(0);
  const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);
  const [isPaused, setIsPaused] = useState(false);

  const translateX = useSharedValue(0);
  const likeScale = useSharedValue(1);
  const passScale = useSharedValue(1);
  const progress = useSharedValue(0);
  const overlayOpacity = useSharedValue(0);
  const overlayType = useSharedValue<'like' | 'pass' | null>(null);

  const currentProfile = profiles[currentProfileIndex];
  const currentPhoto = currentProfile?.photos[currentPhotoIndex];

  // ìë™ ì§„í–‰ íƒ€ì´ë¨¸
  useEffect(() => {
    if (isPaused) return;

    progress.value = 0;
    progress.value = withTiming(1, { duration: 5000 }, (finished) => {
      if (finished) {
        runOnJS(goToNextPhoto)();
      }
    });

    return () => {
      progress.value = 0;
    };
  }, [currentProfileIndex, currentPhotoIndex, isPaused]);

  const goToNextPhoto = useCallback(() => {
    if (currentPhotoIndex < currentProfile.photos.length - 1) {
      setCurrentPhotoIndex(prev => prev + 1);
    } else if (currentProfileIndex < profiles.length - 1) {
      setCurrentProfileIndex(prev => prev + 1);
      setCurrentPhotoIndex(0);
    }
  }, [currentPhotoIndex, currentProfileIndex, currentProfile?.photos.length, profiles.length]);

  const goToPrevPhoto = useCallback(() => {
    if (currentPhotoIndex > 0) {
      setCurrentPhotoIndex(prev => prev - 1);
    } else if (currentProfileIndex > 0) {
      setCurrentProfileIndex(prev => prev - 1);
      const prevProfile = profiles[currentProfileIndex - 1];
      setCurrentPhotoIndex(prevProfile.photos.length - 1);
    }
  }, [currentPhotoIndex, currentProfileIndex, profiles]);

  const handleLike = useCallback(() => {
    likeScale.value = withSpring(1.3, { damping: 10 }, () => {
      likeScale.value = withSpring(1);
    });
    overlayType.value = 'like';
    overlayOpacity.value = withTiming(1, { duration: 200 }, () => {
      overlayOpacity.value = withTiming(0, { duration: 200 });
    });

    onLike(currentProfile.id);

    // ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì´ë™
    if (currentProfileIndex < profiles.length - 1) {
      setCurrentProfileIndex(prev => prev + 1);
      setCurrentPhotoIndex(0);
    } else {
      onClose();
    }
  }, [currentProfile?.id, currentProfileIndex, profiles.length, onLike, onClose]);

  const handlePass = useCallback(() => {
    passScale.value = withSpring(1.3, { damping: 10 }, () => {
      passScale.value = withSpring(1);
    });
    overlayType.value = 'pass';
    overlayOpacity.value = withTiming(1, { duration: 200 }, () => {
      overlayOpacity.value = withTiming(0, { duration: 200 });
    });

    onPass(currentProfile.id);

    if (currentProfileIndex < profiles.length - 1) {
      setCurrentProfileIndex(prev => prev + 1);
      setCurrentPhotoIndex(0);
    } else {
      onClose();
    }
  }, [currentProfile?.id, currentProfileIndex, profiles.length, onPass, onClose]);

  // ì œìŠ¤ì²˜
  const tapGesture = Gesture.Tap()
    .maxDuration(200)
    .onEnd((event) => {
      const TAP_ZONE = SCREEN_WIDTH * 0.3;
      if (event.x < TAP_ZONE) {
        runOnJS(goToPrevPhoto)();
      } else if (event.x > SCREEN_WIDTH - TAP_ZONE) {
        runOnJS(goToNextPhoto)();
      }
    });

  const longPressGesture = Gesture.LongPress()
    .minDuration(200)
    .onStart(() => runOnJS(setIsPaused)(true))
    .onEnd(() => runOnJS(setIsPaused)(false));

  const swipeGesture = Gesture.Pan()
    .activeOffsetY([-20, 20])
    .onUpdate((event) => {
      translateX.value = event.translationX * 0.5;
    })
    .onEnd((event) => {
      if (event.translationX > 100 || event.velocityX > 500) {
        translateX.value = withSpring(SCREEN_WIDTH);
        runOnJS(handleLike)();
      } else if (event.translationX < -100 || event.velocityX < -500) {
        translateX.value = withSpring(-SCREEN_WIDTH);
        runOnJS(handlePass)();
      } else {
        translateX.value = withSpring(0);
      }
    });

  const composedGesture = Gesture.Race(
    Gesture.Simultaneous(tapGesture, longPressGesture),
    swipeGesture
  );

  // ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼
  const cardStyle = useAnimatedStyle(() => {
    const rotate = interpolate(
      translateX.value,
      [-SCREEN_WIDTH, 0, SCREEN_WIDTH],
      [-15, 0, 15],
      Extrapolation.CLAMP
    );

    return {
      transform: [
        { translateX: translateX.value },
        { rotate: `${rotate}deg` },
      ],
    };
  });

  const likeOverlayStyle = useAnimatedStyle(() => ({
    opacity: overlayType.value === 'like' ? overlayOpacity.value : 0,
  }));

  const passOverlayStyle = useAnimatedStyle(() => ({
    opacity: overlayType.value === 'pass' ? overlayOpacity.value : 0,
  }));

  const likeButtonStyle = useAnimatedStyle(() => ({
    transform: [{ scale: likeScale.value }],
  }));

  const passButtonStyle = useAnimatedStyle(() => ({
    transform: [{ scale: passScale.value }],
  }));

  return (
    <View style={styles.container}>
      <GestureDetector gesture={composedGesture}>
        <Animated.View style={[styles.card, cardStyle]}>
          {/* í”„ë¡œí•„ ì´ë¯¸ì§€ */}
          <Image
            source={{ uri: currentPhoto }}
            style={styles.profileImage}
            resizeMode="cover"
          />

          {/* ì¢‹ì•„ìš”/íŒ¨ìŠ¤ ì˜¤ë²„ë ˆì´ */}
          <Animated.View style={[styles.likeOverlay, likeOverlayStyle]}>
            <BlurView intensity={50} style={styles.overlayBlur}>
              <Heart size={100} color={colors.primaryPurple} fill={colors.primaryPurple} />
              <Text style={styles.overlayText}>LIKE</Text>
            </BlurView>
          </Animated.View>

          <Animated.View style={[styles.passOverlay, passOverlayStyle]}>
            <BlurView intensity={50} style={styles.overlayBlur}>
              <X size={100} color="#FF6B6B" />
              <Text style={[styles.overlayText, { color: '#FF6B6B' }]}>PASS</Text>
            </BlurView>
          </Animated.View>

          {/* í”„ë¡œê·¸ë ˆìŠ¤ ë°” */}
          <View style={[styles.progressContainer, { paddingTop: insets.top + 8 }]}>
            {currentProfile?.photos.map((_, index) => (
              <View key={index} style={styles.progressSegment}>
                <View style={styles.progressBackground} />
                {index === currentPhotoIndex && (
                  <Animated.View
                    style={[
                      styles.progressFill,
                      useAnimatedStyle(() => ({
                        width: `${progress.value * 100}%`,
                      }))
                    ]}
                  />
                )}
                {index < currentPhotoIndex && (
                  <View style={[styles.progressFill, { width: '100%' }]} />
                )}
              </View>
            ))}
          </View>

          {/* í”„ë¡œí•„ ì •ë³´ */}
          <Animated.View
            entering={SlideInDown.duration(300)}
            style={styles.profileInfo}
          >
            <BlurView intensity={80} style={styles.profileBlur}>
              <Text style={styles.profileName}>
                {currentProfile?.name}, {currentProfile?.age}
              </Text>
              <Text style={styles.profileUniversity}>
                {currentProfile?.university}
              </Text>
              <Text style={styles.profileBio} numberOfLines={2}>
                {currentProfile?.bio}
              </Text>

              {/* ê´€ì‹¬ì‚¬ íƒœê·¸ */}
              <View style={styles.interestsContainer}>
                {currentProfile?.interests.slice(0, 3).map((interest, index) => (
                  <View key={index} style={styles.interestTag}>
                    <Text style={styles.interestText}>{interest}</Text>
                  </View>
                ))}
              </View>
            </BlurView>
          </Animated.View>
        </Animated.View>
      </GestureDetector>

      {/* ì•¡ì…˜ ë²„íŠ¼ */}
      <View style={[styles.actionsContainer, { paddingBottom: insets.bottom + 20 }]}>
        <Animated.View style={passButtonStyle}>
          <ActionButton
            icon={<X size={28} color="#FF6B6B" />}
            onPress={handlePass}
            style={styles.passButton}
          />
        </Animated.View>

        <ActionButton
          icon={<MessageCircle size={24} color={colors.primaryPurple} />}
          onPress={() => onMessage(currentProfile?.id)}
          style={styles.messageButton}
        />

        <Animated.View style={likeButtonStyle}>
          <ActionButton
            icon={<Heart size={28} color={colors.primaryPurple} fill={colors.primaryPurple} />}
            onPress={handleLike}
            style={styles.likeButton}
          />
        </Animated.View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  card: {
    flex: 1,
    margin: 8,
    borderRadius: 20,
    overflow: 'hidden',
  },
  profileImage: {
    ...StyleSheet.absoluteFillObject,
  },
  progressContainer: {
    flexDirection: 'row',
    paddingHorizontal: 8,
    gap: 4,
  },
  progressSegment: {
    flex: 1,
    height: 3,
    borderRadius: 1.5,
    overflow: 'hidden',
  },
  progressBackground: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
  },
  progressFill: {
    position: 'absolute',
    left: 0,
    top: 0,
    bottom: 0,
    backgroundColor: '#FFFFFF',
  },
  profileInfo: {
    position: 'absolute',
    bottom: 80,
    left: 0,
    right: 0,
    margin: 16,
    borderRadius: 16,
    overflow: 'hidden',
  },
  profileBlur: {
    padding: 16,
  },
  profileName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#FFFFFF',
  },
  profileUniversity: {
    fontSize: 16,
    color: 'rgba(255, 255, 255, 0.8)',
    marginTop: 4,
  },
  profileBio: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.7)',
    marginTop: 8,
    lineHeight: 20,
  },
  interestsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginTop: 12,
  },
  interestTag: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  interestText: {
    fontSize: 12,
    color: '#FFFFFF',
  },
  likeOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
  },
  passOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
  },
  overlayBlur: {
    padding: 40,
    borderRadius: 100,
    alignItems: 'center',
  },
  overlayText: {
    fontSize: 32,
    fontWeight: '800',
    color: colors.primaryPurple,
    marginTop: 8,
  },
  actionsContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    gap: 24,
  },
  passButton: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#FFFFFF',
    borderWidth: 2,
    borderColor: '#FF6B6B',
  },
  messageButton: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#FFFFFF',
  },
  likeButton: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#FFFFFF',
    borderWidth: 2,
    borderColor: colors.primaryPurple,
  },
});

export default MatchingStoryViewer;
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. íƒ€ì´ë¨¸ ëˆ„ìˆ˜

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: cleanup ì—†ìŒ
useEffect(() => {
  const timer = setInterval(() => {
    progress.value += 0.01;
  }, 50);
}, []);

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: Reanimated ì• ë‹ˆë©”ì´ì…˜ + cleanup
useEffect(() => {
  progress.value = withTiming(1, { duration: 5000 });

  return () => {
    cancelAnimation(progress);
  };
}, [storyIndex]);
```

### 2. ì œìŠ¤ì²˜ ì¶©ëŒ

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ì œìŠ¤ì²˜ ê°„ì„­
const panGesture = Gesture.Pan();
const tapGesture = Gesture.Tap();

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ìš°ì„ ìˆœìœ„ ì„¤ì •
const panGesture = Gesture.Pan()
  .activeOffsetX([-10, 10]) // ìµœì†Œ ì´ë™ ê±°ë¦¬ ì„¤ì •
  .failOffsetY([-5, 5]);    // Yì¶• ì›€ì§ì„ì—ì„œ ì‹¤íŒ¨

const composedGesture = Gesture.Race(
  longPressGesture, // ë¨¼ì € ì²´í¬
  Gesture.Simultaneous(tapGesture, panGesture)
);
```

### 3. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ì´ë¯¸ì§€ ìºì‹œ ë¬´í•œ ì¦ê°€
storyGroups.forEach(group => {
  group.stories.forEach(story => {
    Image.prefetch(story.mediaUrl);
  });
});

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í˜„ì¬/ë‹¤ìŒë§Œ í”„ë¦¬í˜ì¹˜
useEffect(() => {
  const currentStory = storyGroups[currentGroupIndex]?.stories[currentStoryIndex];
  const nextStory = storyGroups[currentGroupIndex]?.stories[currentStoryIndex + 1];

  if (nextStory) {
    FastImage.preload([{ uri: nextStory.mediaUrl }]);
  }
}, [currentGroupIndex, currentStoryIndex]);
```

## ğŸ’¡ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì „ëµ

```typescript
// hooks/useStoryPreload.ts
import FastImage from 'react-native-fast-image';

export function useStoryPreload(stories: Story[], currentIndex: number) {
  useEffect(() => {
    // ë‹¤ìŒ 2ê°œ ìŠ¤í† ë¦¬ í”„ë¦¬ë¡œë“œ
    const preloadUrls = stories
      .slice(currentIndex + 1, currentIndex + 3)
      .map(story => ({ uri: story.mediaUrl }));

    FastImage.preload(preloadUrls);

    // ì´ì „ ìŠ¤í† ë¦¬ ìºì‹œì—ì„œ ì œê±° (ë©”ëª¨ë¦¬ ê´€ë¦¬)
    if (currentIndex > 2) {
      const oldUrl = stories[currentIndex - 3]?.mediaUrl;
      if (oldUrl) {
        // FastImageëŠ” ìë™ ìºì‹œ ê´€ë¦¬, ëª…ì‹œì  ì œê±° í•„ìš” ì—†ìŒ
      }
    }
  }, [currentIndex, stories]);
}
```

### 2. ë¹„ë””ì˜¤ ìŠ¤í† ë¦¬ ìµœì í™”

```typescript
// components/StoryVideo.tsx
import { Video, ResizeMode, AVPlaybackStatus } from 'expo-av';

function StoryVideo({
  uri,
  isActive,
  isPaused,
  onProgress,
  onComplete,
}: StoryVideoProps) {
  const videoRef = useRef<Video>(null);

  useEffect(() => {
    if (isActive && !isPaused) {
      videoRef.current?.playAsync();
    } else {
      videoRef.current?.pauseAsync();
    }
  }, [isActive, isPaused]);

  const handlePlaybackStatusUpdate = (status: AVPlaybackStatus) => {
    if (!status.isLoaded) return;

    const progress = status.positionMillis / status.durationMillis;
    onProgress(progress);

    if (status.didJustFinish) {
      onComplete();
    }
  };

  return (
    <Video
      ref={videoRef}
      source={{ uri }}
      style={StyleSheet.absoluteFill}
      resizeMode={ResizeMode.COVER}
      shouldPlay={isActive && !isPaused}
      isLooping={false}
      onPlaybackStatusUpdate={handlePlaybackStatusUpdate}
      // ì„±ëŠ¥ ìµœì í™”
      usePoster
      posterSource={{ uri: `${uri}?frame=0` }}
      progressUpdateIntervalMillis={100}
    />
  );
}
```

### 3. ë©”ëª¨ì´ì œì´ì…˜

```typescript
// ìŠ¤í† ë¦¬ ê·¸ë£¹ ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜
const MemoizedStoryGroup = React.memo(
  StoryGroupView,
  (prevProps, nextProps) => {
    // isActiveê°€ ë³€ê²½ë  ë•Œë§Œ ë¦¬ë Œë”ë§
    return (
      prevProps.isActive === nextProps.isActive &&
      prevProps.currentStoryIndex === nextProps.currentStoryIndex
    );
  }
);
```

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: ìŠ¤í† ë¦¬ ë‹µì¥ ê¸°ëŠ¥
ìŠ¤í† ë¦¬ í•˜ë‹¨ì˜ ë‹µì¥ ì…ë ¥ì°½ì„ êµ¬í˜„í•˜ì„¸ìš”:
- ì…ë ¥ ì‹œ í‚¤ë³´ë“œì™€ í•¨ê»˜ ì˜¬ë¼ì˜¤ëŠ” ì• ë‹ˆë©”ì´ì…˜
- ì „ì†¡ ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™” ì• ë‹ˆë©”ì´ì…˜
- ì „ì†¡ ì„±ê³µ ì‹œ ì²´í¬ ì•„ì´ì½˜ íš¨ê³¼

### ë¬¸ì œ 2: ìŠ¤í† ë¦¬ ë°˜ì‘ ê¸°ëŠ¥
ì´ëª¨ì§€ ë°˜ì‘ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ì„¸ìš”:
- ë”ë¸” íƒ­ìœ¼ë¡œ í•˜íŠ¸ ì´ëª¨ì§€ í­ë°œ íš¨ê³¼
- ë¡±í”„ë ˆìŠ¤ë¡œ ì´ëª¨ì§€ ì„ íƒ íŒ¨ë„ í‘œì‹œ
- ì„ íƒí•œ ì´ëª¨ì§€ê°€ ë‚ ì•„ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜

### ë¬¸ì œ 3: ìŠ¤í† ë¦¬ ë®¤íŠ¸ ê¸°ëŠ¥
ë¹„ë””ì˜¤ ìŠ¤í† ë¦¬ì˜ ìŒì†Œê±° í† ê¸€ì„ êµ¬í˜„í•˜ì„¸ìš”:
- ë³¼ë¥¨ ì•„ì´ì½˜ ì• ë‹ˆë©”ì´ì…˜
- ë®¤íŠ¸ ìƒíƒœ ì§€ì† (ë‹¤ìŒ ìŠ¤í† ë¦¬ê¹Œì§€)
- ì‚¬ìš´ë“œ ì›¨ì´ë¸Œ ì‹œê°í™”

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **ìŠ¤í† ë¦¬ ë·°ì–´ ì•„í‚¤í…ì²˜**: ìƒíƒœ ë¨¸ì‹ ê³¼ ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°
2. **ì§„í–‰ë¥  ë°”**: ë‹¤ì¤‘ ì„¸ê·¸ë¨¼íŠ¸ í”„ë¡œê·¸ë ˆìŠ¤ ì• ë‹ˆë©”ì´ì…˜
3. **ì œìŠ¤ì²˜ ì¡°í•©**: íƒ­, ë¡±í”„ë ˆìŠ¤, ìŠ¤ì™€ì´í”„ ë™ì‹œ ì²˜ë¦¬
4. **ìºëŸ¬ì…€ êµ¬í˜„**: íë¸Œ íš¨ê³¼ì™€ ìŠ¤ì™€ì´í”„ ì „í™˜
5. **ë‹«ê¸° ì œìŠ¤ì²˜**: ë“œë˜ê·¸ë¡œ ë‹«ê¸°ì™€ ë°°ê²½ í˜ì´ë“œ
6. **ì„±ëŠ¥ ìµœì í™”**: í”„ë¦¬ë¡œë”©, ë©”ëª¨ì´ì œì´ì…˜, ë¹„ë””ì˜¤ ì²˜ë¦¬

## ğŸ‰ Part 4 ì™„ë£Œ!

ì¶•í•˜í•©ë‹ˆë‹¤! Part 4: ìŠ¤í¬ë¡¤ ì—°ë™ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.

### Part 4ì—ì„œ ë°°ìš´ ë‚´ìš© ìš”ì•½

| ì¥ | ì£¼ì œ | í•µì‹¬ ê¸°ìˆ  |
|----|------|----------|
| Ch.25 | ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ | useAnimatedScrollHandler |
| Ch.26 | ìŠ¤í¬ë¡¤ í—¤ë” | ì ‘íˆëŠ”/íŒ¨ëŸ´ë™ìŠ¤ í—¤ë” |
| Ch.27 | ë‹¹ê²¨ì„œ ìƒˆë¡œê³ ì¹¨ | ì»¤ìŠ¤í…€ Pull-to-Refresh |
| Ch.28 | íŒ¨ëŸ´ë™ìŠ¤ ìŠ¤í¬ë¡¤ | ë‹¤ì¸µ ë°°ê²½, ì¹´ë“œ íš¨ê³¼ |
| Ch.29 | ê³ ì • ìš”ì†Œ | Sticky í—¤ë”/FAB |
| Ch.30 | ë¬´í•œ ìŠ¤í¬ë¡¤ | FlatList/FlashList ìµœì í™” |
| Ch.31 | ìŠ¤í¬ë¡¤ ìŠ¤ëƒ… | ìºëŸ¬ì…€, í”¼ì»¤, ë£¨í”„ |
| Ch.32 | ì¸ìŠ¤íƒ€ê·¸ë¨ ìŠ¤í† ë¦¬ | ì¢…í•© ì‹¤ì „ í”„ë¡œì íŠ¸ |

**ë‹¤ìŒ Part 5: ê³ ê¸‰ ê·¸ë˜í”½ìŠ¤**ì—ì„œëŠ” SVG ì• ë‹ˆë©”ì´ì…˜, Skia, 3D íš¨ê³¼, íŒŒí‹°í´ ì‹œìŠ¤í…œì„ ë‹¤ë£¹ë‹ˆë‹¤.
