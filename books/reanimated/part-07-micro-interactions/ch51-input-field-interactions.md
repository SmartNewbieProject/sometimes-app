# Chapter 51: ì…ë ¥ í•„ë“œ ì¸í„°ë™ì…˜

í¼ì€ ì•±ì˜ í•µì‹¬ ìƒí˜¸ì‘ìš© ì˜ì—­ì…ë‹ˆë‹¤. í”Œë¡œíŒ… ë ˆì´ë¸”, í¬ì»¤ìŠ¤ íš¨ê³¼, ë¬¸ì ìˆ˜ ì¹´ìš´í„° ë“± ì…ë ¥ ê²½í—˜ì„ í’ë¶€í•˜ê²Œ ë§Œë“œëŠ” ë§ˆì´í¬ë¡œ ì¸í„°ë™ì…˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- í”Œë¡œíŒ… ë ˆì´ë¸” ì• ë‹ˆë©”ì´ì…˜ êµ¬í˜„
- í¬ì»¤ìŠ¤/ë¸”ëŸ¬ í…Œë‘ë¦¬ íš¨ê³¼
- ë¬¸ì ìˆ˜ ì¹´ìš´í„°ì™€ ì§„í–‰ë¥  í‘œì‹œ
- ê²€ìƒ‰ ì…ë ¥ í•„ë“œ ì• ë‹ˆë©”ì´ì…˜
- ë¹„ë°€ë²ˆí˜¸ ê°•ë„ í‘œì‹œê¸°
- ìë™ì™„ì„± ë° íƒœê·¸ ì…ë ¥

## ğŸ“– ì…ë ¥ í•„ë“œ UX ì›ì¹™

```
ì…ë ¥ í•„ë“œ ìƒíƒœ ì „í™˜
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ê¸°ë³¸ ìƒíƒœ (Idle)
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  í”Œë ˆì´ìŠ¤í™€ë” í…ìŠ¤íŠ¸            â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

í¬ì»¤ìŠ¤ ìƒíƒœ (Focus)
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ë ˆì´ë¸” â†â”€â”€ í”Œë¡œíŒ… ë ˆì´ë¸”        â”‚
â”‚ â–Œ                               â”‚ â†â”€â”€ ì»¤ì„œ
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      â†‘
  í…Œë‘ë¦¬ ê°•ì¡°

ì…ë ¥ ì¤‘ (Typing)
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ë ˆì´ë¸”                          â”‚
â”‚ ì…ë ¥ëœ í…ìŠ¤íŠ¸â–Œ     (12/100)     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                     â†‘
              ë¬¸ì ìˆ˜ ì¹´ìš´í„°

ì™„ë£Œ ìƒíƒœ (Filled)
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ë ˆì´ë¸”                    âœ“     â”‚
â”‚ ì…ë ¥ëœ í…ìŠ¤íŠ¸                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                            â†‘
                      ìœ íš¨ì„± í‘œì‹œ

ì—ëŸ¬ ìƒíƒœ (Error)
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ë ˆì´ë¸”                    âœ•     â”‚
â”‚ ì˜ëª»ëœ ì…ë ¥                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
  ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
```

## ğŸ’» í”Œë¡œíŒ… ë ˆì´ë¸” ì…ë ¥ í•„ë“œ

### ê¸°ë³¸ í”Œë¡œíŒ… ë ˆì´ë¸”

```typescript
import React, { useState } from 'react';
import { StyleSheet, View, TextInput, Text, Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  interpolate,
  interpolateColor,
  Easing,
} from 'react-native-reanimated';

const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);

interface FloatingLabelInputProps {
  label: string;
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
  error?: string;
  secureTextEntry?: boolean;
  keyboardType?: 'default' | 'email-address' | 'numeric' | 'phone-pad';
  autoCapitalize?: 'none' | 'sentences' | 'words' | 'characters';
}

export function FloatingLabelInput({
  label,
  value,
  onChangeText,
  placeholder,
  error,
  secureTextEntry,
  keyboardType = 'default',
  autoCapitalize = 'sentences',
}: FloatingLabelInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const focusProgress = useSharedValue(0);
  const hasValue = value.length > 0;

  React.useEffect(() => {
    const shouldFloat = isFocused || hasValue;
    focusProgress.value = withTiming(shouldFloat ? 1 : 0, {
      duration: 200,
      easing: Easing.out(Easing.ease),
    });
  }, [isFocused, hasValue]);

  const labelStyle = useAnimatedStyle(() => {
    const translateY = interpolate(focusProgress.value, [0, 1], [16, -8]);
    const scale = interpolate(focusProgress.value, [0, 1], [1, 0.8]);
    const color = interpolateColor(
      focusProgress.value,
      [0, 1],
      ['#888888', error ? '#F44336' : '#7A4AE2']
    );

    return {
      transform: [
        { translateY },
        { scale },
      ],
      color,
    };
  });

  const containerStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      focusProgress.value,
      [0, 1],
      ['#E0E0E0', error ? '#F44336' : '#7A4AE2']
    );
    const borderWidth = interpolate(focusProgress.value, [0, 1], [1, 2]);

    return {
      borderColor,
      borderWidth,
    };
  });

  return (
    <View style={styles.wrapper}>
      <Animated.View style={[styles.container, containerStyle]}>
        {/* í”Œë¡œíŒ… ë ˆì´ë¸” */}
        <Animated.Text style={[styles.label, labelStyle]}>
          {label}
        </Animated.Text>

        {/* ì…ë ¥ í•„ë“œ */}
        <TextInput
          style={styles.input}
          value={value}
          onChangeText={onChangeText}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          placeholder={isFocused ? placeholder : ''}
          placeholderTextColor="#BBBBBB"
          secureTextEntry={secureTextEntry}
          keyboardType={keyboardType}
          autoCapitalize={autoCapitalize}
        />
      </Animated.View>

      {/* ì—ëŸ¬ ë©”ì‹œì§€ */}
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );
}

const styles = StyleSheet.create({
  wrapper: {
    marginBottom: 20,
  },
  container: {
    position: 'relative',
    backgroundColor: 'white',
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingTop: 20,
    paddingBottom: 8,
  },
  label: {
    position: 'absolute',
    left: 16,
    top: 0,
    fontSize: 16,
    backgroundColor: 'white',
    paddingHorizontal: 4,
    zIndex: 1,
  },
  input: {
    fontSize: 16,
    color: '#333333',
    paddingVertical: 8,
  },
  errorText: {
    color: '#F44336',
    fontSize: 12,
    marginTop: 4,
    marginLeft: 16,
  },
});
```

### ë°‘ì¤„ ìŠ¤íƒ€ì¼ ì…ë ¥ í•„ë“œ

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  interpolate,
  Easing,
} from 'react-native-reanimated';

export function UnderlineInput({
  label,
  value,
  onChangeText,
  error,
}: {
  label: string;
  value: string;
  onChangeText: (text: string) => void;
  error?: string;
}) {
  const [isFocused, setIsFocused] = useState(false);
  const focusProgress = useSharedValue(0);
  const lineScale = useSharedValue(0);

  React.useEffect(() => {
    const shouldFloat = isFocused || value.length > 0;
    focusProgress.value = withTiming(shouldFloat ? 1 : 0, { duration: 200 });
    lineScale.value = withSpring(isFocused ? 1 : 0, {
      damping: 15,
      stiffness: 150,
    });
  }, [isFocused, value]);

  const labelStyle = useAnimatedStyle(() => {
    const translateY = interpolate(focusProgress.value, [0, 1], [0, -24]);
    const scale = interpolate(focusProgress.value, [0, 1], [1, 0.8]);

    return {
      transform: [
        { translateY },
        { scale },
        { translateX: interpolate(focusProgress.value, [0, 1], [0, -8]) },
      ],
      color: isFocused ? '#7A4AE2' : '#888888',
    };
  });

  const lineStyle = useAnimatedStyle(() => ({
    transform: [{ scaleX: lineScale.value }],
    backgroundColor: error ? '#F44336' : '#7A4AE2',
  }));

  return (
    <View style={underlineStyles.container}>
      <Animated.Text style={[underlineStyles.label, labelStyle]}>
        {label}
      </Animated.Text>

      <TextInput
        style={underlineStyles.input}
        value={value}
        onChangeText={onChangeText}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
      />

      {/* ë² ì´ìŠ¤ ë¼ì¸ */}
      <View style={underlineStyles.baseLine} />

      {/* í¬ì»¤ìŠ¤ ë¼ì¸ (ì¤‘ì•™ì—ì„œ í™•ì¥) */}
      <Animated.View style={[underlineStyles.focusLine, lineStyle]} />

      {error && <Text style={underlineStyles.error}>{error}</Text>}
    </View>
  );
}

const underlineStyles = StyleSheet.create({
  container: {
    marginBottom: 24,
    position: 'relative',
  },
  label: {
    position: 'absolute',
    left: 0,
    top: 16,
    fontSize: 16,
    transformOrigin: 'left',
  },
  input: {
    fontSize: 16,
    paddingVertical: 8,
    paddingTop: 24,
    color: '#333333',
  },
  baseLine: {
    height: 1,
    backgroundColor: '#E0E0E0',
  },
  focusLine: {
    position: 'absolute',
    bottom: 0,
    left: '50%',
    right: '50%',
    height: 2,
    marginLeft: '-50%',
    width: '100%',
  },
  error: {
    color: '#F44336',
    fontSize: 12,
    marginTop: 4,
  },
});
```

## ğŸ’» ë¬¸ì ìˆ˜ ì¹´ìš´í„°

### ì›í˜• ì§„í–‰ë¥  ì¹´ìš´í„°

```typescript
import React from 'react';
import { StyleSheet, View, Text, TextInput } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  useAnimatedStyle,
  withTiming,
  interpolateColor,
} from 'react-native-reanimated';
import Svg, { Circle } from 'react-native-svg';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface CharacterCountInputProps {
  value: string;
  onChangeText: (text: string) => void;
  maxLength: number;
  label?: string;
  multiline?: boolean;
}

export function CharacterCountInput({
  value,
  onChangeText,
  maxLength,
  label,
  multiline = false,
}: CharacterCountInputProps) {
  const progress = useSharedValue(0);
  const charCount = value.length;
  const remaining = maxLength - charCount;

  React.useEffect(() => {
    progress.value = withTiming(charCount / maxLength, { duration: 200 });
  }, [charCount, maxLength]);

  const isNearLimit = remaining <= maxLength * 0.1;
  const isOverLimit = remaining < 0;

  return (
    <View style={counterStyles.container}>
      {label && <Text style={counterStyles.label}>{label}</Text>}

      <View style={counterStyles.inputWrapper}>
        <TextInput
          style={[
            counterStyles.input,
            multiline && counterStyles.multilineInput,
          ]}
          value={value}
          onChangeText={(text) => {
            if (text.length <= maxLength) {
              onChangeText(text);
            }
          }}
          multiline={multiline}
          maxLength={maxLength}
        />

        <CircularCounter
          current={charCount}
          max={maxLength}
          progress={progress}
          isNearLimit={isNearLimit}
          isOverLimit={isOverLimit}
        />
      </View>
    </View>
  );
}

function CircularCounter({
  current,
  max,
  progress,
  isNearLimit,
  isOverLimit,
}: {
  current: number;
  max: number;
  progress: Animated.SharedValue<number>;
  isNearLimit: boolean;
  isOverLimit: boolean;
}) {
  const size = 32;
  const strokeWidth = 3;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;

  const animatedProps = useAnimatedProps(() => {
    const strokeDashoffset = circumference * (1 - progress.value);
    const strokeColor = interpolateColor(
      progress.value,
      [0, 0.7, 0.9, 1],
      ['#7A4AE2', '#7A4AE2', '#FFA726', '#F44336']
    );

    return {
      strokeDashoffset,
      stroke: strokeColor,
    };
  });

  const textStyle = useAnimatedStyle(() => {
    const color = interpolateColor(
      progress.value,
      [0, 0.7, 0.9, 1],
      ['#666666', '#666666', '#FFA726', '#F44336']
    );

    return { color };
  });

  return (
    <View style={counterStyles.counterContainer}>
      <Svg width={size} height={size}>
        {/* ë°°ê²½ ì› */}
        <Circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          stroke="#E0E0E0"
          strokeWidth={strokeWidth}
          fill="none"
        />
        {/* í”„ë¡œê·¸ë ˆìŠ¤ ì› */}
        <AnimatedCircle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          fill="none"
          strokeDasharray={circumference}
          animatedProps={animatedProps}
          strokeLinecap="round"
          rotation="-90"
          origin={`${size / 2}, ${size / 2}`}
        />
      </Svg>

      <Animated.Text style={[counterStyles.counterText, textStyle]}>
        {max - current}
      </Animated.Text>
    </View>
  );
}

const counterStyles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    color: '#666666',
    marginBottom: 8,
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    backgroundColor: '#F5F5F5',
    borderRadius: 12,
    padding: 12,
  },
  input: {
    flex: 1,
    fontSize: 16,
    color: '#333333',
  },
  multilineInput: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  counterContainer: {
    width: 32,
    height: 32,
    justifyContent: 'center',
    alignItems: 'center',
  },
  counterText: {
    position: 'absolute',
    fontSize: 10,
    fontWeight: '600',
  },
});
```

### ì„ í˜• ì§„í–‰ë¥  ë°” ì¹´ìš´í„°

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  interpolateColor,
} from 'react-native-reanimated';

export function LinearCounterInput({
  value,
  onChangeText,
  maxLength,
  label,
}: CharacterCountInputProps) {
  const progress = useSharedValue(0);

  React.useEffect(() => {
    progress.value = withSpring(value.length / maxLength, {
      damping: 15,
      stiffness: 150,
    });
  }, [value.length, maxLength]);

  const progressStyle = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(
      progress.value,
      [0, 0.7, 0.9, 1],
      ['#7A4AE2', '#7A4AE2', '#FFA726', '#F44336']
    );

    return {
      width: `${progress.value * 100}%`,
      backgroundColor,
    };
  });

  return (
    <View style={linearStyles.container}>
      {label && <Text style={linearStyles.label}>{label}</Text>}

      <TextInput
        style={linearStyles.input}
        value={value}
        onChangeText={(text) => {
          if (text.length <= maxLength) {
            onChangeText(text);
          }
        }}
        maxLength={maxLength}
      />

      {/* í”„ë¡œê·¸ë ˆìŠ¤ ë°” */}
      <View style={linearStyles.progressTrack}>
        <Animated.View style={[linearStyles.progressFill, progressStyle]} />
      </View>

      {/* ì¹´ìš´í„° í…ìŠ¤íŠ¸ */}
      <Text style={linearStyles.counterText}>
        {value.length} / {maxLength}
      </Text>
    </View>
  );
}

const linearStyles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    color: '#666666',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#F5F5F5',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  progressTrack: {
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
    marginTop: 8,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    borderRadius: 2,
  },
  counterText: {
    fontSize: 12,
    color: '#888888',
    textAlign: 'right',
    marginTop: 4,
  },
});
```

## ğŸ’» ë¹„ë°€ë²ˆí˜¸ ê°•ë„ í‘œì‹œ

```typescript
import React, { useMemo } from 'react';
import { StyleSheet, View, Text, TextInput, Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  interpolateColor,
} from 'react-native-reanimated';

interface PasswordInputProps {
  value: string;
  onChangeText: (text: string) => void;
  showStrength?: boolean;
}

type StrengthLevel = 0 | 1 | 2 | 3 | 4;

interface PasswordStrength {
  level: StrengthLevel;
  label: string;
  color: string;
}

function getPasswordStrength(password: string): PasswordStrength {
  let score = 0;

  if (password.length >= 8) score++;
  if (password.length >= 12) score++;
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) score++;
  if (/\d/.test(password)) score++;
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) score++;

  const levels: PasswordStrength[] = [
    { level: 0, label: '', color: '#E0E0E0' },
    { level: 1, label: 'ì•½í•¨', color: '#F44336' },
    { level: 2, label: 'ë³´í†µ', color: '#FFA726' },
    { level: 3, label: 'ê°•í•¨', color: '#66BB6A' },
    { level: 4, label: 'ë§¤ìš° ê°•í•¨', color: '#43A047' },
  ];

  const level = Math.min(score, 4) as StrengthLevel;
  return levels[level];
}

export function PasswordInput({
  value,
  onChangeText,
  showStrength = true,
}: PasswordInputProps) {
  const [showPassword, setShowPassword] = useState(false);
  const [isFocused, setIsFocused] = useState(false);

  const strength = useMemo(() => getPasswordStrength(value), [value]);

  return (
    <View style={passwordStyles.container}>
      <View style={passwordStyles.inputWrapper}>
        <TextInput
          style={passwordStyles.input}
          value={value}
          onChangeText={onChangeText}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          secureTextEntry={!showPassword}
          placeholder="ë¹„ë°€ë²ˆí˜¸"
          placeholderTextColor="#BBBBBB"
        />

        <Pressable
          style={passwordStyles.toggleButton}
          onPress={() => setShowPassword(!showPassword)}
        >
          <Text style={passwordStyles.toggleIcon}>
            {showPassword ? 'ğŸ™ˆ' : 'ğŸ‘ï¸'}
          </Text>
        </Pressable>
      </View>

      {showStrength && value.length > 0 && (
        <PasswordStrengthIndicator strength={strength} />
      )}
    </View>
  );
}

function PasswordStrengthIndicator({ strength }: { strength: PasswordStrength }) {
  const barCount = 4;

  return (
    <View style={passwordStyles.strengthContainer}>
      <View style={passwordStyles.strengthBars}>
        {Array.from({ length: barCount }).map((_, index) => (
          <StrengthBar
            key={index}
            isActive={index < strength.level}
            color={strength.color}
            delay={index * 50}
          />
        ))}
      </View>

      <AnimatedStrengthLabel label={strength.label} color={strength.color} />
    </View>
  );
}

function StrengthBar({
  isActive,
  color,
  delay,
}: {
  isActive: boolean;
  color: string;
  delay: number;
}) {
  const scale = useSharedValue(0);
  const backgroundColor = useSharedValue('#E0E0E0');

  React.useEffect(() => {
    if (isActive) {
      scale.value = withSpring(1, { damping: 12, stiffness: 200 });
    } else {
      scale.value = withTiming(0, { duration: 150 });
    }
  }, [isActive]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scaleX: isActive ? scale.value : 1 }],
    backgroundColor: isActive ? color : '#E0E0E0',
  }));

  return <Animated.View style={[passwordStyles.strengthBar, animatedStyle]} />;
}

function AnimatedStrengthLabel({
  label,
  color,
}: {
  label: string;
  color: string;
}) {
  const opacity = useSharedValue(0);
  const translateX = useSharedValue(10);

  React.useEffect(() => {
    if (label) {
      opacity.value = withTiming(1, { duration: 200 });
      translateX.value = withSpring(0, { damping: 15 });
    }
  }, [label]);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <Animated.Text style={[passwordStyles.strengthLabel, { color }, animatedStyle]}>
      {label}
    </Animated.Text>
  );
}

const passwordStyles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  input: {
    flex: 1,
    fontSize: 16,
    paddingVertical: 12,
  },
  toggleButton: {
    padding: 8,
  },
  toggleIcon: {
    fontSize: 20,
  },
  strengthContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8,
    gap: 8,
  },
  strengthBars: {
    flexDirection: 'row',
    gap: 4,
    flex: 1,
  },
  strengthBar: {
    flex: 1,
    height: 4,
    borderRadius: 2,
  },
  strengthLabel: {
    fontSize: 12,
    fontWeight: '500',
    minWidth: 60,
    textAlign: 'right',
  },
});
```

## ğŸ’» ê²€ìƒ‰ ì…ë ¥ í•„ë“œ

### í™•ì¥í˜• ê²€ìƒ‰ ë°”

```typescript
import React, { useState } from 'react';
import { StyleSheet, View, TextInput, Pressable, Text } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  interpolate,
  Easing,
} from 'react-native-reanimated';

interface ExpandableSearchBarProps {
  value: string;
  onChangeText: (text: string) => void;
  onSearch: (query: string) => void;
  placeholder?: string;
}

export function ExpandableSearchBar({
  value,
  onChangeText,
  onSearch,
  placeholder = 'ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”',
}: ExpandableSearchBarProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const expandProgress = useSharedValue(0);
  const inputRef = React.useRef<TextInput>(null);

  const expand = () => {
    setIsExpanded(true);
    expandProgress.value = withSpring(1, { damping: 15, stiffness: 150 });
    setTimeout(() => inputRef.current?.focus(), 100);
  };

  const collapse = () => {
    if (value.length === 0) {
      setIsExpanded(false);
      expandProgress.value = withTiming(0, { duration: 200 });
      inputRef.current?.blur();
    }
  };

  const handleSubmit = () => {
    if (value.trim()) {
      onSearch(value.trim());
    }
  };

  const containerStyle = useAnimatedStyle(() => {
    const width = interpolate(expandProgress.value, [0, 1], [48, 300]);

    return {
      width,
    };
  });

  const iconStyle = useAnimatedStyle(() => {
    const rotate = interpolate(expandProgress.value, [0, 1], [0, 90]);
    const opacity = interpolate(expandProgress.value, [0, 0.5], [1, 0.5]);

    return {
      transform: [{ rotate: `${rotate}deg` }],
      opacity,
    };
  });

  const inputStyle = useAnimatedStyle(() => ({
    opacity: expandProgress.value,
    transform: [
      { translateX: interpolate(expandProgress.value, [0, 1], [20, 0]) },
    ],
  }));

  return (
    <Animated.View style={[searchStyles.container, containerStyle]}>
      <Pressable onPress={expand} style={searchStyles.iconButton}>
        <Animated.Text style={[searchStyles.searchIcon, iconStyle]}>
          ğŸ”
        </Animated.Text>
      </Pressable>

      <Animated.View style={[searchStyles.inputWrapper, inputStyle]}>
        <TextInput
          ref={inputRef}
          style={searchStyles.input}
          value={value}
          onChangeText={onChangeText}
          onBlur={collapse}
          onSubmitEditing={handleSubmit}
          placeholder={placeholder}
          placeholderTextColor="#AAAAAA"
          returnKeyType="search"
        />

        {value.length > 0 && (
          <Pressable
            onPress={() => onChangeText('')}
            style={searchStyles.clearButton}
          >
            <Text style={searchStyles.clearIcon}>âœ•</Text>
          </Pressable>
        )}
      </Animated.View>
    </Animated.View>
  );
}

const searchStyles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    borderRadius: 24,
    height: 48,
    overflow: 'hidden',
  },
  iconButton: {
    width: 48,
    height: 48,
    justifyContent: 'center',
    alignItems: 'center',
  },
  searchIcon: {
    fontSize: 20,
  },
  inputWrapper: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    paddingRight: 12,
  },
  input: {
    flex: 1,
    fontSize: 16,
    color: '#333333',
  },
  clearButton: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#DDDDDD',
    justifyContent: 'center',
    alignItems: 'center',
  },
  clearIcon: {
    fontSize: 12,
    color: '#666666',
  },
});
```

### ì‹¤ì‹œê°„ ê²€ìƒ‰ ê²°ê³¼

```typescript
import Animated, {
  useAnimatedStyle,
  withTiming,
  withDelay,
  FadeIn,
  FadeOut,
  Layout,
} from 'react-native-reanimated';

interface SearchResultsProps {
  results: string[];
  isLoading: boolean;
  onSelect: (result: string) => void;
}

export function SearchResults({
  results,
  isLoading,
  onSelect,
}: SearchResultsProps) {
  return (
    <Animated.View
      layout={Layout.springify()}
      style={resultsStyles.container}
    >
      {isLoading ? (
        <SearchResultSkeleton />
      ) : results.length > 0 ? (
        results.map((result, index) => (
          <SearchResultItem
            key={result}
            result={result}
            index={index}
            onPress={() => onSelect(result)}
          />
        ))
      ) : (
        <Animated.Text
          entering={FadeIn.delay(200)}
          style={resultsStyles.emptyText}
        >
          ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
        </Animated.Text>
      )}
    </Animated.View>
  );
}

function SearchResultItem({
  result,
  index,
  onPress,
}: {
  result: string;
  index: number;
  onPress: () => void;
}) {
  const opacity = useSharedValue(0);
  const translateX = useSharedValue(20);

  React.useEffect(() => {
    opacity.value = withDelay(index * 50, withTiming(1, { duration: 200 }));
    translateX.value = withDelay(
      index * 50,
      withTiming(0, { duration: 200 })
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <Pressable onPress={onPress}>
      <Animated.View style={[resultsStyles.resultItem, animatedStyle]}>
        <Text style={resultsStyles.resultIcon}>ğŸ”</Text>
        <Text style={resultsStyles.resultText}>{result}</Text>
      </Animated.View>
    </Pressable>
  );
}

function SearchResultSkeleton() {
  return (
    <View style={resultsStyles.skeletonContainer}>
      {[1, 2, 3].map((i) => (
        <View key={i} style={resultsStyles.skeletonItem}>
          <View style={resultsStyles.skeletonIcon} />
          <View style={resultsStyles.skeletonText} />
        </View>
      ))}
    </View>
  );
}

const resultsStyles = StyleSheet.create({
  container: {
    backgroundColor: 'white',
    borderRadius: 12,
    marginTop: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  resultItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  resultIcon: {
    fontSize: 16,
    marginRight: 12,
  },
  resultText: {
    fontSize: 14,
    color: '#333333',
  },
  emptyText: {
    padding: 24,
    textAlign: 'center',
    color: '#888888',
  },
  skeletonContainer: {
    padding: 8,
  },
  skeletonItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
  },
  skeletonIcon: {
    width: 24,
    height: 24,
    borderRadius: 4,
    backgroundColor: '#E0E0E0',
    marginRight: 12,
  },
  skeletonText: {
    flex: 1,
    height: 16,
    borderRadius: 4,
    backgroundColor: '#E0E0E0',
  },
});
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### í”„ë¡œí•„ ì†Œê°œ ì…ë ¥

```typescript
// src/features/profile-edit/ui/BioInput.tsx
import React, { useState } from 'react';
import { StyleSheet, View, Text, TextInput } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  useAnimatedProps,
  withSpring,
  withTiming,
  interpolate,
  interpolateColor,
} from 'react-native-reanimated';
import Svg, { Circle } from 'react-native-svg';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);

const MAX_BIO_LENGTH = 150;

interface BioInputProps {
  value: string;
  onChangeText: (text: string) => void;
}

export function BioInput({ value, onChangeText }: BioInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const focusProgress = useSharedValue(0);
  const charProgress = useSharedValue(0);

  React.useEffect(() => {
    focusProgress.value = withSpring(isFocused ? 1 : 0, {
      damping: 15,
      stiffness: 150,
    });
  }, [isFocused]);

  React.useEffect(() => {
    charProgress.value = withSpring(value.length / MAX_BIO_LENGTH, {
      damping: 20,
      stiffness: 200,
    });
  }, [value.length]);

  const containerStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      focusProgress.value,
      [0, 1],
      ['#E0E0E0', '#7A4AE2']
    );

    return {
      borderColor,
      borderWidth: interpolate(focusProgress.value, [0, 1], [1, 2]),
    };
  });

  const labelStyle = useAnimatedStyle(() => {
    const color = interpolateColor(
      focusProgress.value,
      [0, 1],
      ['#888888', '#7A4AE2']
    );

    return { color };
  });

  // ì›í˜• í”„ë¡œê·¸ë ˆìŠ¤
  const size = 40;
  const strokeWidth = 3;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;

  const circleProps = useAnimatedProps(() => {
    const strokeColor = interpolateColor(
      charProgress.value,
      [0, 0.7, 0.9, 1],
      ['#7A4AE2', '#7A4AE2', '#FFA726', '#F44336']
    );

    return {
      strokeDashoffset: circumference * (1 - charProgress.value),
      stroke: strokeColor,
    };
  });

  const counterStyle = useAnimatedStyle(() => {
    const color = interpolateColor(
      charProgress.value,
      [0, 0.7, 0.9, 1],
      ['#666666', '#666666', '#FFA726', '#F44336']
    );

    return { color };
  });

  return (
    <View style={bioStyles.container}>
      <View style={bioStyles.header}>
        <Animated.Text style={[bioStyles.label, labelStyle]}>
          ìê¸°ì†Œê°œ
        </Animated.Text>

        {/* ì›í˜• ì¹´ìš´í„° */}
        <View style={bioStyles.counterContainer}>
          <Svg width={size} height={size}>
            <Circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              stroke="#E8E8E8"
              strokeWidth={strokeWidth}
              fill="none"
            />
            <AnimatedCircle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              strokeWidth={strokeWidth}
              fill="none"
              strokeDasharray={circumference}
              animatedProps={circleProps}
              strokeLinecap="round"
              rotation="-90"
              origin={`${size / 2}, ${size / 2}`}
            />
          </Svg>
          <Animated.Text style={[bioStyles.counterText, counterStyle]}>
            {MAX_BIO_LENGTH - value.length}
          </Animated.Text>
        </View>
      </View>

      <Animated.View style={[bioStyles.inputContainer, containerStyle]}>
        <TextInput
          style={bioStyles.input}
          value={value}
          onChangeText={(text) => {
            if (text.length <= MAX_BIO_LENGTH) {
              onChangeText(text);
            }
          }}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          multiline
          placeholder="ë‚˜ë¥¼ ì†Œê°œí•´ë³´ì„¸ìš”!"
          placeholderTextColor="#BBBBBB"
          maxLength={MAX_BIO_LENGTH}
        />
      </Animated.View>

      {/* íŒíŠ¸ í…ìŠ¤íŠ¸ */}
      <Text style={bioStyles.hint}>
        ë§¤ë ¥ì ì¸ ì†Œê°œê¸€ì€ ë§¤ì¹­ í™•ë¥ ì„ ë†’ì—¬ìš” âœ¨
      </Text>
    </View>
  );
}

const bioStyles = StyleSheet.create({
  container: {
    marginBottom: 24,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
  },
  counterContainer: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  counterText: {
    position: 'absolute',
    fontSize: 10,
    fontWeight: '600',
  },
  inputContainer: {
    borderRadius: 12,
    backgroundColor: '#FAFAFA',
  },
  input: {
    padding: 16,
    fontSize: 15,
    color: '#333333',
    minHeight: 120,
    textAlignVertical: 'top',
  },
  hint: {
    fontSize: 12,
    color: '#888888',
    marginTop: 8,
    marginLeft: 4,
  },
});
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ë ˆì´ë¸”ì´ ì…ë ¥ê°’ê³¼ ê²¹ì¹¨

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ê°’ì´ ìˆì„ ë•Œë„ ë ˆì´ë¸”ì´ ì•ˆ ì˜¬ë¼ê°
React.useEffect(() => {
  focusProgress.value = withTiming(isFocused ? 1 : 0);
}, [isFocused]);

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í¬ì»¤ìŠ¤ OR ê°’ì´ ìˆì„ ë•Œ ë ˆì´ë¸” ì˜¬ë¦¼
React.useEffect(() => {
  const shouldFloat = isFocused || value.length > 0;
  focusProgress.value = withTiming(shouldFloat ? 1 : 0);
}, [isFocused, value]);
```

### 2. í‚¤ë³´ë“œê°€ ì…ë ¥í•„ë“œë¥¼ ê°€ë¦¼

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: í‚¤ë³´ë“œ ë¬´ì‹œ
<View>
  <FloatingLabelInput />
</View>

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: KeyboardAvoidingView ì‚¬ìš©
import { KeyboardAvoidingView, Platform } from 'react-native';

<KeyboardAvoidingView
  behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
  style={{ flex: 1 }}
>
  <FloatingLabelInput />
</KeyboardAvoidingView>
```

### 3. ì„±ëŠ¥ ë¬¸ì œ (ë§¤ íƒ€ì´í•‘ë§ˆë‹¤ ë¦¬ë Œë”)

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ìƒíƒœ ê´€ë¦¬
function Form() {
  const [bio, setBio] = useState('');
  return <BioInput value={bio} onChangeText={setBio} />; // ë§¤ íƒ€ì´í•‘ë§ˆë‹¤ Form ë¦¬ë Œë”
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì…ë ¥ ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì—ì„œ debounce
function BioInput({ initialValue, onSave }) {
  const [localValue, setLocalValue] = useState(initialValue);

  // debounceë¡œ ì €ì¥
  const debouncedSave = useDebounce(onSave, 500);

  const handleChange = (text) => {
    setLocalValue(text);
    debouncedSave(text);
  };

  return <TextInput value={localValue} onChangeText={handleChange} />;
}
```

## ğŸ’¡ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. ì…ë ¥ í•„ë“œ ë©”ëª¨ì´ì œì´ì…˜

```typescript
export const MemoizedFloatingInput = React.memo(
  FloatingLabelInput,
  (prev, next) => {
    return prev.value === next.value && prev.error === next.error;
  }
);
```

### 2. ì• ë‹ˆë©”ì´ì…˜ ê°’ ê³µìœ 

```typescript
// ì—¬ëŸ¬ ì…ë ¥ í•„ë“œê°€ ê°™ì€ í¬ì»¤ìŠ¤ ìŠ¤íƒ€ì¼ì„ ê³µìœ 
const FocusContext = React.createContext<{
  registerFocus: () => void;
  unregisterFocus: () => void;
} | null>(null);

function FormGroup({ children }) {
  const focusCount = useSharedValue(0);

  // ê·¸ë£¹ ì „ì²´ì˜ í¬ì»¤ìŠ¤ ìƒíƒœ ê´€ë¦¬
  // ...

  return (
    <FocusContext.Provider value={{ registerFocus, unregisterFocus }}>
      {children}
    </FocusContext.Provider>
  );
}
```

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: OTP ì…ë ¥ í•„ë“œ
6ìë¦¬ OTPë¥¼ ì…ë ¥ë°›ëŠ” í•„ë“œë¥¼ êµ¬í˜„í•˜ì„¸ìš”. ê° ì¹¸ì´ ê°œë³„ì ìœ¼ë¡œ í¬ì»¤ìŠ¤ë˜ê³ , ì…ë ¥ ì‹œ ìë™ìœ¼ë¡œ ë‹¤ìŒ ì¹¸ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.

### ë¬¸ì œ 2: íƒœê·¸ ì…ë ¥ í•„ë“œ
ì—¬ëŸ¬ íƒœê·¸ë¥¼ ì…ë ¥ë°›ëŠ” í•„ë“œë¥¼ êµ¬í˜„í•˜ì„¸ìš”. ì…ë ¥ í›„ ì—”í„°ë¥¼ ëˆ„ë¥´ë©´ íƒœê·¸ë¡œ ë³€í™˜ë˜ê³ , íƒœê·¸ë¥¼ í´ë¦­í•˜ë©´ ì‚­ì œë©ë‹ˆë‹¤.

### ë¬¸ì œ 3: ìë™ì™„ì„± ì…ë ¥
íƒ€ì´í•‘ ì‹œ ì¶”ì²œ í…ìŠ¤íŠ¸ê°€ ë°˜íˆ¬ëª…í•˜ê²Œ í‘œì‹œë˜ê³ , Tab í‚¤ë¡œ ì™„ì„±í•˜ëŠ” ì…ë ¥ í•„ë“œë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **í”Œë¡œíŒ… ë ˆì´ë¸”**: í¬ì»¤ìŠ¤ ì‹œ ìœ„ë¡œ ì´ë™í•˜ëŠ” ë ˆì´ë¸”
2. **ë°‘ì¤„ ìŠ¤íƒ€ì¼**: Material Design ìŠ¤íƒ€ì¼ ì…ë ¥ í•„ë“œ
3. **ë¬¸ì ìˆ˜ ì¹´ìš´í„°**: ì›í˜•/ì„ í˜• ì§„í–‰ë¥  í‘œì‹œ
4. **ë¹„ë°€ë²ˆí˜¸ ê°•ë„**: ì¡°ê±´ë³„ ê°•ë„ í‰ê°€ì™€ ì‹œê°í™”
5. **ê²€ìƒ‰ ë°”**: í™•ì¥í˜• ê²€ìƒ‰ UIì™€ ê²°ê³¼ í‘œì‹œ
6. **ì„±ëŠ¥ ìµœì í™”**: ë©”ëª¨ì´ì œì´ì…˜, debounce

## ë‹¤ìŒ ì¥ ì˜ˆê³ 

**Chapter 52: í† ê¸€ê³¼ ìŠ¤ìœ„ì¹˜ ì• ë‹ˆë©”ì´ì…˜**ì—ì„œëŠ” ì˜¨/ì˜¤í”„ ìƒíƒœë¥¼ ì „í™˜í•˜ëŠ” ë‹¤ì–‘í•œ UI ì»´í¬ë„ŒíŠ¸ë¥¼ ë§Œë“­ë‹ˆë‹¤. iOS ìŠ¤íƒ€ì¼ ìŠ¤ìœ„ì¹˜, ì²´í¬ë°•ìŠ¤, ë¼ë””ì˜¤ ë²„íŠ¼ ë“±ì˜ ì¸í„°ë™ì…˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
