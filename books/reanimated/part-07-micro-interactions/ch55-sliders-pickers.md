# Chapter 55: ìŠ¬ë¼ì´ë”ì™€ ì„ íƒê¸°

ê°’ì„ ì„ íƒí•˜ëŠ” UIëŠ” ì •í™•ì„±ê³¼ ì§ê´€ì„±ì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ë²”ìœ„ ìŠ¬ë¼ì´ë”, ë³„ì  ì„ íƒê¸°, ìƒ‰ìƒ ì„ íƒê¸° ë“± ë‹¤ì–‘í•œ ì„ íƒ ì»´í¬ë„ŒíŠ¸ë¥¼ ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ êµ¬í˜„í•©ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- ì»¤ìŠ¤í…€ ìŠ¬ë¼ì´ë” êµ¬í˜„
- ë²”ìœ„(Range) ìŠ¬ë¼ì´ë”
- ë³„ì  ë° ì´ëª¨ì§€ ì„ íƒê¸°
- ìŠ¤í… ìŠ¬ë¼ì´ë”ì™€ ëˆˆê¸ˆ í‘œì‹œ
- ìƒ‰ìƒ ì„ íƒê¸° (Hue, Saturation)
- ì‹œê°„/ë‚ ì§œ ì„ íƒ UI

## ğŸ“– ìŠ¬ë¼ì´ë” ì¸í„°ë™ì…˜ ì›ì¹™

```
ìŠ¬ë¼ì´ë” ì¸í„°ë™ì…˜ íë¦„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ì •ì  ìƒíƒœ:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
â”‚ 0         50                       100      â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

ë“œë˜ê·¸ ì¤‘:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â—‰â•â•â•â•â•â•                  â”‚ â† íŠ¸ë™ ê°•ì¡°
â”‚           [75] â† ê°’ í‘œì‹œ                    â”‚ â† íˆ´íŒ
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

í”¼ë“œë°± ìš”ì†Œ:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. ë…¸ë¸Œ í¬ê¸° ë³€í™”
   â—‹ (ì •ìƒ) â†’ â— (í„°ì¹˜) â†’ â—‹ (ë¦´ë¦¬ì¦ˆ)

2. íŠ¸ë™ ìƒ‰ìƒ ë³€í™”
   ì„ íƒ ì˜ì—­: ë¸Œëœë“œ ì»¬ëŸ¬
   ë¹„ì„ íƒ ì˜ì—­: íšŒìƒ‰

3. í–…í‹± í”¼ë“œë°±
   â€¢ ìŠ¤í… ë³€ê²½ ì‹œ Light
   â€¢ ìµœì†Œ/ìµœëŒ€ ë„ë‹¬ ì‹œ Warning

4. ê°’ ë ˆì´ë¸”
   ë“œë˜ê·¸ ì¤‘ì—ë§Œ í‘œì‹œ, ë…¸ë¸Œ ìœ„ì— ìœ„ì¹˜
```

## ğŸ’» ê¸°ë³¸ ìŠ¬ë¼ì´ë”

### ë‹¨ì¼ ê°’ ìŠ¬ë¼ì´ë”

```typescript
import React from 'react';
import { StyleSheet, View, Text, LayoutRectangle } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  clamp,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

interface SliderProps {
  value: number;
  onValueChange: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
  showValue?: boolean;
  trackColor?: string;
  activeColor?: string;
}

const TRACK_HEIGHT = 6;
const KNOB_SIZE = 24;

export function Slider({
  value,
  onValueChange,
  min = 0,
  max = 100,
  step = 1,
  showValue = true,
  trackColor = '#E0E0E0',
  activeColor = '#7A4AE2',
}: SliderProps) {
  const [trackLayout, setTrackLayout] = React.useState<LayoutRectangle | null>(null);

  const translateX = useSharedValue(0);
  const knobScale = useSharedValue(1);
  const tooltipOpacity = useSharedValue(0);
  const isActive = useSharedValue(false);

  // ê°’ì„ ìœ„ì¹˜ë¡œ ë³€í™˜
  const valueToPosition = (val: number) => {
    if (!trackLayout) return 0;
    const percentage = (val - min) / (max - min);
    return percentage * trackLayout.width;
  };

  // ìœ„ì¹˜ë¥¼ ê°’ìœ¼ë¡œ ë³€í™˜
  const positionToValue = (pos: number) => {
    if (!trackLayout) return min;
    const percentage = clamp(pos / trackLayout.width, 0, 1);
    const rawValue = min + percentage * (max - min);

    // step ì ìš©
    if (step > 0) {
      return Math.round(rawValue / step) * step;
    }
    return rawValue;
  };

  React.useEffect(() => {
    if (trackLayout) {
      translateX.value = withSpring(valueToPosition(value), {
        damping: 15,
        stiffness: 150,
      });
    }
  }, [value, trackLayout]);

  const triggerHaptic = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  const handleValueChange = (newValue: number) => {
    onValueChange(newValue);
  };

  const panGesture = Gesture.Pan()
    .onBegin(() => {
      isActive.value = true;
      knobScale.value = withSpring(1.2, { damping: 10 });
      tooltipOpacity.value = withTiming(1, { duration: 150 });
    })
    .onUpdate((event) => {
      if (!trackLayout) return;

      const newPosition = clamp(
        event.x,
        0,
        trackLayout.width
      );
      translateX.value = newPosition;

      const newValue = positionToValue(newPosition);
      if (newValue !== value) {
        runOnJS(triggerHaptic)();
        runOnJS(handleValueChange)(newValue);
      }
    })
    .onEnd(() => {
      isActive.value = false;
      knobScale.value = withSpring(1, { damping: 15 });
      tooltipOpacity.value = withTiming(0, { duration: 150 });

      // ê°€ì¥ ê°€ê¹Œìš´ stepìœ¼ë¡œ ìŠ¤ëƒ…
      const snappedValue = positionToValue(translateX.value);
      translateX.value = withSpring(valueToPosition(snappedValue), {
        damping: 15,
        stiffness: 200,
      });
    });

  const activeTrackStyle = useAnimatedStyle(() => ({
    width: translateX.value,
  }));

  const knobStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value - KNOB_SIZE / 2 },
      { scale: knobScale.value },
    ],
  }));

  const tooltipStyle = useAnimatedStyle(() => ({
    opacity: tooltipOpacity.value,
    transform: [
      { translateX: translateX.value - 20 },
      { translateY: -40 },
      { scale: tooltipOpacity.value },
    ],
  }));

  return (
    <View style={sliderStyles.container}>
      <GestureDetector gesture={panGesture}>
        <View
          style={sliderStyles.trackContainer}
          onLayout={(e) => setTrackLayout(e.nativeEvent.layout)}
        >
          {/* ë¹„í™œì„± íŠ¸ë™ */}
          <View style={[sliderStyles.track, { backgroundColor: trackColor }]} />

          {/* í™œì„± íŠ¸ë™ */}
          <Animated.View
            style={[
              sliderStyles.activeTrack,
              { backgroundColor: activeColor },
              activeTrackStyle,
            ]}
          />

          {/* ë…¸ë¸Œ */}
          <Animated.View style={[sliderStyles.knob, knobStyle]}>
            <View style={sliderStyles.knobInner} />
          </Animated.View>

          {/* íˆ´íŒ */}
          {showValue && (
            <Animated.View style={[sliderStyles.tooltip, tooltipStyle]}>
              <Text style={sliderStyles.tooltipText}>{value}</Text>
            </Animated.View>
          )}
        </View>
      </GestureDetector>

      {/* ë ˆì´ë¸” */}
      <View style={sliderStyles.labels}>
        <Text style={sliderStyles.label}>{min}</Text>
        <Text style={sliderStyles.label}>{max}</Text>
      </View>
    </View>
  );
}

const sliderStyles = StyleSheet.create({
  container: {
    paddingHorizontal: 12,
  },
  trackContainer: {
    height: 40,
    justifyContent: 'center',
  },
  track: {
    height: TRACK_HEIGHT,
    borderRadius: TRACK_HEIGHT / 2,
  },
  activeTrack: {
    position: 'absolute',
    left: 0,
    height: TRACK_HEIGHT,
    borderRadius: TRACK_HEIGHT / 2,
  },
  knob: {
    position: 'absolute',
    width: KNOB_SIZE,
    height: KNOB_SIZE,
    borderRadius: KNOB_SIZE / 2,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
    justifyContent: 'center',
    alignItems: 'center',
  },
  knobInner: {
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#7A4AE2',
  },
  tooltip: {
    position: 'absolute',
    top: 0,
    backgroundColor: '#333',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  tooltipText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  labels: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 4,
  },
  label: {
    fontSize: 12,
    color: '#888',
  },
});
```

### ë²”ìœ„ ìŠ¬ë¼ì´ë”

```typescript
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
  clamp,
} from 'react-native-reanimated';

interface RangeSliderProps {
  minValue: number;
  maxValue: number;
  onValuesChange: (min: number, max: number) => void;
  min?: number;
  max?: number;
  step?: number;
}

export function RangeSlider({
  minValue,
  maxValue,
  onValuesChange,
  min = 0,
  max = 100,
  step = 1,
}: RangeSliderProps) {
  const [trackLayout, setTrackLayout] = React.useState<LayoutRectangle | null>(null);

  const minX = useSharedValue(0);
  const maxX = useSharedValue(0);
  const activeKnob = useSharedValue<'min' | 'max' | null>(null);
  const minScale = useSharedValue(1);
  const maxScale = useSharedValue(1);

  const valueToPosition = (val: number) => {
    if (!trackLayout) return 0;
    return ((val - min) / (max - min)) * trackLayout.width;
  };

  const positionToValue = (pos: number) => {
    if (!trackLayout) return min;
    const percentage = clamp(pos / trackLayout.width, 0, 1);
    const rawValue = min + percentage * (max - min);
    return Math.round(rawValue / step) * step;
  };

  React.useEffect(() => {
    if (trackLayout) {
      minX.value = withSpring(valueToPosition(minValue));
      maxX.value = withSpring(valueToPosition(maxValue));
    }
  }, [minValue, maxValue, trackLayout]);

  const minGesture = Gesture.Pan()
    .onBegin(() => {
      activeKnob.value = 'min';
      minScale.value = withSpring(1.2);
    })
    .onUpdate((event) => {
      if (!trackLayout) return;
      const newX = clamp(event.x, 0, maxX.value - KNOB_SIZE);
      minX.value = newX;

      const newValue = positionToValue(newX);
      if (newValue !== minValue) {
        runOnJS(onValuesChange)(newValue, maxValue);
      }
    })
    .onEnd(() => {
      activeKnob.value = null;
      minScale.value = withSpring(1);
    });

  const maxGesture = Gesture.Pan()
    .onBegin(() => {
      activeKnob.value = 'max';
      maxScale.value = withSpring(1.2);
    })
    .onUpdate((event) => {
      if (!trackLayout) return;
      const newX = clamp(event.x, minX.value + KNOB_SIZE, trackLayout.width);
      maxX.value = newX;

      const newValue = positionToValue(newX);
      if (newValue !== maxValue) {
        runOnJS(onValuesChange)(minValue, newValue);
      }
    })
    .onEnd(() => {
      activeKnob.value = null;
      maxScale.value = withSpring(1);
    });

  const rangeStyle = useAnimatedStyle(() => ({
    left: minX.value,
    width: maxX.value - minX.value,
  }));

  const minKnobStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: minX.value - KNOB_SIZE / 2 },
      { scale: minScale.value },
    ],
  }));

  const maxKnobStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: maxX.value - KNOB_SIZE / 2 },
      { scale: maxScale.value },
    ],
  }));

  return (
    <View style={rangeStyles.container}>
      <View
        style={rangeStyles.trackContainer}
        onLayout={(e) => setTrackLayout(e.nativeEvent.layout)}
      >
        {/* ë¹„í™œì„± íŠ¸ë™ */}
        <View style={rangeStyles.track} />

        {/* í™œì„± ë²”ìœ„ */}
        <Animated.View style={[rangeStyles.activeRange, rangeStyle]} />

        {/* ìµœì†Œê°’ ë…¸ë¸Œ */}
        <GestureDetector gesture={minGesture}>
          <Animated.View style={[rangeStyles.knob, minKnobStyle]} />
        </GestureDetector>

        {/* ìµœëŒ€ê°’ ë…¸ë¸Œ */}
        <GestureDetector gesture={maxGesture}>
          <Animated.View style={[rangeStyles.knob, maxKnobStyle]} />
        </GestureDetector>
      </View>

      {/* ê°’ í‘œì‹œ */}
      <View style={rangeStyles.valuesContainer}>
        <Text style={rangeStyles.valueText}>{minValue}</Text>
        <Text style={rangeStyles.separator}>-</Text>
        <Text style={rangeStyles.valueText}>{maxValue}</Text>
      </View>
    </View>
  );
}

const rangeStyles = StyleSheet.create({
  container: {
    paddingHorizontal: 12,
  },
  trackContainer: {
    height: 40,
    justifyContent: 'center',
  },
  track: {
    height: 6,
    backgroundColor: '#E0E0E0',
    borderRadius: 3,
  },
  activeRange: {
    position: 'absolute',
    height: 6,
    backgroundColor: '#7A4AE2',
    borderRadius: 3,
  },
  knob: {
    position: 'absolute',
    width: KNOB_SIZE,
    height: KNOB_SIZE,
    borderRadius: KNOB_SIZE / 2,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
  },
  valuesContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  valueText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#7A4AE2',
  },
  separator: {
    fontSize: 16,
    color: '#888',
    marginHorizontal: 8,
  },
});
```

## ğŸ’» ë³„ì  ì„ íƒê¸°

### ê¸°ë³¸ ë³„ì 

```typescript
import React from 'react';
import { StyleSheet, View, Text, Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withSequence,
  withTiming,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

interface StarRatingProps {
  rating: number;
  onRatingChange: (rating: number) => void;
  maxStars?: number;
  size?: number;
  allowHalf?: boolean;
}

export function StarRating({
  rating,
  onRatingChange,
  maxStars = 5,
  size = 40,
  allowHalf = false,
}: StarRatingProps) {
  return (
    <View style={starStyles.container}>
      {Array.from({ length: maxStars }).map((_, index) => (
        <Star
          key={index}
          index={index}
          rating={rating}
          size={size}
          allowHalf={allowHalf}
          onPress={(value) => {
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
            onRatingChange(value);
          }}
        />
      ))}
    </View>
  );
}

function Star({
  index,
  rating,
  size,
  allowHalf,
  onPress,
}: {
  index: number;
  rating: number;
  size: number;
  allowHalf: boolean;
  onPress: (value: number) => void;
}) {
  const scale = useSharedValue(1);
  const rotation = useSharedValue(0);

  const isFilled = rating > index;
  const isHalfFilled = allowHalf && rating > index && rating < index + 1;

  const handlePress = () => {
    // ë°”ìš´ìŠ¤ + íšŒì „ íš¨ê³¼
    scale.value = withSequence(
      withTiming(1.3, { duration: 100 }),
      withSpring(1, { damping: 8, stiffness: 400 })
    );

    rotation.value = withSequence(
      withTiming(-15, { duration: 50 }),
      withTiming(15, { duration: 100 }),
      withSpring(0, { damping: 10 })
    );

    // í˜„ì¬ ë³„ì´ ì±„ì›Œì ¸ ìˆìœ¼ë©´ ì´ì „ ê°’, ì•„ë‹ˆë©´ í˜„ì¬ ê°’
    const newRating = isFilled && rating === index + 1 ? index : index + 1;
    onPress(newRating);
  };

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { scale: scale.value },
      { rotate: `${rotation.value}deg` },
    ],
  }));

  return (
    <Pressable onPress={handlePress}>
      <Animated.View style={animatedStyle}>
        <Text style={{ fontSize: size }}>
          {isHalfFilled ? 'â­ï¸' : isFilled ? 'â­' : 'â˜†'}
        </Text>
      </Animated.View>
    </Pressable>
  );
}

const starStyles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    gap: 4,
  },
});
```

### ì´ëª¨ì§€ ì„ íƒê¸°

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withSequence,
  withTiming,
  interpolate,
} from 'react-native-reanimated';

interface EmojiPickerProps {
  value: number;
  onValueChange: (value: number) => void;
  emojis?: string[];
}

const DEFAULT_EMOJIS = ['ğŸ˜¢', 'ğŸ˜•', 'ğŸ˜', 'ğŸ™‚', 'ğŸ˜Š'];

export function EmojiPicker({
  value,
  onValueChange,
  emojis = DEFAULT_EMOJIS,
}: EmojiPickerProps) {
  return (
    <View style={emojiStyles.container}>
      <View style={emojiStyles.emojiRow}>
        {emojis.map((emoji, index) => (
          <EmojiOption
            key={index}
            emoji={emoji}
            index={index}
            isSelected={value === index}
            onPress={() => {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
              onValueChange(index);
            }}
          />
        ))}
      </View>

      {/* ì„ íƒ ì¸ë””ì¼€ì´í„° */}
      <SelectionIndicator
        selectedIndex={value}
        totalCount={emojis.length}
      />
    </View>
  );
}

function EmojiOption({
  emoji,
  index,
  isSelected,
  onPress,
}: {
  emoji: string;
  index: number;
  isSelected: boolean;
  onPress: () => void;
}) {
  const scale = useSharedValue(1);
  const opacity = useSharedValue(isSelected ? 1 : 0.5);

  React.useEffect(() => {
    if (isSelected) {
      scale.value = withSequence(
        withSpring(1.3, { damping: 6, stiffness: 400 }),
        withSpring(1.1, { damping: 10, stiffness: 300 })
      );
      opacity.value = withTiming(1, { duration: 200 });
    } else {
      scale.value = withSpring(1, { damping: 15 });
      opacity.value = withTiming(0.5, { duration: 200 });
    }
  }, [isSelected]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
    opacity: opacity.value,
  }));

  return (
    <Pressable onPress={onPress}>
      <Animated.View style={[emojiStyles.emojiContainer, animatedStyle]}>
        <Text style={emojiStyles.emoji}>{emoji}</Text>
      </Animated.View>
    </Pressable>
  );
}

function SelectionIndicator({
  selectedIndex,
  totalCount,
}: {
  selectedIndex: number;
  totalCount: number;
}) {
  const translateX = useSharedValue(0);

  React.useEffect(() => {
    translateX.value = withSpring(selectedIndex * 60, {
      damping: 15,
      stiffness: 150,
    });
  }, [selectedIndex]);

  const indicatorStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <View style={emojiStyles.indicatorTrack}>
      <Animated.View style={[emojiStyles.indicator, indicatorStyle]} />
    </View>
  );
}

const emojiStyles = StyleSheet.create({
  container: {
    alignItems: 'center',
  },
  emojiRow: {
    flexDirection: 'row',
    gap: 12,
  },
  emojiContainer: {
    width: 48,
    height: 48,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emoji: {
    fontSize: 32,
  },
  indicatorTrack: {
    marginTop: 12,
    width: 48 * 5 + 12 * 4,
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
  },
  indicator: {
    width: 48,
    height: 4,
    backgroundColor: '#7A4AE2',
    borderRadius: 2,
  },
});
```

## ğŸ’» ìŠ¤í… ìŠ¬ë¼ì´ë”

### ëˆˆê¸ˆ í‘œì‹œ ìŠ¬ë¼ì´ë”

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';

interface StepSliderProps {
  value: number;
  onValueChange: (value: number) => void;
  steps: number[];
  labels?: string[];
}

export function StepSlider({
  value,
  onValueChange,
  steps,
  labels,
}: StepSliderProps) {
  const [trackLayout, setTrackLayout] = React.useState<LayoutRectangle | null>(null);
  const translateX = useSharedValue(0);
  const knobScale = useSharedValue(1);

  const currentIndex = steps.indexOf(value);
  const stepWidth = trackLayout ? trackLayout.width / (steps.length - 1) : 0;

  React.useEffect(() => {
    if (trackLayout && currentIndex >= 0) {
      translateX.value = withSpring(currentIndex * stepWidth, {
        damping: 15,
        stiffness: 200,
      });
    }
  }, [currentIndex, trackLayout]);

  const handleStepPress = (index: number) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onValueChange(steps[index]);
  };

  const panGesture = Gesture.Pan()
    .onBegin(() => {
      knobScale.value = withSpring(1.2);
    })
    .onUpdate((event) => {
      if (!trackLayout) return;

      const x = clamp(event.x, 0, trackLayout.width);
      const nearestIndex = Math.round(x / stepWidth);
      translateX.value = nearestIndex * stepWidth;

      if (nearestIndex !== currentIndex) {
        runOnJS(Haptics.impactAsync)(Haptics.ImpactFeedbackStyle.Light);
        runOnJS(onValueChange)(steps[nearestIndex]);
      }
    })
    .onEnd(() => {
      knobScale.value = withSpring(1);
    });

  const knobStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value - KNOB_SIZE / 2 },
      { scale: knobScale.value },
    ],
  }));

  return (
    <View style={stepStyles.container}>
      <GestureDetector gesture={panGesture}>
        <View
          style={stepStyles.trackContainer}
          onLayout={(e) => setTrackLayout(e.nativeEvent.layout)}
        >
          {/* íŠ¸ë™ */}
          <View style={stepStyles.track} />

          {/* ëˆˆê¸ˆ ë° ë ˆì´ë¸” */}
          {steps.map((step, index) => (
            <Pressable
              key={index}
              style={[
                stepStyles.stepContainer,
                { left: trackLayout ? index * stepWidth - 15 : 0 },
              ]}
              onPress={() => handleStepPress(index)}
            >
              <View
                style={[
                  stepStyles.tick,
                  index <= currentIndex && stepStyles.activeTick,
                ]}
              />
              {labels && (
                <Text
                  style={[
                    stepStyles.tickLabel,
                    index === currentIndex && stepStyles.activeLabel,
                  ]}
                >
                  {labels[index]}
                </Text>
              )}
            </Pressable>
          ))}

          {/* í™œì„± íŠ¸ë™ */}
          <Animated.View
            style={[
              stepStyles.activeTrack,
              { width: translateX },
            ]}
          />

          {/* ë…¸ë¸Œ */}
          <Animated.View style={[stepStyles.knob, knobStyle]} />
        </View>
      </GestureDetector>
    </View>
  );
}

const stepStyles = StyleSheet.create({
  container: {
    paddingHorizontal: 12,
  },
  trackContainer: {
    height: 60,
    justifyContent: 'center',
  },
  track: {
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
  },
  activeTrack: {
    position: 'absolute',
    left: 0,
    height: 4,
    backgroundColor: '#7A4AE2',
    borderRadius: 2,
  },
  stepContainer: {
    position: 'absolute',
    width: 30,
    alignItems: 'center',
    top: 8,
  },
  tick: {
    width: 3,
    height: 12,
    backgroundColor: '#CCCCCC',
    borderRadius: 1.5,
  },
  activeTick: {
    backgroundColor: '#7A4AE2',
  },
  tickLabel: {
    marginTop: 8,
    fontSize: 12,
    color: '#888888',
  },
  activeLabel: {
    color: '#7A4AE2',
    fontWeight: '600',
  },
  knob: {
    position: 'absolute',
    width: KNOB_SIZE,
    height: KNOB_SIZE,
    borderRadius: KNOB_SIZE / 2,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
  },
});
```

## ğŸ’» ìƒ‰ìƒ ì„ íƒê¸°

### Hue ìŠ¬ë¼ì´ë”

```typescript
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
  clamp,
} from 'react-native-reanimated';
import { LinearGradient } from 'expo-linear-gradient';

interface HueSliderProps {
  hue: number; // 0-360
  onHueChange: (hue: number) => void;
}

export function HueSlider({ hue, onHueChange }: HueSliderProps) {
  const [trackLayout, setTrackLayout] = React.useState<LayoutRectangle | null>(null);
  const translateX = useSharedValue(0);
  const knobScale = useSharedValue(1);

  React.useEffect(() => {
    if (trackLayout) {
      translateX.value = withSpring((hue / 360) * trackLayout.width, {
        damping: 15,
      });
    }
  }, [hue, trackLayout]);

  const panGesture = Gesture.Pan()
    .onBegin(() => {
      knobScale.value = withSpring(1.2);
    })
    .onUpdate((event) => {
      if (!trackLayout) return;
      const x = clamp(event.x, 0, trackLayout.width);
      translateX.value = x;
      const newHue = Math.round((x / trackLayout.width) * 360);
      runOnJS(onHueChange)(newHue);
    })
    .onEnd(() => {
      knobScale.value = withSpring(1);
    });

  const knobStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value - 14 },
      { scale: knobScale.value },
    ],
    backgroundColor: `hsl(${hue}, 100%, 50%)`,
  }));

  return (
    <View style={hueStyles.container}>
      <GestureDetector gesture={panGesture}>
        <View
          style={hueStyles.trackContainer}
          onLayout={(e) => setTrackLayout(e.nativeEvent.layout)}
        >
          <LinearGradient
            colors={[
              '#FF0000', '#FF8000', '#FFFF00', '#80FF00',
              '#00FF00', '#00FF80', '#00FFFF', '#0080FF',
              '#0000FF', '#8000FF', '#FF00FF', '#FF0080', '#FF0000',
            ]}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
            style={hueStyles.gradient}
          />

          <Animated.View style={[hueStyles.knob, knobStyle]}>
            <View style={hueStyles.knobInner} />
          </Animated.View>
        </View>
      </GestureDetector>
    </View>
  );
}

const hueStyles = StyleSheet.create({
  container: {
    paddingHorizontal: 14,
  },
  trackContainer: {
    height: 40,
    justifyContent: 'center',
  },
  gradient: {
    height: 12,
    borderRadius: 6,
  },
  knob: {
    position: 'absolute',
    width: 28,
    height: 28,
    borderRadius: 14,
    borderWidth: 3,
    borderColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 4,
    justifyContent: 'center',
    alignItems: 'center',
  },
  knobInner: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: 'white',
  },
});
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### ë‚˜ì´ ë²”ìœ„ ì„ íƒê¸°

```typescript
// src/features/matching/ui/AgeRangeSelector.tsx
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';

interface AgeRangeSelectorProps {
  minAge: number;
  maxAge: number;
  onAgeRangeChange: (min: number, max: number) => void;
}

const MIN_AGE = 20;
const MAX_AGE = 40;

export function AgeRangeSelector({
  minAge,
  maxAge,
  onAgeRangeChange,
}: AgeRangeSelectorProps) {
  return (
    <View style={ageStyles.container}>
      <View style={ageStyles.header}>
        <Text style={ageStyles.title}>ë‚˜ì´ ë²”ìœ„</Text>
        <Text style={ageStyles.value}>
          {minAge}ì„¸ ~ {maxAge}ì„¸
        </Text>
      </View>

      <RangeSlider
        minValue={minAge}
        maxValue={maxAge}
        onValuesChange={onAgeRangeChange}
        min={MIN_AGE}
        max={MAX_AGE}
        step={1}
      />

      {/* ì¶”ì²œ ë²”ìœ„ ë²„íŠ¼ */}
      <View style={ageStyles.presets}>
        <PresetButton
          label="Â±2ì„¸"
          onPress={() => {
            const mid = Math.round((minAge + maxAge) / 2);
            onAgeRangeChange(mid - 2, mid + 2);
          }}
        />
        <PresetButton
          label="Â±5ì„¸"
          onPress={() => {
            const mid = Math.round((minAge + maxAge) / 2);
            onAgeRangeChange(
              Math.max(mid - 5, MIN_AGE),
              Math.min(mid + 5, MAX_AGE)
            );
          }}
        />
        <PresetButton
          label="ì „ì²´"
          onPress={() => onAgeRangeChange(MIN_AGE, MAX_AGE)}
        />
      </View>
    </View>
  );
}

function PresetButton({
  label,
  onPress,
}: {
  label: string;
  onPress: () => void;
}) {
  const scale = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return (
    <Pressable
      onPressIn={() => (scale.value = withSpring(0.95))}
      onPressOut={() => (scale.value = withSpring(1))}
      onPress={onPress}
    >
      <Animated.View style={[ageStyles.preset, animatedStyle]}>
        <Text style={ageStyles.presetText}>{label}</Text>
      </Animated.View>
    </Pressable>
  );
}

const ageStyles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: 'white',
    borderRadius: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333333',
  },
  value: {
    fontSize: 16,
    fontWeight: '600',
    color: '#7A4AE2',
  },
  presets: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 12,
    marginTop: 16,
  },
  preset: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#F5F5F5',
  },
  presetText: {
    fontSize: 14,
    color: '#666666',
  },
});
```

### ë³„ì  ë¦¬ë·° ì…ë ¥

```typescript
// src/features/review/ui/RatingInput.tsx
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withSequence,
  withTiming,
} from 'react-native-reanimated';

interface RatingInputProps {
  rating: number;
  onRatingChange: (rating: number) => void;
  label?: string;
}

const RATING_LABELS = ['ë³„ë¡œì˜ˆìš”', 'ê·¸ì € ê·¸ë˜ìš”', 'ê´œì°®ì•„ìš”', 'ì¢‹ì•„ìš”', 'ìµœê³ ì˜ˆìš”'];

export function RatingInput({
  rating,
  onRatingChange,
  label = 'ë§Œì¡±ë„',
}: RatingInputProps) {
  const labelOpacity = useSharedValue(0);
  const labelScale = useSharedValue(0.8);

  React.useEffect(() => {
    if (rating > 0) {
      labelOpacity.value = withTiming(1, { duration: 200 });
      labelScale.value = withSequence(
        withSpring(1.1, { damping: 8 }),
        withSpring(1, { damping: 10 })
      );
    }
  }, [rating]);

  const labelStyle = useAnimatedStyle(() => ({
    opacity: labelOpacity.value,
    transform: [{ scale: labelScale.value }],
  }));

  return (
    <View style={ratingInputStyles.container}>
      <Text style={ratingInputStyles.label}>{label}</Text>

      <StarRating
        rating={rating}
        onRatingChange={onRatingChange}
        size={44}
      />

      {rating > 0 && (
        <Animated.Text style={[ratingInputStyles.ratingLabel, labelStyle]}>
          {RATING_LABELS[rating - 1]}
        </Animated.Text>
      )}
    </View>
  );
}

const ratingInputStyles = StyleSheet.create({
  container: {
    alignItems: 'center',
    padding: 20,
  },
  label: {
    fontSize: 14,
    color: '#666666',
    marginBottom: 12,
  },
  ratingLabel: {
    fontSize: 18,
    fontWeight: '600',
    color: '#7A4AE2',
    marginTop: 16,
  },
});
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ë²”ìœ„ ì²´í¬ ì—†ìŒ
const handleChange = (value: number) => {
  onValueChange(value);
};

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ë²”ìœ„ í´ë¨í•‘
const handleChange = (value: number) => {
  const clampedValue = Math.min(Math.max(value, min), max);
  onValueChange(clampedValue);
};
```

### 2. ìŠ¤í… ë°˜ì˜¬ë¦¼ ì˜¤ë¥˜

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ë¶€ë™ì†Œìˆ˜ì  ì˜¤ë¥˜
const steppedValue = Math.round(rawValue / step) * step;
// ì˜ˆ: step=0.1ì¼ ë•Œ 0.30000000000000004

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ê³ ì • ì†Œìˆ˜ì  ì²˜ë¦¬
const decimals = step.toString().split('.')[1]?.length || 0;
const steppedValue = parseFloat(
  (Math.round(rawValue / step) * step).toFixed(decimals)
);
```

### 3. ì œìŠ¤ì²˜ ì¶©ëŒ

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ìŠ¤í¬ë¡¤ê³¼ ìŠ¬ë¼ì´ë” ì œìŠ¤ì²˜ ì¶©ëŒ
<ScrollView>
  <Slider /> // ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ì‹œ ìŠ¤í¬ë¡¤ë¨
</ScrollView>

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ìˆ˜í‰/ìˆ˜ì§ ì œìŠ¤ì²˜ ë¶„ë¦¬
const panGesture = Gesture.Pan()
  .activeOffsetX([-10, 10]) // ìˆ˜í‰ 10px ì´ìƒ ì›€ì§ì—¬ì•¼ í™œì„±í™”
  .failOffsetY([-5, 5]);    // ìˆ˜ì§ 5px ì´ìƒ ì›€ì§ì´ë©´ ì‹¤íŒ¨
```

## ğŸ’¡ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. ê°’ ì—…ë°ì´íŠ¸ ìŠ¤ë¡œí‹€ë§

```typescript
const throttledUpdate = useThrottle((value: number) => {
  onValueChange(value);
}, 16); // 60fps

const handleUpdate = (value: number) => {
  // ì• ë‹ˆë©”ì´ì…˜ì€ ì¦‰ì‹œ
  translateX.value = valueToPosition(value);
  // ì½œë°±ì€ ìŠ¤ë¡œí‹€
  throttledUpdate(value);
};
```

### 2. ëˆˆê¸ˆ ë©”ëª¨ì´ì œì´ì…˜

```typescript
const ticks = React.useMemo(() =>
  steps.map((step, index) => ({
    position: index * stepWidth,
    label: labels?.[index],
    isActive: index <= currentIndex,
  })),
  [steps, stepWidth, currentIndex, labels]
);
```

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: ì˜¨ë„ ìŠ¬ë¼ì´ë”
ì˜¨ë„ë¥¼ ì„ íƒí•˜ëŠ” ìŠ¬ë¼ì´ë”ë¥¼ êµ¬í˜„í•˜ì„¸ìš”. íŒŒë€ìƒ‰(ì¶”ì›€) â†’ ë¹¨ê°„ìƒ‰(ë”ì›€) ê·¸ë¼ë””ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

### ë¬¸ì œ 2: ìˆ˜ëŸ‰ ì„ íƒê¸°
+/- ë²„íŠ¼ê³¼ ìŠ¬ë¼ì´ë”ë¥¼ ê²°í•©í•œ ìˆ˜ëŸ‰ ì„ íƒê¸°ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

### ë¬¸ì œ 3: ì‹œê°„ ë²”ìœ„ ì„ íƒê¸°
ì‹œì‘/ì¢…ë£Œ ì‹œê°„ì„ ì„ íƒí•˜ëŠ” ë²”ìœ„ ìŠ¬ë¼ì´ë”ë¥¼ êµ¬í˜„í•˜ì„¸ìš”. ì‹œê°„ í˜•ì‹(HH:MM)ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **ê¸°ë³¸ ìŠ¬ë¼ì´ë”**: ë‹¨ì¼ ê°’, íˆ´íŒ, í–…í‹± í”¼ë“œë°±
2. **ë²”ìœ„ ìŠ¬ë¼ì´ë”**: ë‘ ê°œì˜ ë…¸ë¸Œ, ìµœì†Œ/ìµœëŒ€ ê°’
3. **ë³„ì  ì„ íƒê¸°**: ë°”ìš´ìŠ¤ íš¨ê³¼, ë°˜ë³„ ì§€ì›
4. **ì´ëª¨ì§€ ì„ íƒê¸°**: ê°ì • í‘œí˜„ UI
5. **ìŠ¤í… ìŠ¬ë¼ì´ë”**: ëˆˆê¸ˆ í‘œì‹œ, ìŠ¤ëƒ…
6. **ìƒ‰ìƒ ì„ íƒê¸°**: Hue ìŠ¬ë¼ì´ë”

## ë‹¤ìŒ íŒŒíŠ¸ ì˜ˆê³ 

**Part 8: ì„±ëŠ¥ ìµœì í™”**ì—ì„œëŠ” Reanimated ì• ë‹ˆë©”ì´ì…˜ì˜ ì„±ëŠ¥ì„ ê·¹ëŒ€í™”í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤. ë©”ëª¨ë¦¬ ê´€ë¦¬, ë Œë”ë§ ìµœì í™”, í”„ë¡œíŒŒì¼ë§ ê¸°ë²• ë“±ì„ ë‹¤ë£¹ë‹ˆë‹¤.
