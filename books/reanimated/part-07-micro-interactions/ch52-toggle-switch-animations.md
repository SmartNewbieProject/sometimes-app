# Chapter 52: í† ê¸€ê³¼ ìŠ¤ìœ„ì¹˜ ì• ë‹ˆë©”ì´ì…˜

ì˜¨/ì˜¤í”„ ìƒíƒœë¥¼ ì „í™˜í•˜ëŠ” UIëŠ” ì•± ê³³ê³³ì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤. iOS ìŠ¤íƒ€ì¼ ìŠ¤ìœ„ì¹˜ë¶€í„° ì²´í¬ë°•ìŠ¤, ë¼ë””ì˜¤ ë²„íŠ¼, ì„¸ê·¸ë¨¼íŠ¸ ì»¨íŠ¸ë¡¤ê¹Œì§€ ë‹¤ì–‘í•œ í† ê¸€ ì»´í¬ë„ŒíŠ¸ì˜ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- iOS/Android ìŠ¤íƒ€ì¼ ìŠ¤ìœ„ì¹˜ êµ¬í˜„
- ì• ë‹ˆë©”ì´ì…˜ ì²´í¬ë°•ìŠ¤ì™€ ë¼ë””ì˜¤ ë²„íŠ¼
- ì„¸ê·¸ë¨¼íŠ¸ ì»¨íŠ¸ë¡¤ ì „í™˜ íš¨ê³¼
- ë‹¤í¬ ëª¨ë“œ í† ê¸€ê³¼ í…Œë§ˆ ìŠ¤ìœ„ì¹˜
- ìŠ¬ë¼ì´ë“œ í† ê¸€ê³¼ ë©€í‹° ì˜µì…˜ ì„ íƒê¸°

## ğŸ“– í† ê¸€ UX ì›ì¹™

```
í† ê¸€ ìƒíƒœ ì „í™˜ì˜ í•µì‹¬ ìš”ì†Œ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ìƒíƒœ í‘œí˜„:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ OFF                           ON           â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â•®                   â•­â”€â”€â”€â”€â”€â”€â”€â•®      â”‚
â”‚ â”‚ â—‹â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â—‹ â”‚      â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â•¯                   â•°â”€â”€â”€â”€â”€â”€â”€â•¯      â”‚
â”‚ íšŒìƒ‰ íŠ¸ë™                    ì»¬ëŸ¬ íŠ¸ë™      â”‚
â”‚ ì™¼ìª½ ë…¸ë¸Œ                    ì˜¤ë¥¸ìª½ ë…¸ë¸Œ    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

ì „í™˜ ì• ë‹ˆë©”ì´ì…˜:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. ë…¸ë¸Œ ì´ë™ (Primary)
   â—‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â—‹
   ìŠ¤í”„ë§ ì• ë‹ˆë©”ì´ì…˜ (íƒ„ì„± ìˆê²Œ)

2. ë°°ê²½ìƒ‰ ì „í™˜ (Secondary)
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â†’ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   ë¶€ë“œëŸ¬ìš´ ìƒ‰ìƒ ë³´ê°„

3. ë…¸ë¸Œ í¬ê¸° ë³€í™” (Tertiary)
   â—‹ â†’ â—¯ â†’ â—‹
   ëˆ„ë¥¼ ë•Œ ì‚´ì§ ëŠ˜ì–´ë‚¨

4. í–…í‹± í”¼ë“œë°± (Touch)
   ìƒíƒœ ì „í™˜ ì‹œ Light Impact
```

## ğŸ’» iOS ìŠ¤íƒ€ì¼ ìŠ¤ìœ„ì¹˜

### ê¸°ë³¸ ìŠ¤ìœ„ì¹˜

```typescript
import React from 'react';
import { StyleSheet, Pressable, View } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  interpolate,
  interpolateColor,
  runOnJS,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

interface SwitchProps {
  value: boolean;
  onValueChange: (value: boolean) => void;
  disabled?: boolean;
  activeColor?: string;
  inactiveColor?: string;
}

const SWITCH_WIDTH = 51;
const SWITCH_HEIGHT = 31;
const KNOB_SIZE = 27;
const KNOB_MARGIN = 2;

export function Switch({
  value,
  onValueChange,
  disabled = false,
  activeColor = '#34C759',
  inactiveColor = '#E9E9EA',
}: SwitchProps) {
  const progress = useSharedValue(value ? 1 : 0);
  const isPressed = useSharedValue(false);

  React.useEffect(() => {
    progress.value = withSpring(value ? 1 : 0, {
      damping: 15,
      stiffness: 200,
    });
  }, [value]);

  const triggerHaptic = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  const handlePress = () => {
    if (disabled) return;
    triggerHaptic();
    onValueChange(!value);
  };

  const trackStyle = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(
      progress.value,
      [0, 1],
      [inactiveColor, activeColor]
    );

    return {
      backgroundColor,
      opacity: disabled ? 0.5 : 1,
    };
  });

  const knobStyle = useAnimatedStyle(() => {
    const translateX = interpolate(
      progress.value,
      [0, 1],
      [KNOB_MARGIN, SWITCH_WIDTH - KNOB_SIZE - KNOB_MARGIN]
    );

    // ëˆŒë €ì„ ë•Œ ì•½ê°„ ëŠ˜ì–´ë‚¨
    const scaleX = isPressed.value
      ? interpolate(progress.value, [0, 0.5, 1], [1.1, 1.15, 1.1])
      : 1;

    return {
      transform: [
        { translateX },
        { scaleX },
      ],
    };
  });

  return (
    <Pressable
      onPress={handlePress}
      onPressIn={() => (isPressed.value = true)}
      onPressOut={() => (isPressed.value = false)}
      disabled={disabled}
    >
      <Animated.View style={[styles.track, trackStyle]}>
        <Animated.View style={[styles.knob, knobStyle]} />
      </Animated.View>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  track: {
    width: SWITCH_WIDTH,
    height: SWITCH_HEIGHT,
    borderRadius: SWITCH_HEIGHT / 2,
    justifyContent: 'center',
  },
  knob: {
    width: KNOB_SIZE,
    height: KNOB_SIZE,
    borderRadius: KNOB_SIZE / 2,
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },
});
```

### ì•„ì´ì½˜ ìŠ¤ìœ„ì¹˜

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  interpolate,
  interpolateColor,
} from 'react-native-reanimated';

interface IconSwitchProps {
  value: boolean;
  onValueChange: (value: boolean) => void;
  iconOff: string;
  iconOn: string;
}

export function IconSwitch({
  value,
  onValueChange,
  iconOff = 'ğŸŒ™',
  iconOn = 'â˜€ï¸',
}: IconSwitchProps) {
  const progress = useSharedValue(value ? 1 : 0);

  React.useEffect(() => {
    progress.value = withSpring(value ? 1 : 0, {
      damping: 12,
      stiffness: 150,
    });
  }, [value]);

  const trackStyle = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(
      progress.value,
      [0, 1],
      ['#1A1A2E', '#87CEEB']
    );

    return { backgroundColor };
  });

  const knobStyle = useAnimatedStyle(() => {
    const translateX = interpolate(
      progress.value,
      [0, 1],
      [4, 56 - 28 - 4]
    );

    const rotate = interpolate(progress.value, [0, 1], [0, 360]);

    return {
      transform: [
        { translateX },
        { rotate: `${rotate}deg` },
      ],
    };
  });

  const offIconStyle = useAnimatedStyle(() => ({
    opacity: interpolate(progress.value, [0, 0.5], [1, 0]),
    transform: [
      { scale: interpolate(progress.value, [0, 0.5], [1, 0.5]) },
    ],
  }));

  const onIconStyle = useAnimatedStyle(() => ({
    opacity: interpolate(progress.value, [0.5, 1], [0, 1]),
    transform: [
      { scale: interpolate(progress.value, [0.5, 1], [0.5, 1]) },
    ],
  }));

  return (
    <Pressable onPress={() => onValueChange(!value)}>
      <Animated.View style={[iconStyles.track, trackStyle]}>
        <Animated.View style={[iconStyles.knob, knobStyle]}>
          <Animated.Text style={[iconStyles.icon, offIconStyle]}>
            {iconOff}
          </Animated.Text>
          <Animated.Text style={[iconStyles.icon, iconStyles.iconAbsolute, onIconStyle]}>
            {iconOn}
          </Animated.Text>
        </Animated.View>
      </Animated.View>
    </Pressable>
  );
}

const iconStyles = StyleSheet.create({
  track: {
    width: 56,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    paddingHorizontal: 4,
  },
  knob: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
  },
  icon: {
    fontSize: 16,
  },
  iconAbsolute: {
    position: 'absolute',
  },
});
```

## ğŸ’» ì²´í¬ë°•ìŠ¤ ì• ë‹ˆë©”ì´ì…˜

### SVG ì²´í¬ë§ˆí¬ ì²´í¬ë°•ìŠ¤

```typescript
import React from 'react';
import { StyleSheet, Pressable, View, Text } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  useAnimatedStyle,
  withSpring,
  withTiming,
  withSequence,
  interpolateColor,
} from 'react-native-reanimated';
import Svg, { Path, Rect } from 'react-native-svg';
import * as Haptics from 'expo-haptics';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedRect = Animated.createAnimatedComponent(Rect);

interface CheckboxProps {
  checked: boolean;
  onToggle: (checked: boolean) => void;
  label?: string;
  size?: number;
  color?: string;
}

export function Checkbox({
  checked,
  onToggle,
  label,
  size = 24,
  color = '#7A4AE2',
}: CheckboxProps) {
  const progress = useSharedValue(checked ? 1 : 0);
  const scale = useSharedValue(1);

  const checkPath = 'M5 12l4 4 10-10';
  const pathLength = 22;

  React.useEffect(() => {
    progress.value = withSpring(checked ? 1 : 0, {
      damping: 12,
      stiffness: 200,
    });
  }, [checked]);

  const handlePress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    // ë°”ìš´ìŠ¤ íš¨ê³¼
    scale.value = withSequence(
      withTiming(0.85, { duration: 50 }),
      withSpring(1, { damping: 8, stiffness: 400 })
    );

    onToggle(!checked);
  };

  const boxProps = useAnimatedProps(() => {
    const fillOpacity = progress.value;
    const stroke = interpolateColor(
      progress.value,
      [0, 1],
      ['#CCCCCC', color]
    );

    return {
      fill: color,
      fillOpacity,
      stroke,
    };
  });

  const checkProps = useAnimatedProps(() => ({
    strokeDashoffset: pathLength * (1 - progress.value),
  }));

  const containerStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return (
    <Pressable onPress={handlePress} style={checkboxStyles.container}>
      <Animated.View style={containerStyle}>
        <Svg width={size} height={size} viewBox="0 0 24 24">
          {/* ë°•ìŠ¤ */}
          <AnimatedRect
            x="2"
            y="2"
            width="20"
            height="20"
            rx="4"
            strokeWidth="2"
            animatedProps={boxProps}
          />

          {/* ì²´í¬ë§ˆí¬ */}
          <AnimatedPath
            d={checkPath}
            stroke="white"
            strokeWidth="2.5"
            strokeLinecap="round"
            strokeLinejoin="round"
            fill="none"
            strokeDasharray={pathLength}
            animatedProps={checkProps}
          />
        </Svg>
      </Animated.View>

      {label && <Text style={checkboxStyles.label}>{label}</Text>}
    </Pressable>
  );
}

const checkboxStyles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  label: {
    fontSize: 16,
    color: '#333333',
  },
});
```

### ì›í˜• ì²´í¬ë°•ìŠ¤

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withSequence,
  withTiming,
  interpolate,
  interpolateColor,
} from 'react-native-reanimated';

export function CircleCheckbox({
  checked,
  onToggle,
  size = 28,
  color = '#7A4AE2',
}: {
  checked: boolean;
  onToggle: (checked: boolean) => void;
  size?: number;
  color?: string;
}) {
  const progress = useSharedValue(checked ? 1 : 0);
  const scale = useSharedValue(1);

  React.useEffect(() => {
    progress.value = withSpring(checked ? 1 : 0, {
      damping: 10,
      stiffness: 150,
    });
  }, [checked]);

  const handlePress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    scale.value = withSequence(
      withTiming(0.8, { duration: 50 }),
      withSpring(1, { damping: 8 })
    );
    onToggle(!checked);
  };

  const outerStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      progress.value,
      [0, 1],
      ['#CCCCCC', color]
    );
    const backgroundColor = interpolateColor(
      progress.value,
      [0, 1],
      ['transparent', color]
    );

    return {
      borderColor,
      backgroundColor,
      transform: [{ scale: scale.value }],
    };
  });

  const innerStyle = useAnimatedStyle(() => ({
    opacity: progress.value,
    transform: [
      { scale: interpolate(progress.value, [0, 1], [0, 1]) },
    ],
  }));

  return (
    <Pressable onPress={handlePress}>
      <Animated.View
        style={[
          {
            width: size,
            height: size,
            borderRadius: size / 2,
            borderWidth: 2,
            justifyContent: 'center',
            alignItems: 'center',
          },
          outerStyle,
        ]}
      >
        <Animated.View
          style={[
            {
              width: size * 0.4,
              height: size * 0.4,
              borderRadius: (size * 0.4) / 2,
              backgroundColor: 'white',
            },
            innerStyle,
          ]}
        />
      </Animated.View>
    </Pressable>
  );
}
```

## ğŸ’» ë¼ë””ì˜¤ ë²„íŠ¼

### ê¸°ë³¸ ë¼ë””ì˜¤ ë²„íŠ¼

```typescript
import React from 'react';
import { StyleSheet, View, Text, Pressable } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withSequence,
  withTiming,
  interpolate,
  interpolateColor,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

interface RadioOption {
  value: string;
  label: string;
}

interface RadioGroupProps {
  options: RadioOption[];
  value: string;
  onChange: (value: string) => void;
  color?: string;
}

export function RadioGroup({
  options,
  value,
  onChange,
  color = '#7A4AE2',
}: RadioGroupProps) {
  return (
    <View style={radioStyles.container}>
      {options.map((option) => (
        <RadioButton
          key={option.value}
          option={option}
          isSelected={value === option.value}
          onSelect={() => onChange(option.value)}
          color={color}
        />
      ))}
    </View>
  );
}

function RadioButton({
  option,
  isSelected,
  onSelect,
  color,
}: {
  option: RadioOption;
  isSelected: boolean;
  onSelect: () => void;
  color: string;
}) {
  const progress = useSharedValue(isSelected ? 1 : 0);
  const scale = useSharedValue(1);

  React.useEffect(() => {
    progress.value = withSpring(isSelected ? 1 : 0, {
      damping: 12,
      stiffness: 200,
    });
  }, [isSelected]);

  const handlePress = () => {
    if (!isSelected) {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      scale.value = withSequence(
        withTiming(0.9, { duration: 50 }),
        withSpring(1, { damping: 10 })
      );
      onSelect();
    }
  };

  const outerStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      progress.value,
      [0, 1],
      ['#CCCCCC', color]
    );

    return {
      borderColor,
      transform: [{ scale: scale.value }],
    };
  });

  const innerStyle = useAnimatedStyle(() => ({
    transform: [{ scale: progress.value }],
    opacity: progress.value,
  }));

  return (
    <Pressable onPress={handlePress} style={radioStyles.option}>
      <Animated.View style={[radioStyles.outer, outerStyle]}>
        <Animated.View
          style={[radioStyles.inner, { backgroundColor: color }, innerStyle]}
        />
      </Animated.View>
      <Text style={radioStyles.label}>{option.label}</Text>
    </Pressable>
  );
}

const radioStyles = StyleSheet.create({
  container: {
    gap: 12,
  },
  option: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingVertical: 8,
  },
  outer: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    justifyContent: 'center',
    alignItems: 'center',
  },
  inner: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  label: {
    fontSize: 16,
    color: '#333333',
  },
});
```

### ì¹´ë“œ ìŠ¤íƒ€ì¼ ë¼ë””ì˜¤

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  interpolateColor,
} from 'react-native-reanimated';

interface CardRadioGroupProps {
  options: { value: string; label: string; description?: string; icon?: string }[];
  value: string;
  onChange: (value: string) => void;
}

export function CardRadioGroup({
  options,
  value,
  onChange,
}: CardRadioGroupProps) {
  return (
    <View style={cardRadioStyles.container}>
      {options.map((option) => (
        <CardRadioButton
          key={option.value}
          option={option}
          isSelected={value === option.value}
          onSelect={() => onChange(option.value)}
        />
      ))}
    </View>
  );
}

function CardRadioButton({
  option,
  isSelected,
  onSelect,
}: {
  option: { value: string; label: string; description?: string; icon?: string };
  isSelected: boolean;
  onSelect: () => void;
}) {
  const progress = useSharedValue(isSelected ? 1 : 0);

  React.useEffect(() => {
    progress.value = withSpring(isSelected ? 1 : 0, {
      damping: 15,
      stiffness: 150,
    });
  }, [isSelected]);

  const cardStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      progress.value,
      [0, 1],
      ['#E0E0E0', '#7A4AE2']
    );
    const backgroundColor = interpolateColor(
      progress.value,
      [0, 1],
      ['#FFFFFF', '#F8F4FF']
    );
    const shadowOpacity = interpolate(progress.value, [0, 1], [0.05, 0.15]);

    return {
      borderColor,
      backgroundColor,
      borderWidth: isSelected ? 2 : 1,
      shadowOpacity,
    };
  });

  const checkStyle = useAnimatedStyle(() => ({
    opacity: progress.value,
    transform: [{ scale: progress.value }],
  }));

  return (
    <Pressable onPress={onSelect}>
      <Animated.View style={[cardRadioStyles.card, cardStyle]}>
        {option.icon && (
          <Text style={cardRadioStyles.icon}>{option.icon}</Text>
        )}

        <View style={cardRadioStyles.content}>
          <Text style={cardRadioStyles.label}>{option.label}</Text>
          {option.description && (
            <Text style={cardRadioStyles.description}>
              {option.description}
            </Text>
          )}
        </View>

        <Animated.View style={[cardRadioStyles.check, checkStyle]}>
          <Text style={cardRadioStyles.checkIcon}>âœ“</Text>
        </Animated.View>
      </Animated.View>
    </Pressable>
  );
}

const cardRadioStyles = StyleSheet.create({
  container: {
    gap: 12,
  },
  card: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 8,
    elevation: 2,
  },
  icon: {
    fontSize: 32,
    marginRight: 16,
  },
  content: {
    flex: 1,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333333',
  },
  description: {
    fontSize: 14,
    color: '#888888',
    marginTop: 4,
  },
  check: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#7A4AE2',
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkIcon: {
    color: 'white',
    fontSize: 14,
    fontWeight: 'bold',
  },
});
```

## ğŸ’» ì„¸ê·¸ë¨¼íŠ¸ ì»¨íŠ¸ë¡¤

### iOS ìŠ¤íƒ€ì¼ ì„¸ê·¸ë¨¼íŠ¸

```typescript
import React from 'react';
import { StyleSheet, View, Text, Pressable, LayoutRectangle } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

interface SegmentedControlProps {
  segments: string[];
  selectedIndex: number;
  onChange: (index: number) => void;
}

export function SegmentedControl({
  segments,
  selectedIndex,
  onChange,
}: SegmentedControlProps) {
  const [segmentLayouts, setSegmentLayouts] = React.useState<LayoutRectangle[]>([]);
  const indicatorX = useSharedValue(0);
  const indicatorWidth = useSharedValue(0);

  React.useEffect(() => {
    if (segmentLayouts[selectedIndex]) {
      const layout = segmentLayouts[selectedIndex];
      indicatorX.value = withSpring(layout.x, { damping: 15, stiffness: 150 });
      indicatorWidth.value = withSpring(layout.width, { damping: 15, stiffness: 150 });
    }
  }, [selectedIndex, segmentLayouts]);

  const indicatorStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: indicatorX.value }],
    width: indicatorWidth.value,
  }));

  const handlePress = (index: number) => {
    if (index !== selectedIndex) {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      onChange(index);
    }
  };

  return (
    <View style={segmentStyles.container}>
      {/* ë°°ê²½ ì¸ë””ì¼€ì´í„° */}
      <Animated.View style={[segmentStyles.indicator, indicatorStyle]} />

      {/* ì„¸ê·¸ë¨¼íŠ¸ ë²„íŠ¼ë“¤ */}
      {segments.map((segment, index) => (
        <Pressable
          key={segment}
          style={segmentStyles.segment}
          onPress={() => handlePress(index)}
          onLayout={(e) => {
            const layouts = [...segmentLayouts];
            layouts[index] = e.nativeEvent.layout;
            setSegmentLayouts(layouts);
          }}
        >
          <Text
            style={[
              segmentStyles.segmentText,
              selectedIndex === index && segmentStyles.selectedText,
            ]}
          >
            {segment}
          </Text>
        </Pressable>
      ))}
    </View>
  );
}

const segmentStyles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    backgroundColor: '#F2F2F7',
    borderRadius: 8,
    padding: 2,
    position: 'relative',
  },
  indicator: {
    position: 'absolute',
    top: 2,
    bottom: 2,
    backgroundColor: 'white',
    borderRadius: 7,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  segment: {
    flex: 1,
    paddingVertical: 8,
    paddingHorizontal: 16,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 1,
  },
  segmentText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666666',
  },
  selectedText: {
    color: '#000000',
  },
});
```

### ì–¸ë”ë¼ì¸ íƒ­

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';

interface TabBarProps {
  tabs: string[];
  selectedIndex: number;
  onChange: (index: number) => void;
}

export function UnderlineTabBar({
  tabs,
  selectedIndex,
  onChange,
}: TabBarProps) {
  const [tabLayouts, setTabLayouts] = React.useState<LayoutRectangle[]>([]);
  const indicatorX = useSharedValue(0);
  const indicatorWidth = useSharedValue(0);

  React.useEffect(() => {
    if (tabLayouts[selectedIndex]) {
      const layout = tabLayouts[selectedIndex];
      indicatorX.value = withSpring(layout.x, { damping: 20, stiffness: 200 });
      indicatorWidth.value = withSpring(layout.width, { damping: 20, stiffness: 200 });
    }
  }, [selectedIndex, tabLayouts]);

  const indicatorStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: indicatorX.value }],
    width: indicatorWidth.value,
  }));

  return (
    <View style={tabStyles.container}>
      <View style={tabStyles.tabsRow}>
        {tabs.map((tab, index) => (
          <Pressable
            key={tab}
            style={tabStyles.tab}
            onPress={() => {
              Haptics.selectionAsync();
              onChange(index);
            }}
            onLayout={(e) => {
              const layouts = [...tabLayouts];
              layouts[index] = e.nativeEvent.layout;
              setTabLayouts(layouts);
            }}
          >
            <TabLabel
              text={tab}
              isSelected={selectedIndex === index}
            />
          </Pressable>
        ))}
      </View>

      {/* ì–¸ë”ë¼ì¸ ì¸ë””ì¼€ì´í„° */}
      <View style={tabStyles.indicatorTrack}>
        <Animated.View style={[tabStyles.indicator, indicatorStyle]} />
      </View>
    </View>
  );
}

function TabLabel({
  text,
  isSelected,
}: {
  text: string;
  isSelected: boolean;
}) {
  const scale = useSharedValue(1);
  const color = useSharedValue(isSelected ? 1 : 0);

  React.useEffect(() => {
    scale.value = withSpring(isSelected ? 1.05 : 1, { damping: 15 });
    color.value = withSpring(isSelected ? 1 : 0, { damping: 15 });
  }, [isSelected]);

  const animatedStyle = useAnimatedStyle(() => {
    const textColor = interpolateColor(
      color.value,
      [0, 1],
      ['#888888', '#7A4AE2']
    );

    return {
      transform: [{ scale: scale.value }],
      color: textColor,
    };
  });

  return (
    <Animated.Text style={[tabStyles.tabText, animatedStyle]}>
      {text}
    </Animated.Text>
  );
}

const tabStyles = StyleSheet.create({
  container: {
    backgroundColor: 'white',
  },
  tabsRow: {
    flexDirection: 'row',
  },
  tab: {
    flex: 1,
    paddingVertical: 16,
    alignItems: 'center',
  },
  tabText: {
    fontSize: 15,
    fontWeight: '600',
  },
  indicatorTrack: {
    height: 3,
    backgroundColor: '#F0F0F0',
  },
  indicator: {
    height: 3,
    backgroundColor: '#7A4AE2',
    borderRadius: 1.5,
  },
});
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### ì„¤ì • í† ê¸€ ëª©ë¡

```typescript
// src/features/setting/ui/SettingsToggles.tsx
import React from 'react';
import { StyleSheet, View, Text, ScrollView } from 'react-native';
import Animated, {
  useAnimatedStyle,
  withSpring,
  FadeIn,
  Layout,
} from 'react-native-reanimated';

interface SettingItem {
  key: string;
  title: string;
  description?: string;
  icon: string;
  value: boolean;
}

interface SettingsTogglesProps {
  settings: SettingItem[];
  onToggle: (key: string, value: boolean) => void;
}

export function SettingsToggles({
  settings,
  onToggle,
}: SettingsTogglesProps) {
  return (
    <ScrollView style={settingStyles.container}>
      <View style={settingStyles.section}>
        <Text style={settingStyles.sectionTitle}>ì•Œë¦¼ ì„¤ì •</Text>

        {settings.map((setting, index) => (
          <SettingToggleItem
            key={setting.key}
            setting={setting}
            onToggle={(value) => onToggle(setting.key, value)}
            index={index}
          />
        ))}
      </View>
    </ScrollView>
  );
}

function SettingToggleItem({
  setting,
  onToggle,
  index,
}: {
  setting: SettingItem;
  onToggle: (value: boolean) => void;
  index: number;
}) {
  const opacity = useSharedValue(0);
  const translateY = useSharedValue(20);

  React.useEffect(() => {
    opacity.value = withSpring(1, { delay: index * 50 });
    translateY.value = withSpring(0, { delay: index * 50, damping: 15 });
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ translateY: translateY.value }],
  }));

  return (
    <Animated.View
      style={[settingStyles.item, animatedStyle]}
      layout={Layout.springify()}
    >
      <View style={settingStyles.iconContainer}>
        <Text style={settingStyles.icon}>{setting.icon}</Text>
      </View>

      <View style={settingStyles.content}>
        <Text style={settingStyles.title}>{setting.title}</Text>
        {setting.description && (
          <Text style={settingStyles.description}>
            {setting.description}
          </Text>
        )}
      </View>

      <Switch
        value={setting.value}
        onValueChange={onToggle}
        activeColor="#7A4AE2"
      />
    </Animated.View>
  );
}

const settingStyles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8F8F8',
  },
  section: {
    backgroundColor: 'white',
    marginTop: 16,
    borderRadius: 12,
    marginHorizontal: 16,
    overflow: 'hidden',
  },
  sectionTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: '#888888',
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 8,
    textTransform: 'uppercase',
  },
  item: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 8,
    backgroundColor: '#F5F5F5',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  icon: {
    fontSize: 20,
  },
  content: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333333',
  },
  description: {
    fontSize: 13,
    color: '#888888',
    marginTop: 2,
  },
});
```

### í•„í„° ì„ íƒ ì„¸ê·¸ë¨¼íŠ¸

```typescript
// src/features/matching/ui/FilterSegments.tsx
import React from 'react';
import { StyleSheet, View, Text } from 'react-native';

interface FilterSegmentsProps {
  ageRange: '20s' | '30s' | 'all';
  onAgeRangeChange: (range: '20s' | '30s' | 'all') => void;
  distance: 'near' | 'mid' | 'far';
  onDistanceChange: (distance: 'near' | 'mid' | 'far') => void;
}

export function FilterSegments({
  ageRange,
  onAgeRangeChange,
  distance,
  onDistanceChange,
}: FilterSegmentsProps) {
  const ageSegments = ['20ëŒ€', '30ëŒ€', 'ì „ì²´'];
  const ageValues: ('20s' | '30s' | 'all')[] = ['20s', '30s', 'all'];

  const distanceSegments = ['ê°€ê¹Œìš´', 'ë³´í†µ', 'ë¨¼'];
  const distanceValues: ('near' | 'mid' | 'far')[] = ['near', 'mid', 'far'];

  return (
    <View style={filterStyles.container}>
      <View style={filterStyles.filterGroup}>
        <Text style={filterStyles.label}>ì—°ë ¹ëŒ€</Text>
        <SegmentedControl
          segments={ageSegments}
          selectedIndex={ageValues.indexOf(ageRange)}
          onChange={(index) => onAgeRangeChange(ageValues[index])}
        />
      </View>

      <View style={filterStyles.filterGroup}>
        <Text style={filterStyles.label}>ê±°ë¦¬</Text>
        <SegmentedControl
          segments={distanceSegments}
          selectedIndex={distanceValues.indexOf(distance)}
          onChange={(index) => onDistanceChange(distanceValues[index])}
        />
      </View>
    </View>
  );
}

const filterStyles = StyleSheet.create({
  container: {
    padding: 16,
    gap: 20,
  },
  filterGroup: {
    gap: 8,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#666666',
  },
});
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. í† ê¸€ ìƒíƒœì™€ UI ë¶ˆì¼ì¹˜

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ë¡œì»¬ ìƒíƒœì™€ prop ë¶„ë¦¬
function Switch({ value, onValueChange }) {
  const [localValue, setLocalValue] = useState(value);

  const handlePress = () => {
    setLocalValue(!localValue); // UIë§Œ ë³€ê²½
    onValueChange(!localValue); // ì‹¤ì œ ìƒíƒœ ë³€ê²½
  };
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: prop ê°’ì„ ì§ì ‘ ì‚¬ìš©
function Switch({ value, onValueChange }) {
  // valueê°€ ë³€ê²½ë˜ë©´ ì• ë‹ˆë©”ì´ì…˜ë„ ìë™ ì—…ë°ì´íŠ¸
  React.useEffect(() => {
    progress.value = withSpring(value ? 1 : 0);
  }, [value]);

  const handlePress = () => {
    onValueChange(!value);
  };
}
```

### 2. ë‹¤ì¤‘ ì„ íƒ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ì¶©ëŒ

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ê° í•­ëª©ì´ ë…ë¦½ì ìœ¼ë¡œ ë ˆì´ì•„ì›ƒ ì• ë‹ˆë©”ì´ì…˜
{items.map(item => (
  <Animated.View layout={Layout.springify()}>
    <Checkbox checked={selected.includes(item.id)} />
  </Animated.View>
))}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì»¨í…Œì´ë„ˆ ë ˆë²¨ì—ì„œ ë ˆì´ì•„ì›ƒ ê´€ë¦¬
<Animated.View layout={Layout.springify()}>
  {items.map(item => (
    <Checkbox
      key={item.id}
      checked={selected.includes(item.id)}
    />
  ))}
</Animated.View>
```

### 3. ì„¸ê·¸ë¨¼íŠ¸ ë ˆì´ì•„ì›ƒ ì¸¡ì • íƒ€ì´ë°

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ì²« ë Œë”ì—ì„œ ë ˆì´ì•„ì›ƒì´ ì—†ìŒ
const indicatorStyle = useAnimatedStyle(() => ({
  left: segmentLayouts[selectedIndex]?.x || 0, // undefinedì¼ ìˆ˜ ìˆìŒ
}));

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ë ˆì´ì•„ì›ƒ ì¤€ë¹„ í™•ì¸
const indicatorStyle = useAnimatedStyle(() => {
  if (!segmentLayouts[selectedIndex]) {
    return { opacity: 0 }; // ë ˆì´ì•„ì›ƒ ì „ì—ëŠ” ìˆ¨ê¹€
  }

  return {
    opacity: 1,
    transform: [{ translateX: indicatorX.value }],
    width: indicatorWidth.value,
  };
});
```

## ğŸ’¡ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. í† ê¸€ ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜

```typescript
export const MemoizedSwitch = React.memo(Switch, (prev, next) => {
  return (
    prev.value === next.value &&
    prev.disabled === next.disabled
  );
});
```

### 2. ë ˆì´ì•„ì›ƒ ì¸¡ì • ìµœì í™”

```typescript
// ë ˆì´ì•„ì›ƒ ì¸¡ì •ì„ í•œ ë²ˆë§Œ ìˆ˜í–‰
const [measured, setMeasured] = useState(false);
const layouts = useRef<LayoutRectangle[]>([]);

const handleLayout = (index: number, layout: LayoutRectangle) => {
  if (!measured) {
    layouts.current[index] = layout;
    if (layouts.current.length === segments.length) {
      setMeasured(true);
    }
  }
};
```

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: ë©€í‹° í† ê¸€
í•œ ì¤„ì— ì—¬ëŸ¬ ì˜µì…˜ì„ ì„ íƒí•  ìˆ˜ ìˆëŠ” í† ê¸€ ê·¸ë£¹ì„ êµ¬í˜„í•˜ì„¸ìš” (ì˜ˆ: "ì›” í™” ìˆ˜ ëª© ê¸ˆ í†  ì¼" ì„ íƒ).

### ë¬¸ì œ 2: ìŠ¬ë¼ì´ë“œ í† ê¸€
ì¢Œìš°ë¡œ ìŠ¬ë¼ì´ë“œí•´ì„œ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” í† ê¸€ì„ êµ¬í˜„í•˜ì„¸ìš”. ë“œë˜ê·¸ ì¤‘ê°„ì— ë†“ìœ¼ë©´ ê°€ê¹Œìš´ ìƒíƒœë¡œ ìŠ¤ëƒ…ë©ë‹ˆë‹¤.

### ë¬¸ì œ 3: 3ë‹¨ê³„ ìŠ¤ìœ„ì¹˜
OFF â†’ MEDIUM â†’ HIGH 3ë‹¨ê³„ë¡œ ì „í™˜ë˜ëŠ” ìŠ¤ìœ„ì¹˜ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **ìŠ¤ìœ„ì¹˜**: iOS ìŠ¤íƒ€ì¼, ì•„ì´ì½˜ ìŠ¤ìœ„ì¹˜
2. **ì²´í¬ë°•ìŠ¤**: SVG ì²´í¬ë§ˆí¬, ì›í˜• ì²´í¬ë°•ìŠ¤
3. **ë¼ë””ì˜¤ ë²„íŠ¼**: ê¸°ë³¸, ì¹´ë“œ ìŠ¤íƒ€ì¼
4. **ì„¸ê·¸ë¨¼íŠ¸**: ìŠ¬ë¼ì´ë”© ì¸ë””ì¼€ì´í„°, ì–¸ë”ë¼ì¸ íƒ­
5. **ì• ë‹ˆë©”ì´ì…˜**: ìŠ¤í”„ë§ ì „í™˜, ìƒ‰ìƒ ë³´ê°„
6. **í–…í‹±**: ìƒíƒœ ì „í™˜ ì‹œ ì´‰ê° í”¼ë“œë°±

## ë‹¤ìŒ ì¥ ì˜ˆê³ 

**Chapter 53: ì•Œë¦¼ ë°°ì§€ì™€ ì¸ë””ì¼€ì´í„°**ì—ì„œëŠ” ìƒˆë¡œìš´ ì•Œë¦¼ì„ ì•Œë ¤ì£¼ëŠ” ë°°ì§€, ì½ì§€ ì•Šì€ ë©”ì‹œì§€ ì¹´ìš´í„°, ì˜¨ë¼ì¸ ìƒíƒœ í‘œì‹œ ë“± ìƒíƒœ ì¸ë””ì¼€ì´í„° ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
