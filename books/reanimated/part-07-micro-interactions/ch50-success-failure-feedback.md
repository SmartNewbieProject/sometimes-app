# Chapter 50: ì„±ê³µ/ì‹¤íŒ¨ í”¼ë“œë°± ì• ë‹ˆë©”ì´ì…˜

ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ì‚¬ìš©ìì—ê²Œ ëª…í™•í•œ ê²°ê³¼ë¥¼ ì•Œë ¤ì£¼ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ì„±ê³µì˜ ê¸°ì¨ì„ ë°°ê°€ì‹œí‚¤ê³  ì‹¤íŒ¨ì˜ ì¢Œì ˆê°ì„ ì¤„ì´ëŠ” í”¼ë“œë°± ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

- ì„±ê³µ/ì‹¤íŒ¨ í”¼ë“œë°±ì˜ ì‹¬ë¦¬í•™ ì´í•´
- ì²´í¬ë§ˆí¬ ë“œë¡œì‰ ì• ë‹ˆë©”ì´ì…˜
- X ë§ˆí¬ ë° ì—ëŸ¬ í”ë“¤ê¸° íš¨ê³¼
- í† ìŠ¤íŠ¸ ë° ìŠ¤ë‚µë°” ì• ë‹ˆë©”ì´ì…˜
- Confetti ë° ì¶•í•˜ íš¨ê³¼
- ìƒíƒœ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜

## ğŸ“– í”¼ë“œë°± ë””ìì¸ ì›ì¹™

```
ì„±ê³µê³¼ ì‹¤íŒ¨ í”¼ë“œë°±ì˜ ì‹¬ë¦¬í•™
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ì„±ê³µ í”¼ë“œë°±:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ âœ“ ëª…í™•í•˜ê³  ê¸ì •ì ì¸ ì‹œê° ì‹ í˜¸              â”‚
â”‚ âœ“ ì ì ˆí•œ ì¶•í•˜ (ê³¼í•˜ì§€ ì•Šê²Œ)                â”‚
â”‚ âœ“ ë‹¤ìŒ í–‰ë™ìœ¼ë¡œ ìì—°ìŠ¤ëŸ¬ìš´ ìœ ë„            â”‚
â”‚ âœ“ í–…í‹± í”¼ë“œë°± ë™ë°˜ (Success)               â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

ì‹¤íŒ¨ í”¼ë“œë°±:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ âœ• ë¹„ë‚œí•˜ì§€ ì•ŠëŠ” í†¤                         â”‚
â”‚ âœ• ë¬¸ì œì™€ í•´ê²°ì±… í•¨ê»˜ ì œì‹œ                  â”‚
â”‚ âœ• ë¹¨ê°„ìƒ‰ë§Œ ì‚¬ìš©í•˜ì§€ ë§ ê²ƒ (ìƒ‰ë§¹ ê³ ë ¤)      â”‚
â”‚ âœ• í”ë“¤ë¦¼ìœ¼ë¡œ ì£¼ì˜ ëŒê¸°                     â”‚
â”‚ âœ• ì¬ì‹œë„ ì˜µì…˜ ì œê³µ                         â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

í”¼ë“œë°± íƒ€ì´ë°:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  ì•¡ì…˜ ì™„ë£Œ        í”¼ë“œë°± ì‹œì‘       ìë™ ë‹«ê¸°
       â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â—
       0ms          100ms    2-3ì´ˆ í›„ (ì„ íƒ)

       â”‚             â”‚               â”‚
       â–¼             â–¼               â–¼
    ì¦‰ê°ì         ì• ë‹ˆë©”ì´ì…˜      ì‚¬ë¼ì§
    ì‘ë‹µ         ì¬ìƒ ì‹œì‘      (í•„ìš”ì‹œ)
```

## ğŸ’» ì²´í¬ë§ˆí¬ ì• ë‹ˆë©”ì´ì…˜

### SVG íŒ¨ìŠ¤ ë“œë¡œì‰ ì²´í¬ë§ˆí¬

```typescript
import React from 'react';
import { StyleSheet, View } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  withDelay,
  withSequence,
  withSpring,
  Easing,
  runOnJS,
} from 'react-native-reanimated';
import Svg, { Path, Circle } from 'react-native-svg';
import * as Haptics from 'expo-haptics';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface CheckmarkAnimationProps {
  size?: number;
  color?: string;
  backgroundColor?: string;
  onComplete?: () => void;
}

export function CheckmarkAnimation({
  size = 80,
  color = 'white',
  backgroundColor = '#4CAF50',
  onComplete,
}: CheckmarkAnimationProps) {
  const circleScale = useSharedValue(0);
  const checkProgress = useSharedValue(0);

  const checkPath = 'M 25 50 L 40 65 L 70 35';
  const checkPathLength = 70; // ëŒ€ëµì ì¸ ê²½ë¡œ ê¸¸ì´

  React.useEffect(() => {
    // 1. ì› í™•ëŒ€
    circleScale.value = withSpring(1, {
      damping: 12,
      stiffness: 200,
    });

    // 2. ì²´í¬ë§ˆí¬ ê·¸ë¦¬ê¸° (ë”œë ˆì´ í›„)
    checkProgress.value = withDelay(
      200,
      withTiming(1, {
        duration: 400,
        easing: Easing.out(Easing.ease),
      })
    );

    // í–…í‹± í”¼ë“œë°±
    setTimeout(() => {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      onComplete?.();
    }, 600);
  }, []);

  const circleStyle = useAnimatedProps(() => ({
    transform: [{ scale: circleScale.value }],
  }));

  const checkProps = useAnimatedProps(() => ({
    strokeDashoffset: checkPathLength * (1 - checkProgress.value),
  }));

  return (
    <View style={[styles.container, { width: size, height: size }]}>
      <Svg width={size} height={size} viewBox="0 0 100 100">
        {/* ë°°ê²½ ì› */}
        <AnimatedCircle
          cx="50"
          cy="50"
          r="45"
          fill={backgroundColor}
          animatedProps={circleStyle}
        />

        {/* ì²´í¬ë§ˆí¬ */}
        <AnimatedPath
          d={checkPath}
          stroke={color}
          strokeWidth="8"
          strokeLinecap="round"
          strokeLinejoin="round"
          fill="none"
          strokeDasharray={checkPathLength}
          animatedProps={checkProps}
        />
      </Svg>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

### ë°”ìš´ìŠ¤ ì²´í¬ë§ˆí¬

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSequence,
  withSpring,
  withDelay,
  withTiming,
} from 'react-native-reanimated';

export function BounceCheckmark({
  size = 80,
}: {
  size?: number;
}) {
  const scale = useSharedValue(0);
  const checkScale = useSharedValue(0);
  const rotation = useSharedValue(-45);

  React.useEffect(() => {
    // ì› ë“±ì¥ (ë°”ìš´ìŠ¤)
    scale.value = withSequence(
      withSpring(1.2, { damping: 6, stiffness: 300 }),
      withSpring(1, { damping: 8, stiffness: 200 })
    );

    // ì²´í¬ë§ˆí¬ ë“±ì¥ (ë”œë ˆì´)
    checkScale.value = withDelay(
      150,
      withSequence(
        withSpring(1.3, { damping: 4, stiffness: 400 }),
        withSpring(1, { damping: 6, stiffness: 300 })
      )
    );

    // ì‚´ì§ íšŒì „
    rotation.value = withDelay(
      150,
      withSequence(
        withTiming(-15, { duration: 150 }),
        withSpring(0, { damping: 10 })
      )
    );
  }, []);

  const containerStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const checkStyle = useAnimatedStyle(() => ({
    transform: [
      { scale: checkScale.value },
      { rotate: `${rotation.value}deg` },
    ],
  }));

  return (
    <Animated.View style={[styles.bounceContainer, { width: size, height: size }, containerStyle]}>
      <View style={[styles.circle, { backgroundColor: '#4CAF50' }]}>
        <Animated.Text style={[styles.checkText, { fontSize: size * 0.5 }, checkStyle]}>
          âœ“
        </Animated.Text>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  bounceContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  circle: {
    width: '100%',
    height: '100%',
    borderRadius: 1000,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkText: {
    color: 'white',
    fontWeight: 'bold',
  },
});
```

## ğŸ’» ì‹¤íŒ¨/ì—ëŸ¬ ì• ë‹ˆë©”ì´ì…˜

### X ë§ˆí¬ ì• ë‹ˆë©”ì´ì…˜

```typescript
import Svg, { Path, Circle } from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  withDelay,
  withSequence,
  withSpring,
  Easing,
} from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);

export function XMarkAnimation({
  size = 80,
  color = 'white',
  backgroundColor = '#F44336',
}: {
  size?: number;
  color?: string;
  backgroundColor?: string;
}) {
  const circleScale = useSharedValue(0);
  const line1Progress = useSharedValue(0);
  const line2Progress = useSharedValue(0);
  const shake = useSharedValue(0);

  const line1Path = 'M 30 30 L 70 70';
  const line2Path = 'M 70 30 L 30 70';
  const lineLength = 57; // âˆš((70-30)Â² + (70-30)Â²)

  React.useEffect(() => {
    // ì› ë“±ì¥
    circleScale.value = withSpring(1, { damping: 12, stiffness: 200 });

    // X ì²« ë²ˆì§¸ ì„ 
    line1Progress.value = withDelay(
      200,
      withTiming(1, { duration: 200, easing: Easing.out(Easing.ease) })
    );

    // X ë‘ ë²ˆì§¸ ì„ 
    line2Progress.value = withDelay(
      350,
      withTiming(1, { duration: 200, easing: Easing.out(Easing.ease) })
    );

    // í”ë“¤ê¸° íš¨ê³¼
    shake.value = withDelay(
      500,
      withSequence(
        withTiming(-8, { duration: 50 }),
        withTiming(8, { duration: 100 }),
        withTiming(-6, { duration: 100 }),
        withTiming(6, { duration: 100 }),
        withTiming(0, { duration: 50 })
      )
    );

    // í–…í‹±
    setTimeout(() => {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    }, 500);
  }, []);

  const containerStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: shake.value }],
  }));

  const circleProps = useAnimatedProps(() => ({
    transform: [{ scale: circleScale.value }],
  }));

  const line1Props = useAnimatedProps(() => ({
    strokeDashoffset: lineLength * (1 - line1Progress.value),
  }));

  const line2Props = useAnimatedProps(() => ({
    strokeDashoffset: lineLength * (1 - line2Progress.value),
  }));

  return (
    <Animated.View style={[{ width: size, height: size }, containerStyle]}>
      <Svg width={size} height={size} viewBox="0 0 100 100">
        <AnimatedCircle
          cx="50"
          cy="50"
          r="45"
          fill={backgroundColor}
          animatedProps={circleProps}
        />
        <AnimatedPath
          d={line1Path}
          stroke={color}
          strokeWidth="8"
          strokeLinecap="round"
          fill="none"
          strokeDasharray={lineLength}
          animatedProps={line1Props}
        />
        <AnimatedPath
          d={line2Path}
          stroke={color}
          strokeWidth="8"
          strokeLinecap="round"
          fill="none"
          strokeDasharray={lineLength}
          animatedProps={line2Props}
        />
      </Svg>
    </Animated.View>
  );
}
```

### ì…ë ¥ í•„ë“œ ì—ëŸ¬ í”ë“¤ê¸°

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSequence,
  withTiming,
  withSpring,
} from 'react-native-reanimated';

interface ShakeInputProps {
  children: React.ReactNode;
  error?: boolean;
}

export function ShakeInput({ children, error }: ShakeInputProps) {
  const shake = useSharedValue(0);
  const borderColor = useSharedValue(0);

  React.useEffect(() => {
    if (error) {
      // í”ë“¤ê¸°
      shake.value = withSequence(
        withTiming(-10, { duration: 50 }),
        withTiming(10, { duration: 100 }),
        withTiming(-8, { duration: 100 }),
        withTiming(8, { duration: 100 }),
        withTiming(-4, { duration: 100 }),
        withTiming(0, { duration: 50 })
      );

      // í…Œë‘ë¦¬ ìƒ‰ìƒ
      borderColor.value = withSequence(
        withTiming(1, { duration: 100 }),
        withTiming(1, { duration: 2000 }), // ìœ ì§€
        withTiming(0, { duration: 300 })
      );

      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
    }
  }, [error]);

  const animatedStyle = useAnimatedStyle(() => {
    const borderColorValue = interpolateColor(
      borderColor.value,
      [0, 1],
      ['#E0E0E0', '#F44336']
    );

    return {
      transform: [{ translateX: shake.value }],
      borderColor: borderColorValue,
    };
  });

  return (
    <Animated.View style={[styles.inputContainer, animatedStyle]}>
      {children}
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  inputContainer: {
    borderWidth: 2,
    borderRadius: 8,
    overflow: 'hidden',
  },
});
```

### í¼ í•„ë“œ ì—ëŸ¬ ìƒíƒœ

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  withSequence,
  interpolateColor,
  Layout,
  FadeIn,
  FadeOut,
} from 'react-native-reanimated';

interface FormFieldProps {
  label: string;
  error?: string;
  children: React.ReactNode;
}

export function FormField({ label, error, children }: FormFieldProps) {
  const errorOpacity = useSharedValue(0);
  const shake = useSharedValue(0);
  const borderProgress = useSharedValue(0);

  React.useEffect(() => {
    if (error) {
      errorOpacity.value = withTiming(1, { duration: 200 });
      borderProgress.value = withTiming(1, { duration: 200 });
      shake.value = withSequence(
        withTiming(-6, { duration: 40 }),
        withTiming(6, { duration: 80 }),
        withTiming(-4, { duration: 80 }),
        withTiming(4, { duration: 80 }),
        withTiming(0, { duration: 40 })
      );
    } else {
      errorOpacity.value = withTiming(0, { duration: 200 });
      borderProgress.value = withTiming(0, { duration: 200 });
    }
  }, [error]);

  const containerStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: shake.value }],
  }));

  const borderStyle = useAnimatedStyle(() => {
    const borderColor = interpolateColor(
      borderProgress.value,
      [0, 1],
      ['#E0E0E0', '#F44336']
    );

    return { borderColor };
  });

  const labelStyle = useAnimatedStyle(() => {
    const color = interpolateColor(
      borderProgress.value,
      [0, 1],
      ['#666666', '#F44336']
    );

    return { color };
  });

  return (
    <Animated.View style={[styles.fieldContainer, containerStyle]}>
      <Animated.Text style={[styles.label, labelStyle]}>
        {label}
      </Animated.Text>

      <Animated.View style={[styles.inputWrapper, borderStyle]}>
        {children}
      </Animated.View>

      {error && (
        <Animated.Text
          entering={FadeIn.duration(200)}
          exiting={FadeOut.duration(200)}
          style={styles.errorText}
        >
          {error}
        </Animated.Text>
      )}
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  fieldContainer: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    marginBottom: 6,
  },
  inputWrapper: {
    borderWidth: 2,
    borderRadius: 8,
    overflow: 'hidden',
  },
  errorText: {
    color: '#F44336',
    fontSize: 12,
    marginTop: 4,
  },
});
```

## ğŸ’» í† ìŠ¤íŠ¸ ì• ë‹ˆë©”ì´ì…˜

### ê¸°ë³¸ í† ìŠ¤íŠ¸

```typescript
import React from 'react';
import { StyleSheet, View, Text, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  withDelay,
  runOnJS,
  SlideInUp,
  SlideOutUp,
} from 'react-native-reanimated';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const { width } = Dimensions.get('window');

type ToastType = 'success' | 'error' | 'warning' | 'info';

interface Toast {
  id: string;
  type: ToastType;
  message: string;
  duration?: number;
}

interface ToastContextValue {
  showToast: (toast: Omit<Toast, 'id'>) => void;
}

const ToastContext = React.createContext<ToastContextValue | null>(null);

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = React.useState<Toast[]>([]);
  const insets = useSafeAreaInsets();

  const showToast = React.useCallback((toast: Omit<Toast, 'id'>) => {
    const id = Date.now().toString();
    const newToast = { ...toast, id };

    setToasts((prev) => [...prev, newToast]);

    // ìë™ ì œê±°
    setTimeout(() => {
      setToasts((prev) => prev.filter((t) => t.id !== id));
    }, toast.duration || 3000);
  }, []);

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}

      {/* í† ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ */}
      <View style={[styles.toastContainer, { top: insets.top + 10 }]}>
        {toasts.map((toast) => (
          <ToastItem key={toast.id} toast={toast} />
        ))}
      </View>
    </ToastContext.Provider>
  );
}

function ToastItem({ toast }: { toast: Toast }) {
  const config = getToastConfig(toast.type);

  return (
    <Animated.View
      entering={SlideInUp.springify().damping(15)}
      exiting={SlideOutUp.duration(200)}
      style={[styles.toast, { backgroundColor: config.backgroundColor }]}
    >
      <Text style={styles.toastIcon}>{config.icon}</Text>
      <Text style={[styles.toastMessage, { color: config.textColor }]}>
        {toast.message}
      </Text>
    </Animated.View>
  );
}

function getToastConfig(type: ToastType) {
  switch (type) {
    case 'success':
      return {
        backgroundColor: '#E8F5E9',
        textColor: '#2E7D32',
        icon: 'âœ“',
      };
    case 'error':
      return {
        backgroundColor: '#FFEBEE',
        textColor: '#C62828',
        icon: 'âœ•',
      };
    case 'warning':
      return {
        backgroundColor: '#FFF8E1',
        textColor: '#F57F17',
        icon: 'âš ',
      };
    case 'info':
    default:
      return {
        backgroundColor: '#E3F2FD',
        textColor: '#1565C0',
        icon: 'â„¹',
      };
  }
}

export function useToast() {
  const context = React.useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}

const styles = StyleSheet.create({
  toastContainer: {
    position: 'absolute',
    left: 16,
    right: 16,
    alignItems: 'center',
    gap: 8,
    zIndex: 1000,
  },
  toast: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    width: '100%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  toastIcon: {
    fontSize: 18,
    marginRight: 12,
  },
  toastMessage: {
    flex: 1,
    fontSize: 14,
    fontWeight: '500',
  },
});
```

### ìŠ¤ì™€ì´í”„ ê°€ëŠ¥í•œ í† ìŠ¤íŠ¸

```typescript
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  runOnJS,
  interpolate,
  Extrapolation,
} from 'react-native-reanimated';

interface SwipeableToastProps {
  toast: Toast;
  onDismiss: (id: string) => void;
}

function SwipeableToast({ toast, onDismiss }: SwipeableToastProps) {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(-100);
  const opacity = useSharedValue(1);
  const config = getToastConfig(toast.type);

  React.useEffect(() => {
    // ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜
    translateY.value = withSpring(0, { damping: 15, stiffness: 150 });
  }, []);

  const dismiss = () => {
    onDismiss(toast.id);
  };

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      translateX.value = event.translationX;
      translateY.value = Math.min(event.translationY, 0);
    })
    .onEnd((event) => {
      const shouldDismissX = Math.abs(event.translationX) > 100;
      const shouldDismissY = event.translationY < -50;

      if (shouldDismissX || shouldDismissY) {
        // ìŠ¤ì™€ì´í”„ ë°©í–¥ìœ¼ë¡œ ì‚¬ë¼ì§
        if (shouldDismissX) {
          translateX.value = withTiming(
            event.translationX > 0 ? 400 : -400,
            { duration: 200 }
          );
        }
        if (shouldDismissY) {
          translateY.value = withTiming(-100, { duration: 200 });
        }
        opacity.value = withTiming(0, { duration: 200 });

        setTimeout(() => runOnJS(dismiss)(), 200);
      } else {
        // ì›ìœ„ì¹˜ ë³µê·€
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
      }
    });

  const animatedStyle = useAnimatedStyle(() => {
    const scale = interpolate(
      Math.abs(translateX.value),
      [0, 100],
      [1, 0.9],
      Extrapolation.CLAMP
    );

    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { scale },
      ],
      opacity: opacity.value,
    };
  });

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View
        style={[
          styles.toast,
          { backgroundColor: config.backgroundColor },
          animatedStyle,
        ]}
      >
        <Text style={styles.toastIcon}>{config.icon}</Text>
        <Text style={[styles.toastMessage, { color: config.textColor }]}>
          {toast.message}
        </Text>
      </Animated.View>
    </GestureDetector>
  );
}
```

## ğŸ’» ì¶•í•˜ íš¨ê³¼

### Confetti ì• ë‹ˆë©”ì´ì…˜

```typescript
import React from 'react';
import { StyleSheet, View, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withDelay,
  withRepeat,
  withSequence,
  Easing,
  runOnJS,
} from 'react-native-reanimated';

const { width, height } = Dimensions.get('window');

const CONFETTI_COLORS = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
  '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
];

interface ConfettiPiece {
  id: number;
  x: number;
  delay: number;
  color: string;
  size: number;
  rotationSpeed: number;
}

interface ConfettiProps {
  count?: number;
  duration?: number;
  onComplete?: () => void;
}

export function Confetti({
  count = 50,
  duration = 3000,
  onComplete,
}: ConfettiProps) {
  const pieces = React.useMemo(() => {
    return Array.from({ length: count }).map((_, index) => ({
      id: index,
      x: Math.random() * width,
      delay: Math.random() * 500,
      color: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
      size: 8 + Math.random() * 8,
      rotationSpeed: 2 + Math.random() * 4,
    }));
  }, [count]);

  React.useEffect(() => {
    const timer = setTimeout(() => {
      onComplete?.();
    }, duration + 500);

    return () => clearTimeout(timer);
  }, [duration, onComplete]);

  return (
    <View style={StyleSheet.absoluteFill} pointerEvents="none">
      {pieces.map((piece) => (
        <ConfettiPieceComponent key={piece.id} piece={piece} duration={duration} />
      ))}
    </View>
  );
}

function ConfettiPieceComponent({
  piece,
  duration,
}: {
  piece: ConfettiPiece;
  duration: number;
}) {
  const translateY = useSharedValue(-50);
  const translateX = useSharedValue(0);
  const rotation = useSharedValue(0);
  const opacity = useSharedValue(1);
  const scale = useSharedValue(0);

  React.useEffect(() => {
    // ìŠ¤ì¼€ì¼ ë“±ì¥
    scale.value = withDelay(
      piece.delay,
      withSequence(
        withTiming(1.2, { duration: 100 }),
        withTiming(1, { duration: 100 })
      )
    );

    // ë‚™í•˜
    translateY.value = withDelay(
      piece.delay,
      withTiming(height + 100, {
        duration: duration,
        easing: Easing.in(Easing.quad),
      })
    );

    // ì¢Œìš° í”ë“¤ë¦¼
    translateX.value = withDelay(
      piece.delay,
      withRepeat(
        withSequence(
          withTiming(30, { duration: 300 }),
          withTiming(-30, { duration: 300 })
        ),
        -1,
        true
      )
    );

    // íšŒì „
    rotation.value = withDelay(
      piece.delay,
      withRepeat(
        withTiming(360 * piece.rotationSpeed, {
          duration: duration,
          easing: Easing.linear,
        }),
        -1,
        false
      )
    );

    // í˜ì´ë“œ ì•„ì›ƒ
    opacity.value = withDelay(
      piece.delay + duration * 0.7,
      withTiming(0, { duration: duration * 0.3 })
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    position: 'absolute',
    left: piece.x,
    width: piece.size,
    height: piece.size * 0.6,
    backgroundColor: piece.color,
    borderRadius: 2,
    transform: [
      { translateY: translateY.value },
      { translateX: translateX.value },
      { rotate: `${rotation.value}deg` },
      { scale: scale.value },
    ],
    opacity: opacity.value,
  }));

  return <Animated.View style={animatedStyle} />;
}
```

### ë³„ í­ë°œ íš¨ê³¼

```typescript
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withDelay,
  withTiming,
  withSequence,
} from 'react-native-reanimated';

interface StarBurstProps {
  size?: number;
  color?: string;
  onComplete?: () => void;
}

export function StarBurst({
  size = 200,
  color = '#FFD700',
  onComplete,
}: StarBurstProps) {
  const starCount = 12;
  const stars = Array.from({ length: starCount });

  return (
    <View style={[styles.burstContainer, { width: size, height: size }]}>
      {stars.map((_, index) => (
        <BurstStar
          key={index}
          index={index}
          total={starCount}
          size={size}
          color={color}
        />
      ))}
      <CenterStar size={size * 0.3} color={color} />
    </View>
  );
}

function BurstStar({
  index,
  total,
  size,
  color,
}: {
  index: number;
  total: number;
  size: number;
  color: string;
}) {
  const angle = (index / total) * 360;
  const distance = size * 0.4;

  const scale = useSharedValue(0);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const opacity = useSharedValue(0);

  React.useEffect(() => {
    const radians = (angle * Math.PI) / 180;
    const targetX = Math.cos(radians) * distance;
    const targetY = Math.sin(radians) * distance;

    scale.value = withDelay(
      index * 30,
      withSequence(
        withSpring(1.5, { damping: 8 }),
        withTiming(0, { duration: 500 })
      )
    );

    translateX.value = withDelay(
      index * 30,
      withSpring(targetX, { damping: 12, stiffness: 150 })
    );

    translateY.value = withDelay(
      index * 30,
      withSpring(targetY, { damping: 12, stiffness: 150 })
    );

    opacity.value = withDelay(
      index * 30,
      withSequence(
        withTiming(1, { duration: 100 }),
        withDelay(400, withTiming(0, { duration: 300 }))
      )
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    position: 'absolute',
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
    opacity: opacity.value,
  }));

  return (
    <Animated.Text style={[styles.star, { color }, animatedStyle]}>
      â˜…
    </Animated.Text>
  );
}

function CenterStar({ size, color }: { size: number; color: string }) {
  const scale = useSharedValue(0);

  React.useEffect(() => {
    scale.value = withSequence(
      withSpring(1.2, { damping: 4, stiffness: 300 }),
      withSpring(1, { damping: 6, stiffness: 200 })
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return (
    <Animated.Text style={[styles.centerStar, { fontSize: size, color }, animatedStyle]}>
      â˜…
    </Animated.Text>
  );
}

const styles = StyleSheet.create({
  burstContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  star: {
    fontSize: 24,
  },
  centerStar: {
    position: 'absolute',
  },
});
```

## ğŸ“± sometimes-app ì ìš© ì‚¬ë¡€

### ë§¤ì¹­ ì„±ê³µ í™”ë©´

```typescript
// src/features/matching/ui/MatchSuccessScreen.tsx
import React from 'react';
import { StyleSheet, View, Text, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withDelay,
  withSequence,
  withTiming,
  interpolate,
  Easing,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

const { width, height } = Dimensions.get('window');

interface MatchSuccessScreenProps {
  myPhoto: string;
  partnerPhoto: string;
  partnerName: string;
  onContinue: () => void;
}

export function MatchSuccessScreen({
  myPhoto,
  partnerPhoto,
  partnerName,
  onContinue,
}: MatchSuccessScreenProps) {
  const [showConfetti, setShowConfetti] = React.useState(false);

  React.useEffect(() => {
    // í–…í‹± í”¼ë“œë°±
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);

    // Confetti ë”œë ˆì´
    setTimeout(() => setShowConfetti(true), 500);
  }, []);

  return (
    <View style={styles.container}>
      {/* ë°°ê²½ ê¸€ë¡œìš° */}
      <BackgroundGlow />

      {/* í”„ë¡œí•„ ì¹´ë“œë“¤ */}
      <ProfileCards myPhoto={myPhoto} partnerPhoto={partnerPhoto} />

      {/* ë§¤ì¹­ í…ìŠ¤íŠ¸ */}
      <MatchText partnerName={partnerName} />

      {/* í•˜íŠ¸ ì• ë‹ˆë©”ì´ì…˜ */}
      <HeartAnimation />

      {/* Confetti */}
      {showConfetti && <Confetti count={60} duration={4000} />}

      {/* ê³„ì†í•˜ê¸° ë²„íŠ¼ */}
      <ContinueButton onPress={onContinue} />
    </View>
  );
}

function BackgroundGlow() {
  const scale = useSharedValue(0);
  const opacity = useSharedValue(0);

  React.useEffect(() => {
    scale.value = withSpring(1, { damping: 10, stiffness: 50 });
    opacity.value = withTiming(0.6, { duration: 1000 });
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
    opacity: opacity.value,
  }));

  return (
    <Animated.View style={[styles.glow, animatedStyle]}>
      <View style={styles.glowInner} />
    </Animated.View>
  );
}

function ProfileCards({
  myPhoto,
  partnerPhoto,
}: {
  myPhoto: string;
  partnerPhoto: string;
}) {
  const leftCard = useSharedValue(-width);
  const rightCard = useSharedValue(width);
  const rotation = useSharedValue(0);

  React.useEffect(() => {
    // ì¹´ë“œ ìŠ¬ë¼ì´ë“œ ì¸
    leftCard.value = withSpring(-60, {
      damping: 15,
      stiffness: 100,
    });

    rightCard.value = withSpring(60, {
      damping: 15,
      stiffness: 100,
    });

    // ì‚´ì§ íšŒì „
    rotation.value = withDelay(
      300,
      withSpring(0, { damping: 10, stiffness: 80 })
    );
  }, []);

  const leftStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: leftCard.value },
      { rotate: '-8deg' },
    ],
  }));

  const rightStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: rightCard.value },
      { rotate: '8deg' },
    ],
  }));

  return (
    <View style={styles.cardsContainer}>
      <Animated.View style={[styles.profileCard, leftStyle]}>
        <Image source={{ uri: myPhoto }} style={styles.profileImage} />
      </Animated.View>

      <Animated.View style={[styles.profileCard, rightStyle]}>
        <Image source={{ uri: partnerPhoto }} style={styles.profileImage} />
      </Animated.View>
    </View>
  );
}

function MatchText({ partnerName }: { partnerName: string }) {
  const opacity = useSharedValue(0);
  const translateY = useSharedValue(30);
  const scale = useSharedValue(0.8);

  React.useEffect(() => {
    opacity.value = withDelay(500, withTiming(1, { duration: 500 }));
    translateY.value = withDelay(
      500,
      withSpring(0, { damping: 15, stiffness: 100 })
    );
    scale.value = withDelay(
      500,
      withSequence(
        withSpring(1.1, { damping: 8, stiffness: 200 }),
        withSpring(1, { damping: 10, stiffness: 150 })
      )
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [
      { translateY: translateY.value },
      { scale: scale.value },
    ],
  }));

  return (
    <Animated.View style={[styles.textContainer, animatedStyle]}>
      <Text style={styles.matchLabel}>It's a Match! ğŸ’œ</Text>
      <Text style={styles.matchMessage}>
        {partnerName}ë‹˜ê³¼ ë§¤ì¹­ë˜ì—ˆì–´ìš”!
      </Text>
    </Animated.View>
  );
}

function HeartAnimation() {
  const scale = useSharedValue(0);
  const rotate = useSharedValue(0);

  React.useEffect(() => {
    scale.value = withDelay(
      300,
      withSequence(
        withSpring(1.5, { damping: 4, stiffness: 400 }),
        withSpring(1, { damping: 6, stiffness: 200 })
      )
    );

    rotate.value = withDelay(
      300,
      withSequence(
        withTiming(-15, { duration: 100 }),
        withTiming(15, { duration: 200 }),
        withSpring(0, { damping: 8 })
      )
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { scale: scale.value },
      { rotate: `${rotate.value}deg` },
    ],
  }));

  return (
    <Animated.View style={[styles.heartContainer, animatedStyle]}>
      <Text style={styles.heartEmoji}>ğŸ’œ</Text>
    </Animated.View>
  );
}

function ContinueButton({ onPress }: { onPress: () => void }) {
  const opacity = useSharedValue(0);
  const translateY = useSharedValue(50);

  React.useEffect(() => {
    opacity.value = withDelay(1500, withTiming(1, { duration: 500 }));
    translateY.value = withDelay(
      1500,
      withSpring(0, { damping: 15, stiffness: 100 })
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ translateY: translateY.value }],
  }));

  return (
    <Animated.View style={[styles.buttonContainer, animatedStyle]}>
      <Pressable style={styles.continueButton} onPress={onPress}>
        <Text style={styles.buttonText}>ëŒ€í™” ì‹œì‘í•˜ê¸°</Text>
      </Pressable>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#1A1A2E',
    justifyContent: 'center',
    alignItems: 'center',
  },
  glow: {
    position: 'absolute',
    width: width * 1.5,
    height: width * 1.5,
    borderRadius: width,
    justifyContent: 'center',
    alignItems: 'center',
  },
  glowInner: {
    width: '100%',
    height: '100%',
    borderRadius: 1000,
    backgroundColor: '#7A4AE2',
    opacity: 0.3,
  },
  cardsContainer: {
    flexDirection: 'row',
    marginBottom: 40,
  },
  profileCard: {
    width: 140,
    height: 180,
    borderRadius: 12,
    overflow: 'hidden',
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 10,
  },
  profileImage: {
    width: '100%',
    height: '100%',
  },
  heartContainer: {
    position: 'absolute',
    zIndex: 10,
  },
  heartEmoji: {
    fontSize: 80,
  },
  textContainer: {
    alignItems: 'center',
    marginTop: 30,
  },
  matchLabel: {
    fontSize: 32,
    fontWeight: 'bold',
    color: 'white',
  },
  matchMessage: {
    fontSize: 18,
    color: 'rgba(255,255,255,0.8)',
    marginTop: 8,
  },
  buttonContainer: {
    position: 'absolute',
    bottom: 60,
    left: 24,
    right: 24,
  },
  continueButton: {
    backgroundColor: '#7A4AE2',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: '600',
  },
});
```

## âš ï¸ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë° ì¶©ëŒ

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ë™ì‹œì— ì‹œì‘ë˜ì–´ ì–´ìƒ‰í•¨
scale.value = withSpring(1);
opacity.value = withTiming(1);
translateY.value = withSpring(0);

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ìˆœì°¨ì  ë”œë ˆì´ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ
scale.value = withSpring(1);
opacity.value = withDelay(100, withTiming(1, { duration: 300 }));
translateY.value = withDelay(200, withSpring(0));
```

### 2. ì—ëŸ¬ í”¼ë“œë°±ì´ ë„ˆë¬´ ê³µê²©ì 

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ê³¼í•œ í”ë“¤ë¦¼
shake.value = withRepeat(
  withTiming(20, { duration: 50 }),
  10, // ë„ˆë¬´ ë§ì€ ë°˜ë³µ
  true
);

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì ë‹¹í•œ í”ë“¤ë¦¼
shake.value = withSequence(
  withTiming(-8, { duration: 50 }),
  withTiming(8, { duration: 100 }),
  withTiming(-4, { duration: 100 }),
  withTiming(0, { duration: 50 })
);
```

### 3. í–…í‹± í”¼ë“œë°± ëˆ„ë½

```typescript
// âŒ ì˜ëª»ëœ ì˜ˆ: ì‹œê°ì  í”¼ë“œë°±ë§Œ
const handleSuccess = () => {
  showSuccessAnimation();
};

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í–…í‹± í¬í•¨
const handleSuccess = () => {
  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
  showSuccessAnimation();
};
```

## ğŸ’¡ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. Confetti íŒŒí‹°í´ ìˆ˜ ì œí•œ

```typescript
// ê¸°ê¸° ì„±ëŠ¥ì— ë”°ë¥¸ íŒŒí‹°í´ ìˆ˜ ì¡°ì ˆ
const getConfettiCount = () => {
  // ì €ì‚¬ì–‘ ê¸°ê¸° ì²´í¬
  if (Platform.OS === 'android') {
    const deviceYear = parseInt(Platform.Version.toString());
    if (deviceYear < 28) return 20; // Android 9 ë¯¸ë§Œ
  }
  return 50;
};
```

### 2. ì• ë‹ˆë©”ì´ì…˜ ì •ë¦¬

```typescript
React.useEffect(() => {
  // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
  scale.value = withRepeat(/*...*/);

  return () => {
    // ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬
    cancelAnimation(scale);
  };
}, []);
```

## ğŸ‹ï¸ ì—°ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: ì„±ê³µ ë±ƒì§€
ì‘ì—… ì™„ë£Œ ì‹œ í™”ë©´ ì¤‘ì•™ì—ì„œ ë±ƒì§€ê°€ íšŒì „í•˜ë©° ë‚˜íƒ€ë‚¬ë‹¤ê°€ ìœ„ë¡œ ë‚ ì•„ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•˜ì„¸ìš”.

### ë¬¸ì œ 2: ì—ëŸ¬ ë³µêµ¬ UI
ì—ëŸ¬ ë°œìƒ ì‹œ í”ë“¤ë¦¼ + ë¹¨ê°„ í…Œë‘ë¦¬ + "ë‹¤ì‹œ ì‹œë„" ë²„íŠ¼ì´ í„ìŠ¤í•˜ëŠ” UIë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

### ë¬¸ì œ 3: ë ˆë²¨ì—… íš¨ê³¼
ë ˆë²¨ì—… ì‹œ ìˆ«ìê°€ ì¹´ìš´íŠ¸ì—…ë˜ë©° ë³„ì´ í­ë°œí•˜ëŠ” íš¨ê³¼ë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

## ğŸ“š ì´ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©

1. **í”¼ë“œë°± ì‹¬ë¦¬í•™**: ì„±ê³µì€ ì¶•í•˜, ì‹¤íŒ¨ëŠ” ë¶€ë“œëŸ½ê²Œ
2. **ì²´í¬ë§ˆí¬**: SVG íŒ¨ìŠ¤ ë“œë¡œì‰, ë°”ìš´ìŠ¤ íš¨ê³¼
3. **ì—ëŸ¬ í‘œì‹œ**: X ë§ˆí¬, í”ë“¤ê¸°, í¼ í•„ë“œ ì—ëŸ¬
4. **í† ìŠ¤íŠ¸**: ìŠ¬ë¼ì´ë“œ, ìŠ¤ì™€ì´í”„ ê°€ëŠ¥
5. **ì¶•í•˜ íš¨ê³¼**: Confetti, ë³„ í­ë°œ
6. **í–…í‹± ì—°ë™**: ì‹œê° + ì´‰ê° í”¼ë“œë°±

## ë‹¤ìŒ ì¥ ì˜ˆê³ 

**Chapter 51: ì…ë ¥ í•„ë“œ ì¸í„°ë™ì…˜**ì—ì„œëŠ” í…ìŠ¤íŠ¸ ì…ë ¥ ì‹œ í”Œë ˆì´ìŠ¤í™€ë” ì• ë‹ˆë©”ì´ì…˜, í¬ì»¤ìŠ¤ íš¨ê³¼, ë¬¸ì ìˆ˜ ì¹´ìš´í„° ë“± í¼ ìš”ì†Œì˜ ë§ˆì´í¬ë¡œ ì¸í„°ë™ì…˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
